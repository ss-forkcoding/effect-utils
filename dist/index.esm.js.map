{"version":3,"file":"index.esm.js","sources":["../node_modules/effect/dist/esm/Function.js","../node_modules/effect/dist/esm/Equivalence.js","../node_modules/effect/dist/esm/internal/version.js","../node_modules/effect/dist/esm/GlobalValue.js","../node_modules/effect/dist/esm/Predicate.js","../node_modules/effect/dist/esm/internal/errors.js","../node_modules/effect/dist/esm/Utils.js","../node_modules/effect/dist/esm/Hash.js","../node_modules/effect/dist/esm/Equal.js","../node_modules/effect/dist/esm/Inspectable.js","../node_modules/effect/dist/esm/Pipeable.js","../node_modules/effect/dist/esm/internal/opCodes/effect.js","../node_modules/effect/dist/esm/internal/effectable.js","../node_modules/effect/dist/esm/internal/option.js","../node_modules/effect/dist/esm/internal/either.js","../node_modules/effect/dist/esm/Either.js","../node_modules/effect/dist/esm/Order.js","../node_modules/effect/dist/esm/Option.js","../node_modules/effect/dist/esm/Tuple.js","../node_modules/effect/dist/esm/Array.js","../node_modules/effect/dist/esm/internal/array.js","../node_modules/effect/dist/esm/Number.js","../node_modules/effect/dist/esm/internal/context.js","../node_modules/effect/dist/esm/Context.js","../node_modules/effect/dist/esm/Chunk.js","../node_modules/effect/dist/esm/Duration.js","../node_modules/effect/dist/esm/internal/hashMap/config.js","../node_modules/effect/dist/esm/internal/hashMap/bitwise.js","../node_modules/effect/dist/esm/internal/stack.js","../node_modules/effect/dist/esm/internal/hashMap/array.js","../node_modules/effect/dist/esm/internal/hashMap/node.js","../node_modules/effect/dist/esm/internal/hashMap.js","../node_modules/effect/dist/esm/internal/hashSet.js","../node_modules/effect/dist/esm/HashSet.js","../node_modules/effect/dist/esm/internal/fiberId.js","../node_modules/effect/dist/esm/FiberId.js","../node_modules/effect/dist/esm/HashMap.js","../node_modules/effect/dist/esm/List.js","../node_modules/effect/dist/esm/internal/data.js","../node_modules/effect/dist/esm/internal/differ/chunkPatch.js","../node_modules/effect/dist/esm/internal/differ/contextPatch.js","../node_modules/effect/dist/esm/internal/differ/hashMapPatch.js","../node_modules/effect/dist/esm/internal/differ/hashSetPatch.js","../node_modules/effect/dist/esm/internal/differ/orPatch.js","../node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js","../node_modules/effect/dist/esm/internal/differ.js","../node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js","../node_modules/effect/dist/esm/internal/runtimeFlags.js","../node_modules/effect/dist/esm/RuntimeFlagsPatch.js","../node_modules/effect/dist/esm/internal/opCodes/cause.js","../node_modules/effect/dist/esm/internal/cause.js","../node_modules/effect/dist/esm/internal/singleShotGen.js","../node_modules/effect/dist/esm/internal/core.js","../node_modules/effect/dist/esm/internal/clock.js","../node_modules/effect/dist/esm/internal/opCodes/configError.js","../node_modules/effect/dist/esm/internal/configError.js","../node_modules/effect/dist/esm/internal/configProvider/pathPatch.js","../node_modules/effect/dist/esm/internal/configProvider.js","../node_modules/effect/dist/esm/internal/opCodes/config.js","../node_modules/effect/dist/esm/RegExp.js","../node_modules/effect/dist/esm/internal/defaultServices/console.js","../node_modules/effect/dist/esm/internal/random.js","../node_modules/effect/dist/esm/internal/tracer.js","../node_modules/effect/dist/esm/internal/defaultServices.js","../node_modules/effect/dist/esm/internal/logger.js","../node_modules/effect/dist/esm/internal/console.js","../node_modules/effect/dist/esm/Console.js","../node_modules/effect/dist/esm/internal/matcher.js","../node_modules/effect/dist/esm/Match.js"],"sourcesContent":["/**\n * Tests if a value is a `function`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isFunction } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isFunction = input => typeof input === \"function\";\n/**\n * Creates a function that can be used in a data-last (aka `pipe`able) or\n * data-first style.\n *\n * The first parameter to `dual` is either the arity of the uncurried function\n * or a predicate that determines if the function is being used in a data-first\n * or data-last style.\n *\n * Using the arity is the most common use case, but there are some cases where\n * you may want to use a predicate. For example, if you have a function that\n * takes an optional argument, you can use a predicate to determine if the\n * function is being used in a data-first or data-last style.\n *\n * You can pass either the arity of the uncurried function or a predicate\n * which determines if the function is being used in a data-first or\n * data-last style.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { dual, pipe } from \"effect/Function\"\n *\n * // Exampe using arity to determine data-first or data-last style\n * const sum: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual(2, (self: number, that: number): number => self + that)\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * assert.deepStrictEqual(pipe(2, sum(3)), 5)\n *\n * // Example using a predicate to determine data-first or data-last style\n * const sum2: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual((args) => args.length === 1, (self: number, that: number): number => self + that)\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * assert.deepStrictEqual(pipe(2, sum(3)), 5)\n * ```\n *\n * @since 2.0.0\n */\nexport const dual = function (arity, body) {\n  if (typeof arity === \"function\") {\n    return function () {\n      if (arity(arguments)) {\n        // @ts-expect-error\n        return body.apply(this, arguments);\n      }\n      return self => body(self, ...arguments);\n    };\n  }\n  switch (arity) {\n    case 0:\n    case 1:\n      throw new RangeError(`Invalid arity ${arity}`);\n    case 2:\n      return function (a, b) {\n        if (arguments.length >= 2) {\n          return body(a, b);\n        }\n        return function (self) {\n          return body(self, a);\n        };\n      };\n    case 3:\n      return function (a, b, c) {\n        if (arguments.length >= 3) {\n          return body(a, b, c);\n        }\n        return function (self) {\n          return body(self, a, b);\n        };\n      };\n    case 4:\n      return function (a, b, c, d) {\n        if (arguments.length >= 4) {\n          return body(a, b, c, d);\n        }\n        return function (self) {\n          return body(self, a, b, c);\n        };\n      };\n    case 5:\n      return function (a, b, c, d, e) {\n        if (arguments.length >= 5) {\n          return body(a, b, c, d, e);\n        }\n        return function (self) {\n          return body(self, a, b, c, d);\n        };\n      };\n    default:\n      return function () {\n        if (arguments.length >= arity) {\n          // @ts-expect-error\n          return body.apply(this, arguments);\n        }\n        const args = arguments;\n        return function (self) {\n          return body(self, ...args);\n        };\n      };\n  }\n};\n/**\n * Apply a function to a given value.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, apply } from \"effect/Function\"\n * import { length } from \"effect/String\"\n *\n * assert.deepStrictEqual(pipe(length, apply(\"hello\")), 5)\n * ```\n *\n * @since 2.0.0\n */\nexport const apply = a => self => self(a);\n/**\n * The identity function, i.e. A function that returns its input argument.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { identity } from \"effect/Function\"\n *\n * assert.deepStrictEqual(identity(5), 5)\n * ```\n *\n * @since 2.0.0\n */\nexport const identity = a => a;\n/**\n * A function that ensures that the type of an expression matches some type,\n * without changing the resulting type of that expression.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { satisfies } from \"effect/Function\"\n *\n * const test1 = satisfies<number>()(5 as const)\n *     //^? const test: 5\n *     // @ts-expect-error\n * const test2 = satisfies<string>()(5)\n *     //^? Argument of type 'number' is not assignable to parameter of type 'string'\n *\n * assert.deepStrictEqual(satisfies<number>()(5), 5)\n * ```\n *\n * @since 2.0.0\n */\nexport const satisfies = () => b => b;\n/**\n * Casts the result to the specified type.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { unsafeCoerce, identity } from \"effect/Function\"\n *\n * assert.deepStrictEqual(unsafeCoerce, identity)\n * ```\n *\n * @since 2.0.0\n */\nexport const unsafeCoerce = identity;\n/**\n * Creates a constant value that never changes.\n *\n * This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)\n * and want that inner function to always use the same value, no matter how many times it is called.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constant } from \"effect/Function\"\n *\n * const constNull = constant(null)\n *\n * assert.deepStrictEqual(constNull(), null)\n * assert.deepStrictEqual(constNull(), null)\n * ```\n *\n * @since 2.0.0\n */\nexport const constant = value => () => value;\n/**\n * A thunk that returns always `true`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constTrue } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constTrue(), true)\n * ```\n *\n * @since 2.0.0\n */\nexport const constTrue = /*#__PURE__*/constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constFalse } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constFalse(), false)\n * ```\n *\n * @since 2.0.0\n */\nexport const constFalse = /*#__PURE__*/constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constNull } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constNull(), null)\n * ```\n *\n * @since 2.0.0\n */\nexport const constNull = /*#__PURE__*/constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constUndefined } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constUndefined(), undefined)\n * ```\n *\n * @since 2.0.0\n */\nexport const constUndefined = /*#__PURE__*/constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { constVoid } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constVoid(), undefined)\n * ```\n *\n * @since 2.0.0\n */\nexport const constVoid = constUndefined;\n/**\n * Reverses the order of arguments for a curried function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { flip } from \"effect/Function\"\n *\n * const f = (a: number) => (b: string) => a - b.length\n *\n * assert.deepStrictEqual(flip(f)('aaa')(2), -1)\n * ```\n *\n * @since 2.0.0\n */\nexport const flip = f => (...b) => (...a) => f(...a)(...b);\n/**\n * Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\n * The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { compose } from \"effect/Function\"\n *\n * const increment = (n: number) => n + 1;\n * const square = (n: number) => n * n;\n *\n * assert.strictEqual(compose(increment, square)(2), 9);\n * ```\n *\n * @since 2.0.0\n */\nexport const compose = /*#__PURE__*/dual(2, (ab, bc) => a => bc(ab(a)));\n/**\n * The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,\n * meaning that it should be impossible for this code to be executed.\n *\n * This function is particularly useful when it's necessary to specify that certain cases are impossible.\n *\n * @since 2.0.0\n */\nexport const absurd = _ => {\n  throw new Error(\"Called `absurd` function which should be uncallable\");\n};\n/**\n * Creates a   version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { tupled } from \"effect/Function\"\n *\n * const sumTupled = tupled((x: number, y: number): number => x + y)\n *\n * assert.deepStrictEqual(sumTupled([1, 2]), 3)\n * ```\n *\n * @since 2.0.0\n */\nexport const tupled = f => a => f(...a);\n/**\n * Inverse function of `tupled`\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { untupled } from \"effect/Function\"\n *\n * const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])\n *\n * assert.deepStrictEqual(getFirst(1, 2), 1)\n * ```\n *\n * @since 2.0.0\n */\nexport const untupled = f => (...a) => f(a);\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n  switch (arguments.length) {\n    case 1:\n      return a;\n    case 2:\n      return ab(a);\n    case 3:\n      return bc(ab(a));\n    case 4:\n      return cd(bc(ab(a)));\n    case 5:\n      return de(cd(bc(ab(a))));\n    case 6:\n      return ef(de(cd(bc(ab(a)))));\n    case 7:\n      return fg(ef(de(cd(bc(ab(a))))));\n    case 8:\n      return gh(fg(ef(de(cd(bc(ab(a)))))));\n    case 9:\n      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n    default:\n      {\n        let ret = arguments[0];\n        for (let i = 1; i < arguments.length; i++) {\n          ret = arguments[i](ret);\n        }\n        return ret;\n      }\n  }\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n  switch (arguments.length) {\n    case 1:\n      return ab;\n    case 2:\n      return function () {\n        return bc(ab.apply(this, arguments));\n      };\n    case 3:\n      return function () {\n        return cd(bc(ab.apply(this, arguments)));\n      };\n    case 4:\n      return function () {\n        return de(cd(bc(ab.apply(this, arguments))));\n      };\n    case 5:\n      return function () {\n        return ef(de(cd(bc(ab.apply(this, arguments)))));\n      };\n    case 6:\n      return function () {\n        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n      };\n    case 7:\n      return function () {\n        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n      };\n    case 8:\n      return function () {\n        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n      };\n    case 9:\n      return function () {\n        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n      };\n  }\n  return;\n}\n/**\n * Type hole simulation.\n *\n * @since 2.0.0\n */\nexport const hole = /*#__PURE__*/unsafeCoerce(absurd);\n/**\n * The SK combinator, also known as the \"S-K combinator\" or \"S-combinator\", is a fundamental combinator in the\n * lambda calculus and the SKI combinator calculus.\n *\n * This function is useful for discarding the first argument passed to it and returning the second argument.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { SK } from \"effect/Function\";\n *\n * assert.deepStrictEqual(SK(0, \"hello\"), \"hello\")\n * ```\n *\n * @since 2.0.0\n */\nexport const SK = (_, b) => b;\n//# sourceMappingURL=Function.js.map","/**\n * This module provides an implementation of the `Equivalence` type class, which defines a binary relation\n * that is reflexive, symmetric, and transitive. In other words, it defines a notion of equivalence between values of a certain type.\n * These properties are also known in mathematics as an \"equivalence relation\".\n *\n * @since 2.0.0\n */\nimport { dual } from \"./Function.js\";\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const make = isEquivalent => (self, that) => self === that || isEquivalent(self, that);\nconst isStrictEquivalent = (x, y) => x === y;\n/**\n * Return an `Equivalence` that uses strict equality (===) to compare values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const strict = () => isStrictEquivalent;\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const string = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const number = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const boolean = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const bigint = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const symbol = /*#__PURE__*/strict();\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combine = /*#__PURE__*/dual(2, (self, that) => make((x, y) => self(x, y) && that(x, y)));\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combineMany = /*#__PURE__*/dual(2, (self, collection) => make((x, y) => {\n  if (!self(x, y)) {\n    return false;\n  }\n  for (const equivalence of collection) {\n    if (!equivalence(x, y)) {\n      return false;\n    }\n  }\n  return true;\n}));\nconst isAlwaysEquivalent = (_x, _y) => true;\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combineAll = collection => combineMany(isAlwaysEquivalent, collection);\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport const mapInput = /*#__PURE__*/dual(2, (self, f) => make((x, y) => self(f(x), f(y))));\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Date = /*#__PURE__*/mapInput(number, date => date.getTime());\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const product = /*#__PURE__*/dual(2, (self, that) => make(([xa, xb], [ya, yb]) => self(xa, ya) && that(xb, yb)));\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const all = collection => {\n  return make((x, y) => {\n    const len = Math.min(x.length, y.length);\n    let collectionLength = 0;\n    for (const equivalence of collection) {\n      if (collectionLength >= len) {\n        break;\n      }\n      if (!equivalence(x[collectionLength], y[collectionLength])) {\n        return false;\n      }\n      collectionLength++;\n    }\n    return true;\n  });\n};\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const productMany = (self, collection) => {\n  const equivalence = all(collection);\n  return make((x, y) => !self(x[0], y[0]) ? false : equivalence(x.slice(1), y.slice(1)));\n};\n/**\n * Similar to `Promise.all` but operates on `Equivalence`s.\n *\n * ```ts skip-type-checking\n * [Equivalence<A>, Equivalence<B>, ...] -> Equivalence<[A, B, ...]>\n * ```\n *\n * Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\n * by applying each `Equivalence` to the corresponding element of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const tuple = (...elements) => all(elements);\n/**\n * Creates a new `Equivalence` for an array of values based on a given `Equivalence` for the elements of the array.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const array = item => make((self, that) => {\n  if (self.length !== that.length) {\n    return false;\n  }\n  for (let i = 0; i < self.length; i++) {\n    const isEq = item(self[i], that[i]);\n    if (!isEq) {\n      return false;\n    }\n  }\n  return true;\n});\n/**\n * Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct\n * by applying each `Equivalence` to the corresponding property of the struct.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const struct = fields => {\n  const keys = Object.keys(fields);\n  return make((self, that) => {\n    for (const key of keys) {\n      if (!fields[key](self[key], that[key])) {\n        return false;\n      }\n    }\n    return true;\n  });\n};\n//# sourceMappingURL=Equivalence.js.map","let moduleVersion = \"3.13.10\";\nexport const getCurrentVersion = () => moduleVersion;\nexport const setCurrentVersion = version => {\n  moduleVersion = version;\n};\n//# sourceMappingURL=version.js.map","/**\n * The `GlobalValue` module ensures that a single instance of a value is created globally,\n * even when modules are imported multiple times (e.g., due to mixing CommonJS and ESM builds)\n * or during hot-reloading in development environments like Next.js or Remix.\n *\n * It achieves this by using a versioned global store, identified by a unique `Symbol` tied to\n * the current version of the `effect` library. The store holds values that are keyed by an identifier,\n * allowing the reuse of previously computed instances across imports or reloads.\n *\n * This pattern is particularly useful in scenarios where frequent reloading can cause services or\n * single-instance objects to be recreated unnecessarily, such as in development environments with hot-reloading.\n *\n * @since 2.0.0\n */\nimport * as version from \"./internal/version.js\";\nconst globalStoreId = `effect/GlobalValue/globalStoreId/${/*#__PURE__*/version.getCurrentVersion()}`;\nlet globalStore;\n/**\n * Retrieves or computes a global value associated with the given `id`. If the value for this `id`\n * has already been computed, it will be returned from the global store. If it does not exist yet,\n * the provided `compute` function will be executed to compute the value, store it, and then return it.\n *\n * This ensures that even in cases where the module is imported multiple times (e.g., in mixed environments\n * like CommonJS and ESM, or during hot-reloading in development), the value is computed only once and reused\n * thereafter.\n *\n * @example\n * ```ts\n * import { globalValue } from \"effect/GlobalValue\"\n *\n * // This cache will persist as long as the module is running,\n * // even if reloaded or imported elsewhere\n * const myCache = globalValue(\n *   Symbol.for(\"myCache\"),\n *   () => new WeakMap<object, number>()\n * )\n * ```\n *\n * @since 2.0.0\n */\nexport const globalValue = (id, compute) => {\n  if (!globalStore) {\n    // @ts-expect-error\n    globalThis[globalStoreId] ??= new Map();\n    // @ts-expect-error\n    globalStore = globalThis[globalStoreId];\n  }\n  if (!globalStore.has(id)) {\n    globalStore.set(id, compute());\n  }\n  return globalStore.get(id);\n};\n//# sourceMappingURL=GlobalValue.js.map","/**\n * @since 2.0.0\n */\nimport { dual, isFunction as isFunction_ } from \"./Function.js\";\n/**\n * Given a `Predicate<A>` returns a `Predicate<B>`\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate, Number } from \"effect\"\n *\n * const minLength3 = Predicate.mapInput(Number.greaterThan(2), (s: string) => s.length)\n *\n * assert.deepStrictEqual(minLength3(\"a\"), false)\n * assert.deepStrictEqual(minLength3(\"aa\"), false)\n * assert.deepStrictEqual(minLength3(\"aaa\"), true)\n * assert.deepStrictEqual(minLength3(\"aaaa\"), true)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const mapInput = /*#__PURE__*/dual(2, (self, f) => b => self(f(b)));\n/**\n * Determine if an `Array` is a tuple with exactly `N` elements, narrowing down the type to `TupleOf`.\n *\n * An `Array` is considered to be a `TupleOf` if its length is exactly `N`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isTupleOf } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isTupleOf([1, 2, 3], 3), true);\n * assert.deepStrictEqual(isTupleOf([1, 2, 3], 2), false);\n * assert.deepStrictEqual(isTupleOf([1, 2, 3], 4), false);\n *\n * const arr: number[] = [1, 2, 3];\n * if (isTupleOf(arr, 3)) {\n *   console.log(arr);\n *   // ^? [number, number, number]\n * }\n * ```\n *\n * @category guards\n * @since 3.3.0\n */\nexport const isTupleOf = /*#__PURE__*/dual(2, (self, n) => self.length === n);\n/**\n * Determine if an `Array` is a tuple with at least `N` elements, narrowing down the type to `TupleOfAtLeast`.\n *\n * An `Array` is considered to be a `TupleOfAtLeast` if its length is at least `N`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isTupleOfAtLeast } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 3), true);\n * assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 2), true);\n * assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 4), false);\n *\n * const arr: number[] = [1, 2, 3, 4];\n * if (isTupleOfAtLeast(arr, 3)) {\n *   console.log(arr);\n *   // ^? [number, number, number, ...number[]]\n * }\n * ```\n *\n * @category guards\n * @since 3.3.0\n */\nexport const isTupleOfAtLeast = /*#__PURE__*/dual(2, (self, n) => self.length >= n);\n/**\n * Tests if a value is `truthy`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isTruthy } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isTruthy(1), true)\n * assert.deepStrictEqual(isTruthy(0), false)\n * assert.deepStrictEqual(isTruthy(\"\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isTruthy = input => !!input;\n/**\n * Tests if a value is a `Set`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isSet } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isSet(new Set([1, 2])), true)\n * assert.deepStrictEqual(isSet(new Set()), true)\n * assert.deepStrictEqual(isSet({}), false)\n * assert.deepStrictEqual(isSet(null), false)\n * assert.deepStrictEqual(isSet(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isSet = input => input instanceof Set;\n/**\n * Tests if a value is a `Map`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isMap } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isMap(new Map()), true)\n * assert.deepStrictEqual(isMap({}), false)\n * assert.deepStrictEqual(isMap(null), false)\n * assert.deepStrictEqual(isMap(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isMap = input => input instanceof Map;\n/**\n * Tests if a value is a `string`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isString } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isString(\"a\"), true)\n *\n * assert.deepStrictEqual(isString(1), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isString = input => typeof input === \"string\";\n/**\n * Tests if a value is a `number`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNumber } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNumber(2), true)\n *\n * assert.deepStrictEqual(isNumber(\"2\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNumber = input => typeof input === \"number\";\n/**\n * Tests if a value is a `boolean`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isBoolean } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isBoolean(true), true)\n *\n * assert.deepStrictEqual(isBoolean(\"true\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isBoolean = input => typeof input === \"boolean\";\n/**\n * Tests if a value is a `bigint`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isBigInt } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isBigInt(1n), true)\n *\n * assert.deepStrictEqual(isBigInt(1), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isBigInt = input => typeof input === \"bigint\";\n/**\n * Tests if a value is a `symbol`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isSymbol } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isSymbol(Symbol.for(\"a\")), true)\n *\n * assert.deepStrictEqual(isSymbol(\"a\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isSymbol = input => typeof input === \"symbol\";\n/**\n * Tests if a value is a `function`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isFunction } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n *\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isFunction = isFunction_;\n/**\n * Tests if a value is `undefined`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isUndefined } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUndefined(undefined), true)\n *\n * assert.deepStrictEqual(isUndefined(null), false)\n * assert.deepStrictEqual(isUndefined(\"undefined\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isUndefined = input => input === undefined;\n/**\n * Tests if a value is not `undefined`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNotUndefined } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotUndefined(null), true)\n * assert.deepStrictEqual(isNotUndefined(\"undefined\"), true)\n *\n * assert.deepStrictEqual(isNotUndefined(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNotUndefined = input => input !== undefined;\n/**\n * Tests if a value is `null`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNull } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNull(null), true)\n *\n * assert.deepStrictEqual(isNull(undefined), false)\n * assert.deepStrictEqual(isNull(\"null\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNull = input => input === null;\n/**\n * Tests if a value is not `null`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNotNull } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotNull(undefined), true)\n * assert.deepStrictEqual(isNotNull(\"null\"), true)\n *\n * assert.deepStrictEqual(isNotNull(null), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNotNull = input => input !== null;\n/**\n * A guard that always fails.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNever } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNever(null), false)\n * assert.deepStrictEqual(isNever(undefined), false)\n * assert.deepStrictEqual(isNever({}), false)\n * assert.deepStrictEqual(isNever([]), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNever = _ => false;\n/**\n * A guard that always succeeds.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isUnknown } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUnknown(null), true)\n * assert.deepStrictEqual(isUnknown(undefined), true)\n *\n * assert.deepStrictEqual(isUnknown({}), true)\n * assert.deepStrictEqual(isUnknown([]), true)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isUnknown = _ => true;\n/** @internal */\nexport const isRecordOrArray = input => typeof input === \"object\" && input !== null;\n/**\n * Tests if a value is an `object`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isObject } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isObject({}), true)\n * assert.deepStrictEqual(isObject([]), true)\n *\n * assert.deepStrictEqual(isObject(null), false)\n * assert.deepStrictEqual(isObject(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isObject = input => isRecordOrArray(input) || isFunction(input);\n/**\n * Checks whether a value is an `object` containing a specified property key.\n *\n * @category guards\n * @since 2.0.0\n */\nexport const hasProperty = /*#__PURE__*/dual(2, (self, property) => isObject(self) && property in self);\n/**\n * Tests if a value is an `object` with a property `_tag` that matches the given tag.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isTagged } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isTagged(1, \"a\"), false)\n * assert.deepStrictEqual(isTagged(null, \"a\"), false)\n * assert.deepStrictEqual(isTagged({}, \"a\"), false)\n * assert.deepStrictEqual(isTagged({ a: \"a\" }, \"a\"), false)\n * assert.deepStrictEqual(isTagged({ _tag: \"a\" }, \"a\"), true)\n * assert.deepStrictEqual(isTagged(\"a\")({ _tag: \"a\" }), true)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isTagged = /*#__PURE__*/dual(2, (self, tag) => hasProperty(self, \"_tag\") && self[\"_tag\"] === tag);\n/**\n * A guard that succeeds when the input is `null` or `undefined`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNullable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNullable(null), true)\n * assert.deepStrictEqual(isNullable(undefined), true)\n *\n * assert.deepStrictEqual(isNullable({}), false)\n * assert.deepStrictEqual(isNullable([]), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNullable = input => input === null || input === undefined;\n/**\n * A guard that succeeds when the input is not `null` or `undefined`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNotNullable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotNullable({}), true)\n * assert.deepStrictEqual(isNotNullable([]), true)\n *\n * assert.deepStrictEqual(isNotNullable(null), false)\n * assert.deepStrictEqual(isNotNullable(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNotNullable = input => input !== null && input !== undefined;\n/**\n * A guard that succeeds when the input is an `Error`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isError } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isError(new Error()), true)\n *\n * assert.deepStrictEqual(isError(null), false)\n * assert.deepStrictEqual(isError({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isError = input => input instanceof Error;\n/**\n * A guard that succeeds when the input is a `Uint8Array`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isUint8Array } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUint8Array(new Uint8Array()), true)\n *\n * assert.deepStrictEqual(isUint8Array(null), false)\n * assert.deepStrictEqual(isUint8Array({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isUint8Array = input => input instanceof Uint8Array;\n/**\n * A guard that succeeds when the input is a `Date`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isDate } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isDate(new Date()), true)\n *\n * assert.deepStrictEqual(isDate(null), false)\n * assert.deepStrictEqual(isDate({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isDate = input => input instanceof Date;\n/**\n * A guard that succeeds when the input is an `Iterable`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isIterable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isIterable([]), true)\n * assert.deepStrictEqual(isIterable(new Set()), true)\n *\n * assert.deepStrictEqual(isIterable(null), false)\n * assert.deepStrictEqual(isIterable({}), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isIterable = input => hasProperty(input, Symbol.iterator);\n/**\n * A guard that succeeds when the input is a record.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isRecord } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isRecord({}), true)\n * assert.deepStrictEqual(isRecord({ a: 1 }), true)\n *\n * assert.deepStrictEqual(isRecord([]), false)\n * assert.deepStrictEqual(isRecord([1, 2, 3]), false)\n * assert.deepStrictEqual(isRecord(null), false)\n * assert.deepStrictEqual(isRecord(undefined), false)\n * assert.deepStrictEqual(isRecord(() => null), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isRecord = input => isRecordOrArray(input) && !Array.isArray(input);\n/**\n * A guard that succeeds when the input is a readonly record.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isReadonlyRecord } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isReadonlyRecord({}), true)\n * assert.deepStrictEqual(isReadonlyRecord({ a: 1 }), true)\n *\n * assert.deepStrictEqual(isReadonlyRecord([]), false)\n * assert.deepStrictEqual(isReadonlyRecord([1, 2, 3]), false)\n * assert.deepStrictEqual(isReadonlyRecord(null), false)\n * assert.deepStrictEqual(isReadonlyRecord(undefined), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isReadonlyRecord = isRecord;\n/**\n * A guard that succeeds when the input is a Promise.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isPromise } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isPromise({}), false)\n * assert.deepStrictEqual(isPromise(Promise.resolve(\"hello\")), true)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isPromise = input => hasProperty(input, \"then\") && \"catch\" in input && isFunction(input.then) && isFunction(input.catch);\n/**\n * @category guards\n * @since 2.0.0\n */\nexport const isPromiseLike = input => hasProperty(input, \"then\") && isFunction(input.then);\n/**\n * Tests if a value is a `RegExp`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * assert.deepStrictEqual(Predicate.isRegExp(/a/), true)\n * assert.deepStrictEqual(Predicate.isRegExp(\"a\"), false)\n * ```\n *\n * @category guards\n * @since 3.9.0\n */\nexport const isRegExp = input => input instanceof RegExp;\n/**\n * @since 2.0.0\n */\nexport const compose = /*#__PURE__*/dual(2, (ab, bc) => a => ab(a) && bc(a));\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const product = (self, that) => ([a, b]) => self(a) && that(b);\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const all = collection => {\n  return as => {\n    let collectionIndex = 0;\n    for (const p of collection) {\n      if (collectionIndex >= as.length) {\n        break;\n      }\n      if (p(as[collectionIndex]) === false) {\n        return false;\n      }\n      collectionIndex++;\n    }\n    return true;\n  };\n};\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const productMany = (self, collection) => {\n  const rest = all(collection);\n  return ([head, ...tail]) => self(head) === false ? false : rest(tail);\n};\n/**\n * Similar to `Promise.all` but operates on `Predicate`s.\n *\n * ```ts skip-type-checking\n * [Refinement<A, B>, Refinement<C, D>, ...] -> Refinement<[A, C, ...], [B, D, ...]>\n * [Predicate<A>, Predicate<B>, ...] -> Predicate<[A, B, ...]>\n * [Refinement<A, B>, Predicate<C>, ...] -> Refinement<[A, C, ...], [B, C, ...]>\n * ```\n *\n * @since 2.0.0\n */\nexport const tuple = (...elements) => all(elements);\n/**\n * ```ts skip-type-checking\n * { ab: Refinement<A, B>; cd: Refinement<C, D>, ... } -> Refinement<{ ab: A; cd: C; ... }, { ab: B; cd: D; ... }>\n * { a: Predicate<A, B>; b: Predicate<B>, ... } -> Predicate<{ a: A; b: B; ... }>\n * { ab: Refinement<A, B>; c: Predicate<C>, ... } -> Refinement<{ ab: A; c: C; ... }, { ab: B; c: С; ... }>\n * ```\n *\n * @since 2.0.0\n */\nexport const struct = fields => {\n  const keys = Object.keys(fields);\n  return a => {\n    for (const key of keys) {\n      if (!fields[key](a[key])) {\n        return false;\n      }\n    }\n    return true;\n  };\n};\n/**\n * Negates the result of a given predicate.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate, Number } from \"effect\"\n *\n * const isPositive = Predicate.not(Number.lessThan(0))\n *\n * assert.deepStrictEqual(isPositive(-1), false)\n * assert.deepStrictEqual(isPositive(0), true)\n * assert.deepStrictEqual(isPositive(1), true)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const not = self => a => !self(a);\n/**\n * Combines two predicates into a new predicate that returns `true` if at least one of the predicates returns `true`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate, Number } from \"effect\"\n *\n * const nonZero = Predicate.or(Number.lessThan(0), Number.greaterThan(0))\n *\n * assert.deepStrictEqual(nonZero(-1), true)\n * assert.deepStrictEqual(nonZero(0), false)\n * assert.deepStrictEqual(nonZero(1), true)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const or = /*#__PURE__*/dual(2, (self, that) => a => self(a) || that(a));\n/**\n * Combines two predicates into a new predicate that returns `true` if both of the predicates returns `true`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * const minLength = (n: number) => (s: string) => s.length >= n\n * const maxLength = (n: number) => (s: string) => s.length <= n\n *\n * const length = (n: number) => Predicate.and(minLength(n), maxLength(n))\n *\n * assert.deepStrictEqual(length(2)(\"aa\"), true)\n * assert.deepStrictEqual(length(2)(\"a\"), false)\n * assert.deepStrictEqual(length(2)(\"aaa\"), false)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const and = /*#__PURE__*/dual(2, (self, that) => a => self(a) && that(a));\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport const xor = /*#__PURE__*/dual(2, (self, that) => a => self(a) !== that(a));\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport const eqv = /*#__PURE__*/dual(2, (self, that) => a => self(a) === that(a));\n/**\n * Represents the logical implication combinator for predicates. In formal\n * logic, the implication operator `->` denotes that if the first proposition\n * (antecedent) is true, then the second proposition (consequent) must also be\n * true. In simpler terms, `p implies q` can be interpreted as \"if p then q\". If\n * the first predicate holds, then the second predicate must hold\n * for the given context.\n *\n * In practical terms within TypeScript, `p implies q` is equivalent to `!p || (p && q)`.\n *\n * Note that if the antecedent is `false`, the result is `true` by default\n * because the outcome of the consequent cannot be determined.\n *\n * This function is useful in situations where you need to enforce rules or\n * constraints that are contingent on certain conditions.\n * It proves especially helpful in defining property tests.\n *\n * The example below illustrates the transitive property of order using the\n * `implies` function. In simple terms, if `a <= b` and `b <= c`, then `a <= c`\n * must be true.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * type Triple = {\n *   readonly a: number\n *   readonly b: number\n *   readonly c: number\n * }\n *\n * const transitivity = Predicate.implies(\n *   // antecedent\n *   (input: Triple) => input.a <= input.b && input.b <= input.c,\n *   // consequent\n *   (input: Triple) => input.a <= input.c\n * )\n *\n * assert.equal(transitivity({ a: 1, b: 2, c: 3 }), true)\n * // antecedent is `false`, so the result is `true`\n * assert.equal(transitivity({ a: 1, b: 0, c: 0 }), true)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const implies = /*#__PURE__*/dual(2, (antecedent, consequent) => a => antecedent(a) ? consequent(a) : true);\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport const nor = /*#__PURE__*/dual(2, (self, that) => a => !(self(a) || that(a)));\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport const nand = /*#__PURE__*/dual(2, (self, that) => a => !(self(a) && that(a)));\n/**\n * @category elements\n * @since 2.0.0\n */\nexport const every = collection => a => {\n  for (const p of collection) {\n    if (!p(a)) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * @category elements\n * @since 2.0.0\n */\nexport const some = collection => a => {\n  for (const p of collection) {\n    if (p(a)) {\n      return true;\n    }\n  }\n  return false;\n};\n//# sourceMappingURL=Predicate.js.map","/**\n * @since 2.0.0\n */\n/** @internal */\nexport const getBugErrorMessage = message => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;\n//# sourceMappingURL=errors.js.map","/**\n * @since 2.0.0\n */\nimport { identity } from \"./Function.js\";\nimport { globalValue } from \"./GlobalValue.js\";\nimport { getBugErrorMessage } from \"./internal/errors.js\";\nimport { isNullable, isObject } from \"./Predicate.js\";\n/*\n * Copyright 2014 Thom Chiovoloni, released under the MIT license.\n *\n * A random number generator based on the basic implementation of the PCG algorithm,\n * as described here: http://www.pcg-random.org/\n *\n * Adapted for TypeScript from Thom's original code at https://github.com/thomcc/pcg-random\n *\n * forked from https://github.com/frptools\n *\n * @since 2.0.0\n */\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport const GenKindTypeId = /*#__PURE__*/Symbol.for(\"effect/Gen/GenKind\");\n/**\n * @category predicates\n * @since 3.0.6\n */\nexport const isGenKind = u => isObject(u) && GenKindTypeId in u;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport class GenKindImpl {\n  value;\n  constructor(\n  /**\n   * @since 2.0.0\n   */\n  value) {\n    this.value = value;\n  }\n  /**\n   * @since 2.0.0\n   */\n  get _F() {\n    return identity;\n  }\n  /**\n   * @since 2.0.0\n   */\n  get _R() {\n    return _ => _;\n  }\n  /**\n   * @since 2.0.0\n   */\n  get _O() {\n    return _ => _;\n  }\n  /**\n   * @since 2.0.0\n   */\n  get _E() {\n    return _ => _;\n  }\n  /**\n   * @since 2.0.0\n   */\n  [GenKindTypeId] = GenKindTypeId;\n  /**\n   * @since 2.0.0\n   */\n  [Symbol.iterator]() {\n    return new SingleShotGen(this);\n  }\n}\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport class SingleShotGen {\n  self;\n  called = false;\n  constructor(self) {\n    this.self = self;\n  }\n  /**\n   * @since 2.0.0\n   */\n  next(a) {\n    return this.called ? {\n      value: a,\n      done: true\n    } : (this.called = true, {\n      value: this.self,\n      done: false\n    });\n  }\n  /**\n   * @since 2.0.0\n   */\n  return(a) {\n    return {\n      value: a,\n      done: true\n    };\n  }\n  /**\n   * @since 2.0.0\n   */\n  throw(e) {\n    throw e;\n  }\n  /**\n   * @since 2.0.0\n   */\n  [Symbol.iterator]() {\n    return new SingleShotGen(this.self);\n  }\n}\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const makeGenKind = kind => new GenKindImpl(kind);\n/**\n * @category adapters\n * @since 2.0.0\n */\nexport const adapter = () => function () {\n  let x = arguments[0];\n  for (let i = 1; i < arguments.length; i++) {\n    x = arguments[i](x);\n  }\n  return new GenKindImpl(x);\n};\nconst defaultIncHi = 0x14057b7e;\nconst defaultIncLo = 0xf767814f;\nconst MUL_HI = 0x5851f42d >>> 0;\nconst MUL_LO = 0x4c957f2d >>> 0;\nconst BIT_53 = 9007199254740992.0;\nconst BIT_27 = 134217728.0;\n/**\n * PCG is a family of simple fast space-efficient statistically good algorithms\n * for random number generation. Unlike many general-purpose RNGs, they are also\n * hard to predict.\n *\n * @category model\n * @since 2.0.0\n */\nexport class PCGRandom {\n  _state;\n  constructor(seedHi, seedLo, incHi, incLo) {\n    if (isNullable(seedLo) && isNullable(seedHi)) {\n      seedLo = Math.random() * 0xffffffff >>> 0;\n      seedHi = 0;\n    } else if (isNullable(seedLo)) {\n      seedLo = seedHi;\n      seedHi = 0;\n    }\n    if (isNullable(incLo) && isNullable(incHi)) {\n      incLo = this._state ? this._state[3] : defaultIncLo;\n      incHi = this._state ? this._state[2] : defaultIncHi;\n    } else if (isNullable(incLo)) {\n      incLo = incHi;\n      incHi = 0;\n    }\n    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);\n    this._next();\n    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);\n    this._next();\n    return this;\n  }\n  /**\n   * Returns a copy of the internal state of this random number generator as a\n   * JavaScript Array.\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  getState() {\n    return [this._state[0], this._state[1], this._state[2], this._state[3]];\n  }\n  /**\n   * Restore state previously retrieved using `getState()`.\n   *\n   * @since 2.0.0\n   */\n  setState(state) {\n    this._state[0] = state[0];\n    this._state[1] = state[1];\n    this._state[2] = state[2];\n    this._state[3] = state[3] | 1;\n  }\n  /**\n   * Get a uniformly distributed 32 bit integer between [0, max).\n   *\n   * @category getter\n   * @since 2.0.0\n   */\n  integer(max) {\n    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;\n  }\n  /**\n   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with\n   * 53 bits of precision (every bit of the mantissa is randomized).\n   *\n   * @category getters\n   * @since 2.0.0\n   */\n  number() {\n    const hi = (this._next() & 0x03ffffff) * 1.0;\n    const lo = (this._next() & 0x07ffffff) * 1.0;\n    return (hi * BIT_27 + lo) / BIT_53;\n  }\n  /** @internal */\n  _next() {\n    // save current state (what we'll use for this number)\n    const oldHi = this._state[0] >>> 0;\n    const oldLo = this._state[1] >>> 0;\n    // churn LCG.\n    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);\n    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);\n    // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27\n    let xsHi = oldHi >>> 18;\n    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;\n    xsHi = (xsHi ^ oldHi) >>> 0;\n    xsLo = (xsLo ^ oldLo) >>> 0;\n    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;\n    // rotate xorshifted right a random amount, based on the most sig. 5 bits\n    // bits of the old state.\n    const rot = oldHi >>> 27;\n    const rot2 = (-rot >>> 0 & 31) >>> 0;\n    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;\n  }\n}\nfunction mul64(out, aHi, aLo, bHi, bLo) {\n  let c1 = (aLo >>> 16) * (bLo & 0xffff) >>> 0;\n  let c0 = (aLo & 0xffff) * (bLo >>> 16) >>> 0;\n  let lo = (aLo & 0xffff) * (bLo & 0xffff) >>> 0;\n  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;\n  c0 = c0 << 16 >>> 0;\n  lo = lo + c0 >>> 0;\n  if (lo >>> 0 < c0 >>> 0) {\n    hi = hi + 1 >>> 0;\n  }\n  c1 = c1 << 16 >>> 0;\n  lo = lo + c1 >>> 0;\n  if (lo >>> 0 < c1 >>> 0) {\n    hi = hi + 1 >>> 0;\n  }\n  hi = hi + Math.imul(aLo, bHi) >>> 0;\n  hi = hi + Math.imul(aHi, bLo) >>> 0;\n  out[0] = hi;\n  out[1] = lo;\n}\n// add two 64 bit numbers (given in parts), and store the result in `out`.\nfunction add64(out, aHi, aLo, bHi, bLo) {\n  let hi = aHi + bHi >>> 0;\n  const lo = aLo + bLo >>> 0;\n  if (lo >>> 0 < aLo >>> 0) {\n    hi = hi + 1 | 0;\n  }\n  out[0] = hi;\n  out[1] = lo;\n}\n/**\n * @since 3.0.6\n */\nexport const YieldWrapTypeId = /*#__PURE__*/Symbol.for(\"effect/Utils/YieldWrap\");\n/**\n * @since 3.0.6\n */\nexport class YieldWrap {\n  /**\n   * @since 3.0.6\n   */\n  #value;\n  constructor(value) {\n    this.#value = value;\n  }\n  /**\n   * @since 3.0.6\n   */\n  [YieldWrapTypeId]() {\n    return this.#value;\n  }\n}\n/**\n * @since 3.0.6\n */\nexport function yieldWrapGet(self) {\n  if (typeof self === \"object\" && self !== null && YieldWrapTypeId in self) {\n    return self[YieldWrapTypeId]();\n  }\n  throw new Error(getBugErrorMessage(\"yieldWrapGet\"));\n}\n/**\n * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code\n *\n * @since 3.1.1\n * @status experimental\n * @category modifiers\n */\nexport const structuralRegionState = /*#__PURE__*/globalValue(\"effect/Utils/isStructuralRegion\", () => ({\n  enabled: false,\n  tester: undefined\n}));\n/**\n * Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code\n *\n * @since 3.1.1\n * @status experimental\n * @category modifiers\n */\nexport const structuralRegion = (body, tester) => {\n  const current = structuralRegionState.enabled;\n  const currentTester = structuralRegionState.tester;\n  structuralRegionState.enabled = true;\n  if (tester) {\n    structuralRegionState.tester = tester;\n  }\n  try {\n    return body();\n  } finally {\n    structuralRegionState.enabled = current;\n    structuralRegionState.tester = currentTester;\n  }\n};\nconst tracingFunction = name => {\n  const wrap = {\n    [name](body) {\n      return body();\n    }\n  };\n  return function (fn) {\n    return wrap[name](fn);\n  };\n};\n/**\n * @since 3.2.2\n * @status experimental\n * @category tracing\n */\nexport const internalCall = /*#__PURE__*/tracingFunction(\"effect_internal_function\");\nconst genConstructor = function* () {}.constructor;\n/**\n * @since 3.11.0\n */\nexport const isGeneratorFunction = u => isObject(u) && u.constructor === genConstructor;\n//# sourceMappingURL=Utils.js.map","/**\n * @since 2.0.0\n */\nimport { pipe } from \"./Function.js\";\nimport { globalValue } from \"./GlobalValue.js\";\nimport { hasProperty } from \"./Predicate.js\";\nimport { structuralRegionState } from \"./Utils.js\";\n/** @internal */\nconst randomHashCache = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/Hash/randomHashCache\"), () => new WeakMap());\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const symbol = /*#__PURE__*/Symbol.for(\"effect/Hash\");\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const hash = self => {\n  if (structuralRegionState.enabled === true) {\n    return 0;\n  }\n  switch (typeof self) {\n    case \"number\":\n      return number(self);\n    case \"bigint\":\n      return string(self.toString(10));\n    case \"boolean\":\n      return string(String(self));\n    case \"symbol\":\n      return string(String(self));\n    case \"string\":\n      return string(self);\n    case \"undefined\":\n      return string(\"undefined\");\n    case \"function\":\n    case \"object\":\n      {\n        if (self === null) {\n          return string(\"null\");\n        } else if (self instanceof Date) {\n          return hash(self.toISOString());\n        } else if (isHash(self)) {\n          return self[symbol]();\n        } else {\n          return random(self);\n        }\n      }\n    default:\n      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);\n  }\n};\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const random = self => {\n  if (!randomHashCache.has(self)) {\n    randomHashCache.set(self, number(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));\n  }\n  return randomHashCache.get(self);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const combine = b => self => self * 53 ^ b;\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const optimize = n => n & 0xbfffffff | n >>> 1 & 0x40000000;\n/**\n * @since 2.0.0\n * @category guards\n */\nexport const isHash = u => hasProperty(u, symbol);\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const number = n => {\n  if (n !== n || n === Infinity) {\n    return 0;\n  }\n  let h = n | 0;\n  if (h !== n) {\n    h ^= n * 0xffffffff;\n  }\n  while (n > 0xffffffff) {\n    h ^= n /= 0xffffffff;\n  }\n  return optimize(h);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const string = str => {\n  let h = 5381,\n    i = str.length;\n  while (i) {\n    h = h * 33 ^ str.charCodeAt(--i);\n  }\n  return optimize(h);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const structureKeys = (o, keys) => {\n  let h = 12289;\n  for (let i = 0; i < keys.length; i++) {\n    h ^= pipe(string(keys[i]), combine(hash(o[keys[i]])));\n  }\n  return optimize(h);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const structure = o => structureKeys(o, Object.keys(o));\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const array = arr => {\n  let h = 6151;\n  for (let i = 0; i < arr.length; i++) {\n    h = pipe(h, combine(hash(arr[i])));\n  }\n  return optimize(h);\n};\n/**\n * @since 2.0.0\n * @category hashing\n */\nexport const cached = function () {\n  if (arguments.length === 1) {\n    const self = arguments[0];\n    return function (hash) {\n      Object.defineProperty(self, symbol, {\n        value() {\n          return hash;\n        },\n        enumerable: false\n      });\n      return hash;\n    };\n  }\n  const self = arguments[0];\n  const hash = arguments[1];\n  Object.defineProperty(self, symbol, {\n    value() {\n      return hash;\n    },\n    enumerable: false\n  });\n  return hash;\n};\n//# sourceMappingURL=Hash.js.map","import * as Hash from \"./Hash.js\";\nimport { hasProperty } from \"./Predicate.js\";\nimport { structuralRegionState } from \"./Utils.js\";\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const symbol = /*#__PURE__*/Symbol.for(\"effect/Equal\");\nexport function equals() {\n  if (arguments.length === 1) {\n    return self => compareBoth(self, arguments[0]);\n  }\n  return compareBoth(arguments[0], arguments[1]);\n}\nfunction compareBoth(self, that) {\n  if (self === that) {\n    return true;\n  }\n  const selfType = typeof self;\n  if (selfType !== typeof that) {\n    return false;\n  }\n  if (selfType === \"object\" || selfType === \"function\") {\n    if (self !== null && that !== null) {\n      if (isEqual(self) && isEqual(that)) {\n        if (Hash.hash(self) === Hash.hash(that) && self[symbol](that)) {\n          return true;\n        } else {\n          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;\n        }\n      } else if (self instanceof Date && that instanceof Date) {\n        return self.toISOString() === that.toISOString();\n      }\n    }\n    if (structuralRegionState.enabled) {\n      if (Array.isArray(self) && Array.isArray(that)) {\n        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));\n      }\n      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {\n        const keysSelf = Object.keys(self);\n        const keysThat = Object.keys(that);\n        if (keysSelf.length === keysThat.length) {\n          for (const key of keysSelf) {\n            // @ts-expect-error\n            if (!(key in that && compareBoth(self[key], that[key]))) {\n              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;\n            }\n          }\n          return true;\n        }\n      }\n      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;\n    }\n  }\n  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;\n}\n/**\n * @since 2.0.0\n * @category guards\n */\nexport const isEqual = u => hasProperty(u, symbol);\n/**\n * @since 2.0.0\n * @category instances\n */\nexport const equivalence = () => equals;\n//# sourceMappingURL=Equal.js.map","import { globalValue } from \"./GlobalValue.js\";\nimport { hasProperty, isFunction } from \"./Predicate.js\";\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const NodeInspectSymbol = /*#__PURE__*/Symbol.for(\"nodejs.util.inspect.custom\");\n/**\n * @since 2.0.0\n */\nexport const toJSON = x => {\n  try {\n    if (hasProperty(x, \"toJSON\") && isFunction(x[\"toJSON\"]) && x[\"toJSON\"].length === 0) {\n      return x.toJSON();\n    } else if (Array.isArray(x)) {\n      return x.map(toJSON);\n    }\n  } catch (_) {\n    return {};\n  }\n  return redact(x);\n};\n/**\n * @since 2.0.0\n */\nexport const format = x => JSON.stringify(x, null, 2);\n/**\n * @since 2.0.0\n */\nexport const BaseProto = {\n  toJSON() {\n    return toJSON(this);\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  toString() {\n    return format(this.toJSON());\n  }\n};\n/**\n * @since 2.0.0\n */\nexport class Class {\n  /**\n   * @since 2.0.0\n   */\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n  /**\n   * @since 2.0.0\n   */\n  toString() {\n    return format(this.toJSON());\n  }\n}\n/**\n * @since 2.0.0\n */\nexport const toStringUnknown = (u, whitespace = 2) => {\n  if (typeof u === \"string\") {\n    return u;\n  }\n  try {\n    return typeof u === \"object\" ? stringifyCircular(u, whitespace) : String(u);\n  } catch (_) {\n    return String(u);\n  }\n};\n/**\n * @since 2.0.0\n */\nexport const stringifyCircular = (obj, whitespace) => {\n  let cache = [];\n  const retVal = JSON.stringify(obj, (_key, value) => typeof value === \"object\" && value !== null ? cache.includes(value) ? undefined // circular reference\n  : cache.push(value) && (redactableState.fiberRefs !== undefined && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);\n  cache = undefined;\n  return retVal;\n};\n/**\n * @since 3.10.0\n * @category redactable\n */\nexport const symbolRedactable = /*#__PURE__*/Symbol.for(\"effect/Inspectable/Redactable\");\n/**\n * @since 3.10.0\n * @category redactable\n */\nexport const isRedactable = u => typeof u === \"object\" && u !== null && symbolRedactable in u;\nconst redactableState = /*#__PURE__*/globalValue(\"effect/Inspectable/redactableState\", () => ({\n  fiberRefs: undefined\n}));\n/**\n * @since 3.10.0\n * @category redactable\n */\nexport const withRedactableContext = (context, f) => {\n  const prev = redactableState.fiberRefs;\n  redactableState.fiberRefs = context;\n  try {\n    return f();\n  } finally {\n    redactableState.fiberRefs = prev;\n  }\n};\n/**\n * @since 3.10.0\n * @category redactable\n */\nexport const redact = u => {\n  if (isRedactable(u) && redactableState.fiberRefs !== undefined) {\n    return u[symbolRedactable](redactableState.fiberRefs);\n  }\n  return u;\n};\n//# sourceMappingURL=Inspectable.js.map","/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n */\nexport const pipeArguments = (self, args) => {\n  switch (args.length) {\n    case 0:\n      return self;\n    case 1:\n      return args[0](self);\n    case 2:\n      return args[1](args[0](self));\n    case 3:\n      return args[2](args[1](args[0](self)));\n    case 4:\n      return args[3](args[2](args[1](args[0](self))));\n    case 5:\n      return args[4](args[3](args[2](args[1](args[0](self)))));\n    case 6:\n      return args[5](args[4](args[3](args[2](args[1](args[0](self))))));\n    case 7:\n      return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))));\n    case 8:\n      return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))));\n    case 9:\n      return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))));\n    default:\n      {\n        let ret = self;\n        for (let i = 0, len = args.length; i < len; i++) {\n          ret = args[i](ret);\n        }\n        return ret;\n      }\n  }\n};\n//# sourceMappingURL=Pipeable.js.map","/** @internal */\nexport const OP_ASYNC = \"Async\";\n/** @internal */\nexport const OP_COMMIT = \"Commit\";\n/** @internal */\nexport const OP_FAILURE = \"Failure\";\n/** @internal */\nexport const OP_ON_FAILURE = \"OnFailure\";\n/** @internal */\nexport const OP_ON_SUCCESS = \"OnSuccess\";\n/** @internal */\nexport const OP_ON_SUCCESS_AND_FAILURE = \"OnSuccessAndFailure\";\n/** @internal */\nexport const OP_SUCCESS = \"Success\";\n/** @internal */\nexport const OP_SYNC = \"Sync\";\n/** @internal */\nexport const OP_TAG = \"Tag\";\n/** @internal */\nexport const OP_UPDATE_RUNTIME_FLAGS = \"UpdateRuntimeFlags\";\n/** @internal */\nexport const OP_WHILE = \"While\";\n/** @internal */\nexport const OP_ITERATOR = \"Iterator\";\n/** @internal */\nexport const OP_WITH_RUNTIME = \"WithRuntime\";\n/** @internal */\nexport const OP_YIELD = \"Yield\";\n/** @internal */\nexport const OP_REVERT_FLAGS = \"RevertFlags\";\n//# sourceMappingURL=effect.js.map","import * as Equal from \"../Equal.js\";\nimport * as Hash from \"../Hash.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { SingleShotGen, YieldWrap } from \"../Utils.js\";\nimport * as OpCodes from \"./opCodes/effect.js\";\nimport * as version from \"./version.js\";\n/** @internal */\nexport const EffectTypeId = /*#__PURE__*/Symbol.for(\"effect/Effect\");\n/** @internal */\nexport const StreamTypeId = /*#__PURE__*/Symbol.for(\"effect/Stream\");\n/** @internal */\nexport const SinkTypeId = /*#__PURE__*/Symbol.for(\"effect/Sink\");\n/** @internal */\nexport const ChannelTypeId = /*#__PURE__*/Symbol.for(\"effect/Channel\");\n/** @internal */\nexport const effectVariance = {\n  /* c8 ignore next */\n  _R: _ => _,\n  /* c8 ignore next */\n  _E: _ => _,\n  /* c8 ignore next */\n  _A: _ => _,\n  _V: /*#__PURE__*/version.getCurrentVersion()\n};\nconst sinkVariance = {\n  /* c8 ignore next */\n  _A: _ => _,\n  /* c8 ignore next */\n  _In: _ => _,\n  /* c8 ignore next */\n  _L: _ => _,\n  /* c8 ignore next */\n  _E: _ => _,\n  /* c8 ignore next */\n  _R: _ => _\n};\nconst channelVariance = {\n  /* c8 ignore next */\n  _Env: _ => _,\n  /* c8 ignore next */\n  _InErr: _ => _,\n  /* c8 ignore next */\n  _InElem: _ => _,\n  /* c8 ignore next */\n  _InDone: _ => _,\n  /* c8 ignore next */\n  _OutErr: _ => _,\n  /* c8 ignore next */\n  _OutElem: _ => _,\n  /* c8 ignore next */\n  _OutDone: _ => _\n};\n/** @internal */\nexport const EffectPrototype = {\n  [EffectTypeId]: effectVariance,\n  [StreamTypeId]: effectVariance,\n  [SinkTypeId]: sinkVariance,\n  [ChannelTypeId]: channelVariance,\n  [Equal.symbol](that) {\n    return this === that;\n  },\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.random(this));\n  },\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this));\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const StructuralPrototype = {\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.structure(this));\n  },\n  [Equal.symbol](that) {\n    const selfKeys = Object.keys(this);\n    const thatKeys = Object.keys(that);\n    if (selfKeys.length !== thatKeys.length) {\n      return false;\n    }\n    for (const key of selfKeys) {\n      if (!(key in that && Equal.equals(this[key], that[key]))) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n/** @internal */\nexport const CommitPrototype = {\n  ...EffectPrototype,\n  _op: OpCodes.OP_COMMIT\n};\n/** @internal */\nexport const StructuralCommitPrototype = {\n  ...CommitPrototype,\n  ...StructuralPrototype\n};\n/** @internal */\nexport const Base = /*#__PURE__*/function () {\n  function Base() {}\n  Base.prototype = CommitPrototype;\n  return Base;\n}();\n/** @internal */\nexport const StructuralBase = /*#__PURE__*/function () {\n  function Base() {}\n  Base.prototype = StructuralCommitPrototype;\n  return Base;\n}();\n//# sourceMappingURL=effectable.js.map","/**\n * @since 2.0.0\n */\nimport * as Equal from \"../Equal.js\";\nimport * as Hash from \"../Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport { EffectPrototype } from \"./effectable.js\";\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Option\");\nconst CommonProto = {\n  ...EffectPrototype,\n  [TypeId]: {\n    _A: _ => _\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  toString() {\n    return format(this.toJSON());\n  }\n};\nconst SomeProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {\n  _tag: \"Some\",\n  _op: \"Some\",\n  [Equal.symbol](that) {\n    return isOption(that) && isSome(that) && Equal.equals(this.value, that.value);\n  },\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.combine(Hash.hash(this._tag))(Hash.hash(this.value)));\n  },\n  toJSON() {\n    return {\n      _id: \"Option\",\n      _tag: this._tag,\n      value: toJSON(this.value)\n    };\n  }\n});\nconst NoneHash = /*#__PURE__*/Hash.hash(\"None\");\nconst NoneProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {\n  _tag: \"None\",\n  _op: \"None\",\n  [Equal.symbol](that) {\n    return isOption(that) && isNone(that);\n  },\n  [Hash.symbol]() {\n    return NoneHash;\n  },\n  toJSON() {\n    return {\n      _id: \"Option\",\n      _tag: this._tag\n    };\n  }\n});\n/** @internal */\nexport const isOption = input => hasProperty(input, TypeId);\n/** @internal */\nexport const isNone = fa => fa._tag === \"None\";\n/** @internal */\nexport const isSome = fa => fa._tag === \"Some\";\n/** @internal */\nexport const none = /*#__PURE__*/Object.create(NoneProto);\n/** @internal */\nexport const some = value => {\n  const a = Object.create(SomeProto);\n  a.value = value;\n  return a;\n};\n//# sourceMappingURL=option.js.map","/**\n * @since 2.0.0\n */\nimport * as Equal from \"../Equal.js\";\nimport { dual } from \"../Function.js\";\nimport * as Hash from \"../Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport { EffectPrototype } from \"./effectable.js\";\nimport * as option from \"./option.js\";\n/**\n * @internal\n */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/Either\");\nconst CommonProto = {\n  ...EffectPrototype,\n  [TypeId]: {\n    _R: _ => _\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  toString() {\n    return format(this.toJSON());\n  }\n};\nconst RightProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {\n  _tag: \"Right\",\n  _op: \"Right\",\n  [Equal.symbol](that) {\n    return isEither(that) && isRight(that) && Equal.equals(this.right, that.right);\n  },\n  [Hash.symbol]() {\n    return Hash.combine(Hash.hash(this._tag))(Hash.hash(this.right));\n  },\n  toJSON() {\n    return {\n      _id: \"Either\",\n      _tag: this._tag,\n      right: toJSON(this.right)\n    };\n  }\n});\nconst LeftProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(CommonProto), {\n  _tag: \"Left\",\n  _op: \"Left\",\n  [Equal.symbol](that) {\n    return isEither(that) && isLeft(that) && Equal.equals(this.left, that.left);\n  },\n  [Hash.symbol]() {\n    return Hash.combine(Hash.hash(this._tag))(Hash.hash(this.left));\n  },\n  toJSON() {\n    return {\n      _id: \"Either\",\n      _tag: this._tag,\n      left: toJSON(this.left)\n    };\n  }\n});\n/** @internal */\nexport const isEither = input => hasProperty(input, TypeId);\n/** @internal */\nexport const isLeft = ma => ma._tag === \"Left\";\n/** @internal */\nexport const isRight = ma => ma._tag === \"Right\";\n/** @internal */\nexport const left = left => {\n  const a = Object.create(LeftProto);\n  a.left = left;\n  return a;\n};\n/** @internal */\nexport const right = right => {\n  const a = Object.create(RightProto);\n  a.right = right;\n  return a;\n};\n/** @internal */\nexport const getLeft = self => isRight(self) ? option.none : option.some(self.left);\n/** @internal */\nexport const getRight = self => isLeft(self) ? option.none : option.some(self.right);\n/** @internal */\nexport const fromOption = /*#__PURE__*/dual(2, (self, onNone) => option.isNone(self) ? left(onNone()) : right(self.value));\n//# sourceMappingURL=either.js.map","/**\n * @since 2.0.0\n */\nimport * as Equivalence from \"./Equivalence.js\";\nimport { constNull, constUndefined, dual, identity } from \"./Function.js\";\nimport * as doNotation from \"./internal/doNotation.js\";\nimport * as either from \"./internal/either.js\";\nimport { isFunction } from \"./Predicate.js\";\nimport * as Gen from \"./Utils.js\";\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport const TypeId = either.TypeId;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const right = either.right;\nconst void_ = /*#__PURE__*/right(void 0);\nexport {\n/**\n * @category constructors\n * @since 3.13.0\n */\nvoid_ as void };\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const left = either.left;\n/**\n * Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))\n * assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromNullable = /*#__PURE__*/dual(2, (self, onNullable) => self == null ? left(onNullable(self)) : right(self));\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))\n * assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromOption = either.fromOption;\nconst try_ = evaluate => {\n  if (isFunction(evaluate)) {\n    try {\n      return right(evaluate());\n    } catch (e) {\n      return left(e);\n    }\n  } else {\n    try {\n      return right(evaluate.try());\n    } catch (e) {\n      return left(evaluate.catch(e));\n    }\n  }\n};\nexport {\n/**\n * Imports a synchronous side-effect into a pure `Either` value, translating any\n * thrown exceptions into typed failed eithers creating with `Either.left`.\n *\n * @category constructors\n * @since 2.0.0\n */\ntry_ as try };\n/**\n * Tests if a value is a `Either`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isEither(Either.right(1)), true)\n * assert.deepStrictEqual(Either.isEither(Either.left(\"a\")), true)\n * assert.deepStrictEqual(Either.isEither({ right: 1 }), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEither = either.isEither;\n/**\n * Determine if a `Either` is a `Left`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isLeft(Either.right(1)), false)\n * assert.deepStrictEqual(Either.isLeft(Either.left(\"a\")), true)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isLeft = either.isLeft;\n/**\n * Determine if a `Either` is a `Right`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.isRight(Either.right(1)), true)\n * assert.deepStrictEqual(Either.isRight(Either.left(\"a\")), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isRight = either.isRight;\n/**\n * Converts a `Either` to an `Option` discarding the `Left`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))\n * assert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getRight = either.getRight;\n/**\n * Converts a `Either` to an `Option` discarding the value.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())\n * assert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getLeft = either.getLeft;\n/**\n * @category equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = ({\n  left,\n  right\n}) => Equivalence.make((x, y) => isLeft(x) ? isLeft(y) && left(x.left, y.left) : isRight(y) && right(x.right, y.right));\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport const mapBoth = /*#__PURE__*/dual(2, (self, {\n  onLeft,\n  onRight\n}) => isLeft(self) ? left(onLeft(self.left)) : right(onRight(self.right)));\n/**\n * Maps the `Left` side of an `Either` value to a new `Either` value.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapLeft = /*#__PURE__*/dual(2, (self, f) => isLeft(self) ? left(f(self.left)) : right(self.right));\n/**\n * Maps the `Right` side of an `Either` value to a new `Either` value.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const map = /*#__PURE__*/dual(2, (self, f) => isRight(self) ? right(f(self.right)) : left(self.left));\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\n * if the value is a `Right` the inner value is applied to the `onRight` function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Either } from \"effect\"\n *\n * const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n *\n * const onRight = (value: number): string => `Ok: ${value}`\n *\n * assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')\n * assert.deepStrictEqual(\n *   pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),\n *   'strings: string 1, string 2'\n * )\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const match = /*#__PURE__*/dual(2, (self, {\n  onLeft,\n  onRight\n}) => isLeft(self) ? onLeft(self.left) : onRight(self.right));\n/**\n * Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\n * or `Left` of the result of the provided function if the predicate returns false\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Either } from \"effect\"\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     Either.liftPredicate(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     0,\n *     Either.liftPredicate(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.left(\"0 is not positive\")\n * )\n * ```\n *\n * @category lifting\n * @since 3.4.0\n */\nexport const liftPredicate = /*#__PURE__*/dual(3, (a, predicate, orLeftWith) => predicate(a) ? right(a) : left(orLeftWith(a)));\n/**\n * Filter the right value with the provided function.\n * If the predicate fails, set the left value with the result of the provided function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Either } from \"effect\"\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     Either.right(1),\n *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     Either.right(0),\n *     Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n *   ),\n *   Either.left(\"0 is not positive\")\n * )\n * ```\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */\nexport const filterOrLeft = /*#__PURE__*/dual(3, (self, predicate, orLeftWith) => flatMap(self, r => predicate(r) ? right(r) : left(orLeftWith(r))));\n/**\n * @category getters\n * @since 2.0.0\n */\nexport const merge = /*#__PURE__*/match({\n  onLeft: identity,\n  onRight: identity\n});\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + \"!\"), 1)\n * assert.deepStrictEqual(Either.getOrElse(Either.left(\"not a number\"), (error) => error + \"!\"), \"not a number!\")\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrElse = /*#__PURE__*/dual(2, (self, onLeft) => isLeft(self) ? onLeft(self.left) : self.right);\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrNull(Either.right(1)), 1)\n * assert.deepStrictEqual(Either.getOrNull(Either.left(\"a\")), null)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrNull = /*#__PURE__*/getOrElse(constNull);\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrUndefined(Either.right(1)), 1)\n * assert.deepStrictEqual(Either.getOrUndefined(Either.left(\"a\")), undefined)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrUndefined = /*#__PURE__*/getOrElse(constUndefined);\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),\n *   1\n * )\n * assert.throws(() => Either.getOrThrowWith(Either.left(\"error\"), () => new Error('Unexpected Left')))\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrThrowWith = /*#__PURE__*/dual(2, (self, onLeft) => {\n  if (isRight(self)) {\n    return self.right;\n  }\n  throw onLeft(self.left);\n});\n// TODO(4.0): by default should throw `L` (i.e getOrThrowWith with the identity function)\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)\n * assert.throws(() => Either.getOrThrow(Either.left(\"error\")))\n * ```\n *\n * @throws `Error(\"getOrThrow called on a Left\")`\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrThrow = /*#__PURE__*/getOrThrowWith(() => new Error(\"getOrThrow called on a Left\"));\n/**\n * Returns `self` if it is a `Right` or `that` otherwise.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport const orElse = /*#__PURE__*/dual(2, (self, that) => isLeft(self) ? that(self.left) : right(self.right));\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => isLeft(self) ? left(self.left) : f(self.right));\n/**\n * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const andThen = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => {\n  const b = isFunction(f) ? f(a) : f;\n  return isEither(b) ? b : right(b);\n}));\n/**\n * @category zipping\n * @since 2.0.0\n */\nexport const zipWith = /*#__PURE__*/dual(3, (self, that, f) => flatMap(self, r => map(that, r2 => f(r, r2))));\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const ap = /*#__PURE__*/dual(2, (self, that) => zipWith(self, that, (f, a) => f(a)));\n/**\n * Takes a structure of `Either`s and returns an `Either` of values with the same structure.\n *\n * - If a tuple is supplied, then the returned `Either` will contain a tuple with the same length.\n * - If a struct is supplied, then the returned `Either` will contain a struct with the same keys.\n * - If an iterable is supplied, then the returned `Either` will contain an array.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either } from \"effect\"\n *\n * assert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))\n * assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.right(\"hello\") }), Either.right({ right: 1, b: \"hello\" }))\n * assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left(\"error\") }), Either.left(\"error\"))\n * ```\n *\n * @category combining\n * @since 2.0.0\n */\n// @ts-expect-error\nexport const all = input => {\n  if (Symbol.iterator in input) {\n    const out = [];\n    for (const e of input) {\n      if (isLeft(e)) {\n        return e;\n      }\n      out.push(e.right);\n    }\n    return right(out);\n  }\n  const out = {};\n  for (const key of Object.keys(input)) {\n    const e = input[key];\n    if (isLeft(e)) {\n      return e;\n    }\n    out[key] = e.right;\n  }\n  return right(out);\n};\n/**\n * Returns an `Either` that swaps the error/success cases. This allows you to\n * use all methods on the error channel, possibly before flipping back.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const flip = self => isLeft(self) ? right(self.left) : left(self.right);\nconst adapter = /*#__PURE__*/Gen.adapter();\n/**\n * @category generators\n * @since 2.0.0\n */\nexport const gen = (...args) => {\n  const f = args.length === 1 ? args[0] : args[1].bind(args[0]);\n  const iterator = f(adapter);\n  let state = iterator.next();\n  while (!state.done) {\n    const current = Gen.isGenKind(state.value) ? state.value.value : Gen.yieldWrapGet(state.value);\n    if (isLeft(current)) {\n      return current;\n    }\n    state = iterator.next(current.right);\n  }\n  return right(state.value);\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @see {@link bind}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @category do notation\n * @since 2.0.0\n */\nexport const Do = /*#__PURE__*/right({});\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @see {@link Do}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @category do notation\n * @since 2.0.0\n */\nexport const bind = /*#__PURE__*/doNotation.bind(map, flatMap);\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @see {@link Do}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @category do notation\n * @since 2.0.0\n */\nexport const bindTo = /*#__PURE__*/doNotation.bindTo(map);\nconst let_ = /*#__PURE__*/doNotation.let_(map);\nexport {\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * @see {@link Do}\n * @see {@link bindTo}\n * @see {@link bind}\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Either.Do,\n *   Either.bind(\"x\", () => Either.right(2)),\n *   Either.bind(\"y\", () => Either.right(3)),\n *   Either.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n *\n * ```\n * @category do notation\n * @since 2.0.0\n */\nlet_ as let };\n//# sourceMappingURL=Either.js.map","/**\n * This module provides an implementation of the `Order` type class which is used to define a total ordering on some type `A`.\n * An order is defined by a relation `<=`, which obeys the following laws:\n *\n * - either `x <= y` or `y <= x` (totality)\n * - if `x <= y` and `y <= x`, then `x == y` (antisymmetry)\n * - if `x <= y` and `y <= z`, then `x <= z` (transitivity)\n *\n * The truth table for compare is defined as follows:\n *\n * | `x <= y` | `x >= y` | Ordering |                       |\n * | -------- | -------- | -------- | --------------------- |\n * | `true`   | `true`   | `0`      | corresponds to x == y |\n * | `true`   | `false`  | `< 0`    | corresponds to x < y  |\n * | `false`  | `true`   | `> 0`    | corresponds to x > y  |\n *\n * @since 2.0.0\n */\nimport { dual } from \"./Function.js\";\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const make = compare => (self, that) => self === that ? 0 : compare(self, that);\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const string = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const number = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const boolean = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const bigint = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @since 2.0.0\n */\nexport const reverse = O => make((self, that) => O(that, self));\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combine = /*#__PURE__*/dual(2, (self, that) => make((a1, a2) => {\n  const out = self(a1, a2);\n  if (out !== 0) {\n    return out;\n  }\n  return that(a1, a2);\n}));\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combineMany = /*#__PURE__*/dual(2, (self, collection) => make((a1, a2) => {\n  let out = self(a1, a2);\n  if (out !== 0) {\n    return out;\n  }\n  for (const O of collection) {\n    out = O(a1, a2);\n    if (out !== 0) {\n      return out;\n    }\n  }\n  return out;\n}));\n/**\n * @since 2.0.0\n */\nexport const empty = () => make(() => 0);\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combineAll = collection => combineMany(empty(), collection);\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport const mapInput = /*#__PURE__*/dual(2, (self, f) => make((b1, b2) => self(f(b1), f(b2))));\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Date = /*#__PURE__*/mapInput(number, date => date.getTime());\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const product = /*#__PURE__*/dual(2, (self, that) => make(([xa, xb], [ya, yb]) => {\n  const o = self(xa, ya);\n  return o !== 0 ? o : that(xb, yb);\n}));\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const all = collection => {\n  return make((x, y) => {\n    const len = Math.min(x.length, y.length);\n    let collectionLength = 0;\n    for (const O of collection) {\n      if (collectionLength >= len) {\n        break;\n      }\n      const o = O(x[collectionLength], y[collectionLength]);\n      if (o !== 0) {\n        return o;\n      }\n      collectionLength++;\n    }\n    return 0;\n  });\n};\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const productMany = /*#__PURE__*/dual(2, (self, collection) => {\n  const O = all(collection);\n  return make((x, y) => {\n    const o = self(x[0], y[0]);\n    return o !== 0 ? o : O(x.slice(1), y.slice(1));\n  });\n});\n/**\n * Similar to `Promise.all` but operates on `Order`s.\n *\n * ```\n * [Order<A>, Order<B>, ...] -> Order<[A, B, ...]>\n * ```\n *\n * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\n * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\n * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\n * of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const tuple = (...elements) => all(elements);\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const array = O => make((self, that) => {\n  const aLen = self.length;\n  const bLen = that.length;\n  const len = Math.min(aLen, bLen);\n  for (let i = 0; i < len; i++) {\n    const o = O(self[i], that[i]);\n    if (o !== 0) {\n      return o;\n    }\n  }\n  return number(aLen, bLen);\n});\n/**\n * This function creates and returns a new `Order` for a struct of values based on the given `Order`s\n * for each property in the struct.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const struct = fields => {\n  const keys = Object.keys(fields);\n  return make((self, that) => {\n    for (const key of keys) {\n      const o = fields[key](self[key], that[key]);\n      if (o !== 0) {\n        return o;\n      }\n    }\n    return 0;\n  });\n};\n/**\n * Test whether one value is _strictly less than_ another.\n *\n * @since 2.0.0\n */\nexport const lessThan = O => dual(2, (self, that) => O(self, that) === -1);\n/**\n * Test whether one value is _strictly greater than_ another.\n *\n * @since 2.0.0\n */\nexport const greaterThan = O => dual(2, (self, that) => O(self, that) === 1);\n/**\n * Test whether one value is _non-strictly less than_ another.\n *\n * @since 2.0.0\n */\nexport const lessThanOrEqualTo = O => dual(2, (self, that) => O(self, that) !== 1);\n/**\n * Test whether one value is _non-strictly greater than_ another.\n *\n * @since 2.0.0\n */\nexport const greaterThanOrEqualTo = O => dual(2, (self, that) => O(self, that) !== -1);\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 2.0.0\n */\nexport const min = O => dual(2, (self, that) => self === that || O(self, that) < 1 ? self : that);\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 2.0.0\n */\nexport const max = O => dual(2, (self, that) => self === that || O(self, that) > -1 ? self : that);\n/**\n * Clamp a value between a minimum and a maximum.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Order, Number } from \"effect\"\n *\n * const clamp = Order.clamp(Number.Order)({ minimum: 1, maximum: 5 })\n *\n * assert.equal(clamp(3), 3)\n * assert.equal(clamp(0), 1)\n * assert.equal(clamp(6), 5)\n * ```\n *\n * @since 2.0.0\n */\nexport const clamp = O => dual(2, (self, options) => min(O)(options.maximum, max(O)(options.minimum, self)));\n/**\n * Test whether a value is between a minimum and a maximum (inclusive).\n *\n * @since 2.0.0\n */\nexport const between = O => dual(2, (self, options) => !lessThan(O)(self, options.minimum) && !greaterThan(O)(self, options.maximum));\n//# sourceMappingURL=Order.js.map","import * as Equal from \"./Equal.js\";\nimport * as Equivalence from \"./Equivalence.js\";\nimport { constNull, constUndefined, dual, identity, isFunction } from \"./Function.js\";\nimport * as doNotation from \"./internal/doNotation.js\";\nimport * as either from \"./internal/either.js\";\nimport * as option from \"./internal/option.js\";\nimport * as order from \"./Order.js\";\nimport * as Gen from \"./Utils.js\";\n/**\n * @category Symbols\n * @since 2.0.0\n */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/Option\");\n/**\n * Represents the absence of a value by creating an empty `Option`.\n *\n * `Option.none` returns an `Option<never>`, which is a subtype of `Option<A>`.\n * This means you can use it in place of any `Option<A>` regardless of the type\n * `A`.\n *\n * @see {@link some} for the opposite operation.\n *\n * @example\n * ```ts\n * // Title: Creating an Option with No Value\n * import { Option } from \"effect\"\n *\n * // An Option holding no value\n * //\n * //      ┌─── Option<never>\n * //      ▼\n * const noValue = Option.none()\n *\n * console.log(noValue)\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Constructors\n * @since 2.0.0\n */\nexport const none = () => option.none;\n/**\n * Wraps the given value into an `Option` to represent its presence.\n *\n * @see {@link none} for the opposite operation.\n *\n * @example\n * ```ts\n * // Title: Creating an Option with a Value\n * import { Option } from \"effect\"\n *\n * // An Option holding the number 1\n * //\n * //      ┌─── Option<number>\n * //      ▼\n * const value = Option.some(1)\n *\n * console.log(value)\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n * ```\n *\n * @category Constructors\n * @since 2.0.0\n */\nexport const some = option.some;\n/**\n * Determines whether the given value is an `Option`.\n *\n * **Details**\n *\n * This function checks if a value is an instance of `Option`. It returns `true`\n * if the value is either `Option.some` or `Option.none`, and `false` otherwise.\n * This is particularly useful when working with unknown values or when you need\n * to ensure type safety in your code.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.isOption(Option.some(1)))\n * // Output: true\n *\n * console.log(Option.isOption(Option.none()))\n * // Output: true\n *\n * console.log(Option.isOption({}))\n * // Output: false\n * ```\n *\n * @category Guards\n * @since 2.0.0\n */\nexport const isOption = option.isOption;\n/**\n * Checks whether an `Option` represents the absence of a value (`None`).\n *\n * @see {@link isSome} for the opposite check.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.isNone(Option.some(1)))\n * // Output: false\n *\n * console.log(Option.isNone(Option.none()))\n * // Output: true\n * ```\n *\n * @category Guards\n * @since 2.0.0\n */\nexport const isNone = option.isNone;\n/**\n * Checks whether an `Option` contains a value (`Some`).\n *\n * @see {@link isNone} for the opposite check.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.isSome(Option.some(1)))\n * // Output: true\n *\n * console.log(Option.isSome(Option.none()))\n * // Output: false\n * ```\n *\n * @category Guards\n * @since 2.0.0\n */\nexport const isSome = option.isSome;\n/**\n * Performs pattern matching on an `Option` to handle both `Some` and `None`\n * cases.\n *\n * **Details**\n *\n * This function allows you to match against an `Option` and handle both\n * scenarios: when the `Option` is `None` (i.e., contains no value), and when\n * the `Option` is `Some` (i.e., contains a value). It executes one of the\n * provided functions based on the case:\n *\n * - If the `Option` is `None`, the `onNone` function is executed and its result\n *   is returned.\n * - If the `Option` is `Some`, the `onSome` function is executed with the\n *   contained value, and its result is returned.\n *\n * This function provides a concise and functional way to handle optional values\n * without resorting to `if` or manual checks, making your code more declarative\n * and readable.\n *\n * @example\n * ```ts\n * // Title: Pattern Matching with Option\n * import { Option } from \"effect\"\n *\n * const foo = Option.some(1)\n *\n * const message = Option.match(foo, {\n *   onNone: () => \"Option is empty\",\n *   onSome: (value) => `Option has a value: ${value}`\n * })\n *\n * console.log(message)\n * // Output: \"Option has a value: 1\"\n * ```\n *\n * @category Pattern matching\n * @since 2.0.0\n */\nexport const match = /*#__PURE__*/dual(2, (self, {\n  onNone,\n  onSome\n}) => isNone(self) ? onNone() : onSome(self.value));\n/**\n * Converts an `Option`-returning function into a type guard.\n *\n * **Details**\n *\n * This function transforms a function that returns an `Option` into a type\n * guard, ensuring type safety when validating or narrowing types. The returned\n * type guard function checks whether the input satisfies the condition defined\n * in the original `Option`-returning function.\n *\n * If the original function returns `Option.some`, the type guard evaluates to\n * `true`, confirming the input is of the desired type. If the function returns\n * `Option.none`, the type guard evaluates to `false`.\n *\n * This utility is especially useful for validating types in union types,\n * filtering arrays, or ensuring safe handling of specific subtypes.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * type MyData = string | number\n *\n * const parseString = (data: MyData): Option.Option<string> =>\n *   typeof data === \"string\" ? Option.some(data) : Option.none()\n *\n * //      ┌─── (a: MyData) => a is string\n * //      ▼\n * const isString = Option.toRefinement(parseString)\n *\n * console.log(isString(\"a\"))\n * // Output: true\n *\n * console.log(isString(1))\n * // Output: false\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const toRefinement = f => a => isSome(f(a));\n/**\n * Converts an `Iterable` into an `Option`, wrapping the first element if it\n * exists.\n *\n * **Details**\n *\n * This function takes an `Iterable` (e.g., an array, a generator, or any object\n * implementing the `Iterable` interface) and returns an `Option` based on its\n * content:\n *\n * - If the `Iterable` contains at least one element, the first element is\n *   wrapped in a `Some` and returned.\n * - If the `Iterable` is empty, `None` is returned, representing the absence of\n *   a value.\n *\n * This utility is useful for safely handling collections that might be empty,\n * ensuring you explicitly handle both cases where a value exists or doesn't.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.fromIterable([1, 2, 3]))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(Option.fromIterable([]))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Constructors\n * @since 2.0.0\n */\nexport const fromIterable = collection => {\n  for (const a of collection) {\n    return some(a);\n  }\n  return none();\n};\n/**\n * Converts an `Either` into an `Option` by discarding the error and extracting\n * the right value.\n *\n * **Details**\n *\n * This function takes an `Either` and returns an `Option` based on its value:\n *\n * - If the `Either` is a `Right`, its value is wrapped in a `Some` and\n *   returned.\n * - If the `Either` is a `Left`, the error is discarded, and `None` is\n *   returned.\n *\n * This is particularly useful when you only care about the success case\n * (`Right`) of an `Either` and want to handle the result using `Option`. By\n * using this function, you can convert `Either` into a simpler structure for\n * cases where error handling is not required.\n *\n * @see {@link getLeft} for the opposite operation.\n *\n * @example\n * ```ts\n * import { Either, Option } from \"effect\"\n *\n * console.log(Option.getRight(Either.right(\"ok\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'ok' }\n *\n * console.log(Option.getRight(Either.left(\"err\")))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const getRight = either.getRight;\n/**\n * Converts an `Either` into an `Option` by discarding the right value and\n * extracting the left value.\n *\n * **Details**\n *\n * This function transforms an `Either` into an `Option` as follows:\n *\n * - If the `Either` is a `Left`, its value is wrapped in a `Some` and returned.\n * - If the `Either` is a `Right`, the value is discarded, and `None` is\n *   returned.\n *\n * This utility is useful when you only care about the error case (`Left`) of an\n * `Either` and want to handle it as an `Option`. By discarding the right value,\n * it simplifies error-focused workflows.\n *\n * @see {@link getRight} for the opposite operation.\n *\n * @example\n * ```ts\n * import { Either, Option } from \"effect\"\n *\n * console.log(Option.getLeft(Either.right(\"ok\")))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.getLeft(Either.left(\"err\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'err' }\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const getLeft = either.getLeft;\n/**\n * Returns the value contained in the `Option` if it is `Some`, otherwise\n * evaluates and returns the result of `onNone`.\n *\n * **Details**\n *\n * This function allows you to provide a fallback value or computation for when\n * an `Option` is `None`. If the `Option` contains a value (`Some`), that value\n * is returned. If it is empty (`None`), the `onNone` function is executed, and\n * its result is returned instead.\n *\n * This utility is helpful for safely handling `Option` values by ensuring you\n * always receive a meaningful result, whether or not the `Option` contains a\n * value. It is particularly useful for providing default values or alternative\n * logic when working with optional values.\n *\n * @see {@link getOrNull} for a version that returns `null` instead of executing a function.\n * @see {@link getOrUndefined} for a version that returns `undefined` instead of executing a function.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.some(1).pipe(Option.getOrElse(() => 0)))\n * // Output: 1\n *\n * console.log(Option.none().pipe(Option.getOrElse(() => 0)))\n * // Output: 0\n * ```\n *\n * @category Getters\n * @since 2.0.0\n */\nexport const getOrElse = /*#__PURE__*/dual(2, (self, onNone) => isNone(self) ? onNone() : self.value);\n/**\n * Returns the provided `Option` `that` if the current `Option` (`self`) is\n * `None`; otherwise, it returns `self`.\n *\n * **Details**\n *\n * This function provides a fallback mechanism for `Option` values. If the\n * current `Option` is `None` (i.e., it contains no value), the `that` function\n * is evaluated, and its resulting `Option` is returned. If the current `Option`\n * is `Some` (i.e., it contains a value), the original `Option` is returned\n * unchanged.\n *\n * This is particularly useful for chaining fallback values or computations,\n * allowing you to provide alternative `Option` values when the first one is\n * empty.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.none().pipe(Option.orElse(() => Option.none())))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.some(\"a\").pipe(Option.orElse(() => Option.none())))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n *\n * console.log(Option.none().pipe(Option.orElse(() => Option.some(\"b\"))))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n *\n * console.log(Option.some(\"a\").pipe(Option.orElse(() => Option.some(\"b\"))))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n * ```\n *\n * @category Error handling\n * @since 2.0.0\n */\nexport const orElse = /*#__PURE__*/dual(2, (self, that) => isNone(self) ? that() : self);\n/**\n * Returns the provided default value wrapped in `Some` if the current `Option`\n * (`self`) is `None`; otherwise, returns `self`.\n *\n * **Details**\n *\n * This function provides a way to supply a default value for cases where an\n * `Option` is `None`. If the current `Option` is empty (`None`), the `onNone`\n * function is executed to compute the default value, which is then wrapped in a\n * `Some`. If the current `Option` contains a value (`Some`), it is returned as\n * is.\n *\n * This is particularly useful for handling optional values where a fallback\n * default needs to be provided explicitly in case of absence.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.none().pipe(Option.orElseSome(() => \"b\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n *\n * console.log(Option.some(\"a\").pipe(Option.orElseSome(() => \"b\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n * ```\n *\n * @category Error handling\n * @since 2.0.0\n */\nexport const orElseSome = /*#__PURE__*/dual(2, (self, onNone) => isNone(self) ? some(onNone()) : self);\n/**\n * Similar to {@link orElse}, but returns an `Either` wrapped in an `Option` to\n * indicate the source of the value.\n *\n * **Details**\n *\n * This function allows you to provide a fallback `Option` in case the current\n * `Option` (`self`) is `None`. However, unlike `orElse`, it returns the value\n * wrapped in an `Either` object, providing additional information about where\n * the value came from:\n *\n * - If the value is from the fallback `Option` (`that`), it is wrapped in an\n *   `Either.right`.\n * - If the value is from the original `Option` (`self`), it is wrapped in an\n *   `Either.left`.\n *\n * This is especially useful when you need to differentiate between values\n * originating from the primary `Option` and those coming from the fallback,\n * while still maintaining the `Option`-style handling.\n *\n * @category Error handling\n * @since 2.0.0\n */\nexport const orElseEither = /*#__PURE__*/dual(2, (self, that) => isNone(self) ? map(that(), either.right) : map(self, either.left));\n/**\n * Returns the first `Some` value found in an `Iterable` collection of\n * `Option`s, or `None` if no `Some` is found.\n *\n * **Details**\n *\n * This function iterates over a collection of `Option` values and returns the\n * first `Some` it encounters. If the collection contains only `None` values,\n * the result will also be `None`. This utility is useful for efficiently\n * finding the first valid value in a sequence of potentially empty or invalid\n * options.\n *\n * The iteration stops as soon as a `Some` is found, making this function\n * efficient for large collections.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.firstSomeOf([\n *   Option.none(),\n *   Option.some(1),\n *   Option.some(2)\n * ]))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n * ```\n *\n * @category Error handling\n * @since 2.0.0\n */\nexport const firstSomeOf = collection => {\n  let out = none();\n  for (out of collection) {\n    if (isSome(out)) {\n      return out;\n    }\n  }\n  return out;\n};\n/**\n * Converts a nullable value into an `Option`. Returns `None` if the value is\n * `null` or `undefined`, otherwise wraps the value in a `Some`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.fromNullable(undefined))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.fromNullable(null))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.fromNullable(1))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const fromNullable = nullableValue => nullableValue == null ? none() : some(nullableValue);\n/**\n * Lifts a function that returns `null` or `undefined` into the `Option`\n * context.\n *\n * **Details**\n *\n * This function takes a function `f` that might return `null` or `undefined`\n * and transforms it into a function that returns an `Option`. The resulting\n * function will return:\n * - `Some` if the original function produces a non-null, non-undefined value.\n * - `None` if the original function produces `null` or `undefined`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const parse = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const parseOption = Option.liftNullable(parse)\n *\n * console.log(parseOption(\"1\"))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(parseOption(\"not a number\"))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const liftNullable = f => (...a) => fromNullable(f(...a));\n/**\n * Returns the value contained in the `Option` if it is `Some`; otherwise,\n * returns `null`.\n *\n * **Details**\n *\n * This function provides a way to extract the value of an `Option` while\n * falling back to `null` if the `Option` is `None`.\n *\n * It is particularly useful in scenarios where `null` is an acceptable\n * placeholder for the absence of a value, such as when interacting with APIs or\n * systems that use `null` as a default for missing values.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.getOrNull(Option.some(1)))\n * // Output: 1\n *\n * console.log(Option.getOrNull(Option.none()))\n * // Output: null\n * ```\n *\n * @category Getters\n * @since 2.0.0\n */\nexport const getOrNull = /*#__PURE__*/getOrElse(constNull);\n/**\n * Returns the value contained in the `Option` if it is `Some`; otherwise,\n * returns `undefined`.\n *\n * **Details**\n *\n * This function provides a way to extract the value of an `Option` while\n * falling back to `undefined` if the `Option` is `None`.\n *\n * It is particularly useful in scenarios where `undefined` is an acceptable\n * placeholder for the absence of a value, such as when interacting with APIs or\n * systems that use `undefined` as a default for missing values.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.getOrUndefined(Option.some(1)))\n * // Output: 1\n *\n * console.log(Option.getOrUndefined(Option.none()))\n * // Output: undefined\n * ```\n *\n * @category Getters\n * @since 2.0.0\n */\nexport const getOrUndefined = /*#__PURE__*/getOrElse(constUndefined);\n/**\n * Lifts a function that throws exceptions into a function that returns an\n * `Option`.\n *\n * **Details**\n *\n * This utility function takes a function `f` that might throw an exception and\n * transforms it into a safer function that returns an `Option`. If the original\n * function executes successfully, the result is wrapped in a `Some`. If an\n * exception is thrown, the result is `None`, allowing the developer to handle\n * errors in a functional, type-safe way.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const parse = Option.liftThrowable(JSON.parse)\n *\n * console.log(parse(\"1\"))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(parse(\"\"))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const liftThrowable = f => (...a) => {\n  try {\n    return some(f(...a));\n  } catch (e) {\n    return none();\n  }\n};\n/**\n * Extracts the value of an `Option` or throws an error if the `Option` is\n * `None`, using a custom error factory.\n *\n * **Details**\n *\n * This function allows you to extract the value of an `Option` when it is\n * `Some`. If the `Option` is `None`, it throws an error generated by the\n * provided `onNone` function. This utility is particularly useful when you need\n * a fail-fast behavior for empty `Option` values and want to provide a custom\n * error message or object.\n *\n * @see {@link getOrThrow} for a version that throws a default error.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),\n *   1\n * )\n * assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const getOrThrowWith = /*#__PURE__*/dual(2, (self, onNone) => {\n  if (isSome(self)) {\n    return self.value;\n  }\n  throw onNone();\n});\n/**\n * Extracts the value of an `Option` or throws a default error if the `Option`\n * is `None`.\n *\n * **Details**\n *\n * This function extracts the value from an `Option` if it is `Some`. If the\n * `Option` is `None`, it throws a default error. It is useful for fail-fast\n * scenarios where the absence of a value is treated as an exceptional case and\n * a default error is sufficient.\n *\n * @see {@link getOrThrowWith} for a version that allows you to provide a custom error.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option } from \"effect\"\n *\n * assert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)\n * assert.throws(() => Option.getOrThrow(Option.none()))\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const getOrThrow = /*#__PURE__*/getOrThrowWith(() => new Error(\"getOrThrow called on a None\"));\n/**\n * Transforms the value inside a `Some` to a new value using the provided\n * function, while leaving `None` unchanged.\n *\n * **Details**\n *\n * This function applies a mapping function `f` to the value inside an `Option`\n * if it is a `Some`. If the `Option` is `None`, it remains unchanged. The\n * result is a new `Option` with the transformed value (if it was a `Some`) or\n * still `None`.\n *\n * This utility is particularly useful for chaining transformations in a\n * functional way without needing to manually handle `None` cases.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // Mapping over a `Some`\n * const someValue = Option.some(2)\n *\n * console.log(Option.map(someValue, (n) => n * 2))\n * // Output: { _id: 'Option', _tag: 'Some', value: 4 }\n *\n * // Mapping over a `None`\n * const noneValue = Option.none<number>()\n *\n * console.log(Option.map(noneValue, (n) => n * 2))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Mapping\n * @since 2.0.0\n */\nexport const map = /*#__PURE__*/dual(2, (self, f) => isNone(self) ? none() : some(f(self.value)));\n/**\n * Replaces the value inside a `Some` with the specified constant value, leaving\n * `None` unchanged.\n *\n * **Details**\n *\n * This function transforms an `Option` by replacing the value inside a `Some`\n * with the given constant value `b`. If the `Option` is `None`, it remains\n * unchanged.\n *\n * This is useful when you want to preserve the presence of a value (`Some`) but\n * replace its content with a fixed value.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // Replacing the value of a `Some`\n * const someValue = Option.some(42)\n *\n * console.log(Option.as(someValue, \"new value\"))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'new value' }\n *\n * // Replacing a `None` (no effect)\n * const noneValue = Option.none<number>()\n *\n * console.log(Option.as(noneValue, \"new value\"))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Mapping\n * @since 2.0.0\n */\nexport const as = /*#__PURE__*/dual(2, (self, b) => map(self, () => b));\n/**\n * Replaces the value inside a `Some` with the constant value `void`, leaving\n * `None` unchanged.\n *\n * **Details**\n *\n * This function transforms an `Option` by replacing the value inside a `Some`\n * with `void`. If the `Option` is `None`, it remains unchanged.\n *\n * This is particularly useful in scenarios where the presence or absence of a\n * value is significant, but the actual content of the value is irrelevant.\n *\n * @category Mapping\n * @since 2.0.0\n */\nexport const asVoid = /*#__PURE__*/as(undefined);\nconst void_ = /*#__PURE__*/some(undefined);\nexport {\n/**\n * @since 2.0.0\n */\nvoid_ as void };\n/**\n * Applies a function to the value of a `Some` and flattens the resulting\n * `Option`. If the input is `None`, it remains `None`.\n *\n * **Details**\n *\n * This function allows you to chain computations that return `Option` values.\n * If the input `Option` is `Some`, the provided function `f` is applied to the\n * contained value, and the resulting `Option` is returned. If the input is\n * `None`, the function is not applied, and the result remains `None`.\n *\n * This utility is particularly useful for sequencing operations that may fail\n * or produce optional results, enabling clean and concise workflows for\n * handling such cases.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * interface Address {\n *   readonly city: string\n *   readonly street: Option.Option<string>\n * }\n *\n * interface User {\n *   readonly id: number\n *   readonly username: string\n *   readonly email: Option.Option<string>\n *   readonly address: Option.Option<Address>\n * }\n *\n * const user: User = {\n *   id: 1,\n *   username: \"john_doe\",\n *   email: Option.some(\"john.doe@example.com\"),\n *   address: Option.some({\n *     city: \"New York\",\n *     street: Option.some(\"123 Main St\")\n *   })\n * }\n *\n * // Use flatMap to extract the street value\n * const street = user.address.pipe(\n *   Option.flatMap((address) => address.street)\n * )\n *\n * console.log(street)\n * // Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }\n * ```\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => isNone(self) ? none() : f(self.value));\n/**\n * Chains two `Option`s together. The second `Option` can either be a static\n * value or depend on the result of the first `Option`.\n *\n * **Details**\n *\n * This function enables sequencing of two `Option` computations. If the first\n * `Option` is `Some`, the second `Option` is evaluated. The second `Option` can\n * either:\n *\n * - Be a static `Option` value.\n * - Be a function that produces an `Option`, optionally based on the value of\n *   the first `Option`.\n *\n * If the first `Option` is `None`, the function skips the evaluation of the\n * second `Option` and directly returns `None`.\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const andThen = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => {\n  const b = isFunction(f) ? f(a) : f;\n  return isOption(b) ? b : some(b);\n}));\n/**\n * Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`\n * using a function that may return `null` or `undefined`.\n *\n * **Details**\n *\n * This function applies a transformation function `f` to the value inside a\n * `Some`. The function `f` may return a value, `null`, or `undefined`. If `f`\n * returns a value, it is wrapped in a `Some`. If `f` returns `null` or\n * `undefined`, the result is `None`. If the input `Option` is `None`, the\n * function is not applied, and `None` is returned.\n *\n * This utility is particularly useful when working with deeply nested optional\n * values or chaining computations that may result in `null` or `undefined` at\n * some point.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: \"high street\" } } } }\n *\n * // Extracting a deeply nested property\n * console.log(\n *   Option.some(employee1)\n *     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n * )\n * // Output: { _id: 'Option', _tag: 'Some', value: 'high street' }\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * // Property does not exist\n * console.log(\n *   Option.some(employee2)\n *     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n * )\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const flatMapNullable = /*#__PURE__*/dual(2, (self, f) => isNone(self) ? none() : fromNullable(f(self.value)));\n/**\n * Flattens an `Option` of `Option` into a single `Option`.\n *\n * **Details**\n *\n * This function takes an `Option` that wraps another `Option` and flattens it\n * into a single `Option`. If the outer `Option` is `Some`, the function\n * extracts the inner `Option`. If the outer `Option` is `None`, the result\n * remains `None`.\n *\n * This is useful for simplifying nested `Option` structures that may arise\n * during functional operations.\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const flatten = /*#__PURE__*/flatMap(identity);\n/**\n * Combines two `Option`s, keeping the value from the second `Option` if both\n * are `Some`.\n *\n * **Details**\n *\n * This function takes two `Option`s and returns the second one if the first is\n * `Some`. If the first `Option` is `None`, the result will also be `None`,\n * regardless of the second `Option`. It effectively \"zips\" the two `Option`s\n * while discarding the value from the first `Option`.\n *\n * This is particularly useful when sequencing computations where the result of\n * the first computation is not needed, and you only care about the result of\n * the second computation.\n *\n * @category Zipping\n * @since 2.0.0\n */\nexport const zipRight = /*#__PURE__*/dual(2, (self, that) => flatMap(self, () => that));\n/**\n * Combines two `Option`s, keeping the value from the first `Option` if both are\n * `Some`.\n *\n * **Details**\n *\n * This function takes two `Option`s and returns the first one if it is `Some`.\n * If either the first `Option` or the second `Option` is `None`, the result\n * will be `None`. This operation \"zips\" the two `Option`s while discarding the\n * value from the second `Option`.\n *\n * This is useful when sequencing computations where the second `Option`\n * represents a dependency or condition that must hold, but its value is\n * irrelevant.\n *\n * @category Zipping\n * @since 2.0.0\n */\nexport const zipLeft = /*#__PURE__*/dual(2, (self, that) => tap(self, () => that));\n/**\n * Composes two functions that return `Option` values, creating a new function\n * that chains them together.\n *\n * **Details**\n *\n * This function allows you to compose two computations, each represented by a\n * function that returns an `Option`. The result of the first function is passed\n * to the second function if it is `Some`. If the first function returns `None`,\n * the composed function short-circuits and returns `None` without invoking the\n * second function.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const parse = (s: string): Option.Option<number> => isNaN(Number(s)) ? Option.none() : Option.some(Number(s))\n *\n * const double = (n: number): Option.Option<number> => n > 0 ? Option.some(n * 2) : Option.none()\n *\n * const parseAndDouble = Option.composeK(parse, double)\n *\n * console.log(parseAndDouble(\"42\"))\n * // Output: { _id: 'Option', _tag: 'Some', value: 84 }\n *\n * console.log(parseAndDouble(\"not a number\"))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const composeK = /*#__PURE__*/dual(2, (afb, bfc) => a => flatMap(afb(a), bfc));\n/**\n * Applies the provided function `f` to the value of the `Option` if it is\n * `Some` and returns the original `Option`, unless `f` returns `None`, in which\n * case it returns `None`.\n *\n * **Details**\n *\n * This function allows you to perform additional computations on the value of\n * an `Option` without modifying its original value. If the `Option` is `Some`,\n * the provided function `f` is executed with the value, and its result\n * determines whether the original `Option` is returned (`Some`) or the result\n * is `None` if `f` returns `None`. If the input `Option` is `None`, the\n * function is not executed, and `None` is returned.\n *\n * This is particularly useful for applying side conditions or performing\n * validation checks while retaining the original `Option`'s value.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()\n *\n * console.log(Option.tap(Option.none(), getInteger))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(Option.tap(Option.some(1), getInteger))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(Option.tap(Option.some(1.14), getInteger))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Sequencing\n * @since 2.0.0\n */\nexport const tap = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => map(f(a), () => a)));\n/**\n * Combines two `Option` values into a single `Option` containing a tuple of\n * their values if both are `Some`.\n *\n * **Details**\n *\n * This function takes two `Option`s and combines their values into a tuple `[A,\n * B]` if both are `Some`. If either of the `Option`s is `None`, the result is\n * `None`. This is particularly useful for combining multiple `Option` values\n * into a single one, ensuring both contain valid values.\n *\n * @category Combining\n * @since 2.0.0\n */\nexport const product = (self, that) => isSome(self) && isSome(that) ? some([self.value, that.value]) : none();\n/**\n * Combines an `Option` with a collection of `Option`s into a single `Option`\n * containing a tuple of their values if all are `Some`.\n *\n * **Details**\n *\n * This function takes a primary `Option` and a collection of `Option`s and\n * combines their values into a tuple `[A, ...Array<A>]` if all are `Some`. If\n * the primary `Option` or any `Option` in the collection is `None`, the result\n * is `None`.\n *\n * @category Combining\n * @since 2.0.0\n */\nexport const productMany = (self, collection) => {\n  if (isNone(self)) {\n    return none();\n  }\n  const out = [self.value];\n  for (const o of collection) {\n    if (isNone(o)) {\n      return none();\n    }\n    out.push(o.value);\n  }\n  return some(out);\n};\n/**\n * Combines a structure of `Option`s into a single `Option` containing the\n * values with the same structure.\n *\n * **Details**\n *\n * This function takes a structure of `Option`s (a tuple, struct, or iterable)\n * and produces a single `Option` that contains the values from the input\n * structure if all `Option`s are `Some`. If any `Option` in the input is\n * `None`, the result is `None`. The structure of the input is preserved in the\n * output.\n *\n * - If the input is a tuple (e.g., an array), the result will be an `Option`\n *   containing a tuple with the same length.\n * - If the input is a struct (e.g., an object), the result will be an `Option`\n *   containing a struct with the same keys.\n * - If the input is an iterable, the result will be an `Option` containing an\n *   array.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const maybeName: Option.Option<string> = Option.some(\"John\")\n * const maybeAge: Option.Option<number> = Option.some(25)\n *\n * //      ┌─── Option<[string, number]>\n * //      ▼\n * const tuple = Option.all([maybeName, maybeAge])\n * console.log(tuple)\n * // Output:\n * // { _id: 'Option', _tag: 'Some', value: [ 'John', 25 ] }\n *\n * //      ┌─── Option<{ name: string; age: number; }>\n * //      ▼\n * const struct = Option.all({ name: maybeName, age: maybeAge })\n * console.log(struct)\n * // Output:\n * // { _id: 'Option', _tag: 'Some', value: { name: 'John', age: 25 } }\n * ```\n *\n * @category Combining\n * @since 2.0.0\n */\n// @ts-expect-error\nexport const all = input => {\n  if (Symbol.iterator in input) {\n    const out = [];\n    for (const o of input) {\n      if (isNone(o)) {\n        return none();\n      }\n      out.push(o.value);\n    }\n    return some(out);\n  }\n  const out = {};\n  for (const key of Object.keys(input)) {\n    const o = input[key];\n    if (isNone(o)) {\n      return none();\n    }\n    out[key] = o.value;\n  }\n  return some(out);\n};\n/**\n * Combines two `Option` values into a new `Option` by applying a provided\n * function to their values.\n *\n * **Details**\n *\n * This function takes two `Option` values (`self` and `that`) and a combining\n * function `f`. If both `Option` values are `Some`, the function `f` is applied\n * to their values, and the result is wrapped in a new `Some`. If either\n * `Option` is `None`, the result is `None`.\n *\n * This utility is useful for combining two optional computations into a single\n * result while maintaining type safety and avoiding explicit checks for `None`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const maybeName: Option.Option<string> = Option.some(\"John\")\n * const maybeAge: Option.Option<number> = Option.some(25)\n *\n * // Combine the name and age into a person object\n * const person = Option.zipWith(maybeName, maybeAge, (name, age) => ({\n *   name: name.toUpperCase(),\n *   age\n * }))\n *\n * console.log(person)\n * // Output:\n * // { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n * ```\n *\n * @category Zipping\n * @since 2.0.0\n */\nexport const zipWith = /*#__PURE__*/dual(3, (self, that, f) => map(product(self, that), ([a, b]) => f(a, b)));\n/**\n * Applies a function inside a `Some` to a value inside another `Some`,\n * combining them into a new `Option`.\n *\n * **Details**\n *\n * This function allows you to apply a function wrapped in an `Option` (`self`)\n * to a value wrapped in another `Option` (`that`). If both `Option`s are\n * `Some`, the function is applied to the value, and the result is wrapped in a\n * new `Some`. If either `Option` is `None`, the result is `None`.\n *\n * @category Combining\n * @since 2.0.0\n */\nexport const ap = /*#__PURE__*/dual(2, (self, that) => zipWith(self, that, (f, a) => f(a)));\n/**\n * Reduces an `Iterable` of `Option<A>` to a single value of type `B`, ignoring\n * elements that are `None`.\n *\n * **Details**\n *\n * This function takes an initial value of type `B` and a reducing function `f`\n * that combines the accumulator with values of type `A`. It processes an\n * iterable of `Option<A>`, applying `f` only to the `Some` values while\n * ignoring the `None` values. The result is a single value of type `B`.\n *\n * This utility is particularly useful for aggregating values from an iterable\n * of `Option`s while skipping the absent (`None`) values.\n *\n * @example\n * ```ts\n * import { Option, pipe } from \"effect\"\n *\n * const iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]\n *\n * console.log(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)))\n * // Output: 3\n * ```\n *\n * @category Reducing\n * @since 2.0.0\n */\nexport const reduceCompact = /*#__PURE__*/dual(3, (self, b, f) => {\n  let out = b;\n  for (const oa of self) {\n    if (isSome(oa)) {\n      out = f(out, oa.value);\n    }\n  }\n  return out;\n});\n/**\n * Converts an `Option` into an `Array`.\n * If the input is `None`, an empty array is returned.\n * If the input is `Some`, its value is wrapped in a single-element array.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.toArray(Option.some(1)))\n * // Output: [1]\n *\n * console.log(Option.toArray(Option.none()))\n * // Output: []\n * ```\n *\n * @category Conversions\n * @since 2.0.0\n */\nexport const toArray = self => isNone(self) ? [] : [self.value];\n/**\n * Splits an `Option` into two `Option`s based on the result of a mapping\n * function that produces an `Either`.\n *\n * **Details**\n *\n * This function takes an `Option` and a mapping function `f` that converts its\n * value into an `Either`. It returns a tuple of two `Option`s:\n *\n * - The first `Option` (`left`) contains the value from the `Left` side of the\n *   `Either` if it exists, otherwise `None`.\n * - The second `Option` (`right`) contains the value from the `Right` side of\n *   the `Either` if it exists, otherwise `None`.\n *\n * If the input `Option` is `None`, both returned `Option`s are `None`.\n *\n * This utility is useful for filtering and categorizing the contents of an\n * `Option` based on a bifurcating computation.\n *\n * @category Filtering\n * @since 2.0.0\n */\nexport const partitionMap = /*#__PURE__*/dual(2, (self, f) => {\n  if (isNone(self)) {\n    return [none(), none()];\n  }\n  const e = f(self.value);\n  return either.isLeft(e) ? [some(e.left), none()] : [none(), some(e.right)];\n});\n// TODO(4.0): remove?\n/**\n * Alias of {@link flatMap}.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // Transform and filter numbers\n * const transformEven = (n: Option.Option<number>): Option.Option<string> =>\n *   Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))\n *\n * console.log(transformEven(Option.none()))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(transformEven(Option.some(1)))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(transformEven(Option.some(2)))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }\n * ```\n *\n * @category Filtering\n * @since 2.0.0\n */\nexport const filterMap = flatMap;\n/**\n * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n *\n * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const removeEmptyString = (input: Option.Option<string>) =>\n *   Option.filter(input, (value) => value !== \"\")\n *\n * console.log(removeEmptyString(Option.none()))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(removeEmptyString(Option.some(\"\")))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * console.log(removeEmptyString(Option.some(\"a\")))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n * ```\n *\n * @category Filtering\n * @since 2.0.0\n */\nexport const filter = /*#__PURE__*/dual(2, (self, predicate) => filterMap(self, b => predicate(b) ? option.some(b) : option.none));\n/**\n * Creates an `Equivalence` instance for comparing `Option` values, using a\n * provided `Equivalence` for the inner type.\n *\n * **Details**\n *\n * This function takes an `Equivalence` instance for a specific type `A` and\n * produces an `Equivalence` instance for `Option<A>`. The resulting\n * `Equivalence` determines whether two `Option` values are equivalent:\n *\n * - Two `None`s are considered equivalent.\n * - A `Some` and a `None` are not equivalent.\n * - Two `Some` values are equivalent if their inner values are equivalent\n *   according to the provided `Equivalence`.\n *\n * @example\n * ```ts\n * // Title: Comparing Optional Numbers for Equivalence\n * import { Number, Option } from \"effect\"\n *\n * const isEquivalent = Option.getEquivalence(Number.Equivalence)\n *\n * console.log(isEquivalent(Option.none(), Option.none()))\n * // Output: true\n *\n * console.log(isEquivalent(Option.none(), Option.some(1)))\n * // Output: false\n *\n * console.log(isEquivalent(Option.some(1), Option.none()))\n * // Output: false\n *\n * console.log(isEquivalent(Option.some(1), Option.some(2)))\n * // Output: false\n *\n * console.log(isEquivalent(Option.some(1), Option.some(1)))\n * // Output: true\n * ```\n *\n * @category Equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = isEquivalent => Equivalence.make((x, y) => isNone(x) ? isNone(y) : isNone(y) ? false : isEquivalent(x.value, y.value));\n/**\n * Creates an `Order` instance for comparing `Option` values, using a provided\n * `Order` for the inner type.\n *\n * **Details**\n *\n * This function produces an `Order` instance for `Option<A>`, allowing `Option`\n * values to be compared:\n *\n * - `None` is always considered less than any `Some` value.\n * - If both are `Some`, their inner values are compared using the provided\n *   `Order` instance.\n *\n * @example\n * ```ts\n * import { Number, Option } from \"effect\"\n *\n * const order = Option.getOrder(Number.Order)\n *\n * console.log(order(Option.none(), Option.none()))\n * // Output: 0\n *\n * console.log(order(Option.none(), Option.some(1)))\n * // Output: -1\n *\n * console.log(order(Option.some(1), Option.none()))\n * // Output: 1\n *\n * console.log(order(Option.some(1), Option.some(2)))\n * // Output: -1\n *\n * console.log(order(Option.some(1), Option.some(1)))\n * // Output: 0\n * ```\n *\n * @category Sorting\n * @since 2.0.0\n */\nexport const getOrder = O => order.make((self, that) => isSome(self) ? isSome(that) ? O(self.value, that.value) : 1 : -1);\n/**\n * Lifts a binary function to work with `Option` values, allowing the function\n * to operate on two `Option`s.\n *\n * **Details**\n *\n * This function takes a binary function `f` and returns a new function that\n * applies `f` to the values of two `Option`s (`self` and `that`). If both\n * `Option`s are `Some`, the binary function `f` is applied to their values, and\n * the result is wrapped in a new `Some`. If either `Option` is `None`, the\n * result is `None`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // A binary function to add two numbers\n * const add = (a: number, b: number): number => a + b\n *\n * // Lift the `add` function to work with `Option` values\n * const addOptions = Option.lift2(add)\n *\n * // Both `Option`s are `Some`\n * console.log(addOptions(Option.some(2), Option.some(3)))\n * // Output: { _id: 'Option', _tag: 'Some', value: 5 }\n *\n * // One `Option` is `None`\n * console.log(addOptions(Option.some(2), Option.none()))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Lifting\n * @since 2.0.0\n */\nexport const lift2 = f => dual(2, (self, that) => zipWith(self, that, f));\n/**\n * Lifts a `Predicate` or `Refinement` into the `Option` context, returning a\n * `Some` of the input value if the predicate is satisfied, or `None` otherwise.\n *\n * **Details**\n *\n * This function transforms a `Predicate` (or a more specific `Refinement`) into\n * a function that produces an `Option`. If the predicate evaluates to `true`,\n * the input value is wrapped in a `Some`. If the predicate evaluates to\n * `false`, the result is `None`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * // Check if a number is positive\n * const isPositive = (n: number) => n > 0\n *\n * //      ┌─── (b: number) => Option<number>\n * //      ▼\n * const parsePositive = Option.liftPredicate(isPositive)\n *\n * console.log(parsePositive(1))\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * console.log(parsePositive(-1))\n * // OUtput: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Lifting\n * @since 2.0.0\n */\nexport const liftPredicate = /*#__PURE__*/dual(2, (b, predicate) => predicate(b) ? some(b) : none());\n/**\n * Returns a function that checks if an `Option` contains a specified value,\n * using a provided equivalence function.\n *\n * **Details**\n *\n * This function allows you to check whether an `Option` contains a specific\n * value. It uses an equivalence function `isEquivalent` to compare the value\n * inside the `Option` to the provided value. If the `Option` is `Some` and the\n * equivalence function returns `true`, the result is `true`. If the `Option` is\n * `None` or the values are not equivalent, the result is `false`.\n *\n * @see {@link contains} for a version that uses the default `Equivalence`.\n *\n * @example\n * ```ts\n * import { Number, Option } from \"effect\"\n *\n * const contains = Option.containsWith(Number.Equivalence)\n *\n * console.log(Option.some(2).pipe(contains(2)))\n * // Output: true\n *\n * console.log(Option.some(1).pipe(contains(2)))\n * // Output: false\n *\n * console.log(Option.none().pipe(contains(2)))\n * // Output: false\n * ```\n *\n * @category Elements\n * @since 2.0.0\n */\nexport const containsWith = isEquivalent => dual(2, (self, a) => isNone(self) ? false : isEquivalent(self.value, a));\nconst _equivalence = /*#__PURE__*/Equal.equivalence();\n/**\n * Returns a function that checks if an `Option` contains a specified value\n * using the default `Equivalence`.\n *\n * **Details**\n *\n * This function allows you to check whether an `Option` contains a specific\n * value. It uses the default `Equivalence` for equality comparison. If the\n * `Option` is `Some` and its value is equivalent to the provided value, the\n * result is `true`. If the `Option` is `None` or the values are not equivalent,\n * the result is `false`.\n *\n * @see {@link containsWith} for a version that allows you to specify a custom equivalence function.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * console.log(Option.some(2).pipe(Option.contains(2)))\n * // Output: true\n *\n * console.log(Option.some(1).pipe(Option.contains(2)))\n * // Output: false\n *\n * console.log(Option.none().pipe(Option.contains(2)))\n * // Output: false\n * ```\n *\n * @category Elements\n * @since 2.0.0\n */\nexport const contains = /*#__PURE__*/containsWith(_equivalence);\n/**\n * Checks if a value in an `Option` satisfies a given predicate or refinement.\n *\n * **Details**\n *\n * This function allows you to check if a value inside a `Some` meets a\n * specified condition. If the `Option` is `None`, the result is `false`. If the\n * `Option` is `Some`, the provided predicate or refinement is applied to the\n * value:\n *\n * - If the condition is met, the result is `true`.\n * - If the condition is not met, the result is `false`.\n *\n * @example\n * ```ts\n * import { Option } from \"effect\"\n *\n * const isEven = (n: number) => n % 2 === 0\n *\n * console.log(Option.some(2).pipe(Option.exists(isEven)))\n * // Output: true\n *\n * console.log(Option.some(1).pipe(Option.exists(isEven)))\n * // Output: false\n *\n * console.log(Option.none().pipe(Option.exists(isEven)))\n * // Output: false\n * ```\n *\n * @category Elements\n * @since 2.0.0\n */\nexport const exists = /*#__PURE__*/dual(2, (self, refinement) => isNone(self) ? false : refinement(self.value));\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @see {@link Do}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @category Do notation\n * @since 2.0.0\n */\nexport const bindTo = /*#__PURE__*/doNotation.bindTo(map);\nconst let_ = /*#__PURE__*/doNotation.let_(map);\nexport {\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @see {@link Do}\n * @see {@link bind}\n * @see {@link bindTo}\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n *\n * ```\n * @category Do notation\n * @since 2.0.0\n */\nlet_ as let };\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @see {@link Do}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @category Do notation\n * @since 2.0.0\n */\nexport const bind = /*#__PURE__*/doNotation.bind(map, flatMap);\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * @see {@link bindTo}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Option, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Option.Do,\n *   Option.bind(\"x\", () => Option.some(2)),\n *   Option.bind(\"y\", () => Option.some(3)),\n *   Option.let(\"sum\", ({ x, y }) => x + y),\n *   Option.filter(({ x, y }) => x * y > 5)\n * )\n * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n * ```\n *\n * @category Do notation\n * @since 2.0.0\n */\nexport const Do = /*#__PURE__*/some({});\nconst adapter = /*#__PURE__*/Gen.adapter();\n/**\n * Similar to `Effect.gen`, `Option.gen` provides a more readable,\n * generator-based syntax for working with `Option` values, making code that\n * involves `Option` easier to write and understand. This approach is similar to\n * using `async/await` but tailored for `Option`.\n *\n * @example\n * ```ts\n * // Title: Using Option.gen to Create a Combined Value\n * import { Option } from \"effect\"\n *\n * const maybeName: Option.Option<string> = Option.some(\"John\")\n * const maybeAge: Option.Option<number> = Option.some(25)\n *\n * const person = Option.gen(function* () {\n *   const name = (yield* maybeName).toUpperCase()\n *   const age = yield* maybeAge\n *   return { name, age }\n * })\n *\n * console.log(person)\n * // Output:\n * // { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n * ```\n *\n * @category Generators\n * @since 2.0.0\n */\nexport const gen = (...args) => {\n  const f = args.length === 1 ? args[0] : args[1].bind(args[0]);\n  const iterator = f(adapter);\n  let state = iterator.next();\n  while (!state.done) {\n    const current = Gen.isGenKind(state.value) ? state.value.value : Gen.yieldWrapGet(state.value);\n    if (isNone(current)) {\n      return current;\n    }\n    state = iterator.next(current.value);\n  }\n  return some(state.value);\n};\n/**\n * Merges two optional values, applying a function if both exist.\n * Unlike {@link zipWith}, this function returns `None` only if both inputs are `None`.\n *\n * @internal\n */\nexport const mergeWith = f => (o1, o2) => {\n  if (isNone(o1)) {\n    return o2;\n  } else if (isNone(o2)) {\n    return o1;\n  }\n  return some(f(o1.value, o2.value));\n};\n//# sourceMappingURL=Option.js.map","/**\n * This module provides utility functions for working with tuples in TypeScript.\n *\n * @since 2.0.0\n */\nimport * as Equivalence from \"./Equivalence.js\";\nimport { dual } from \"./Function.js\";\nimport * as order from \"./Order.js\";\n/**\n * Constructs a new tuple from the provided values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { make } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(make(1, 'hello', true), [1, 'hello', true])\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const make = (...elements) => elements;\n/**\n * Return the first element of a tuple.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { getFirst } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(getFirst([\"hello\", 42]), \"hello\")\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getFirst = self => self[0];\n/**\n * Return the second element of a tuple.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { getSecond } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(getSecond([\"hello\", 42]), 42)\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getSecond = self => self[1];\n/**\n * Transforms each element of tuple using the given function, treating tuple homomorphically\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Tuple } from \"effect\"\n *\n * const result = pipe(\n *   [\"a\", 1, false] as const,\n *   Tuple.map((el) => el.toString().toUpperCase())\n * )\n * assert.deepStrictEqual(result, ['A', '1', 'FALSE'])\n * ```\n *\n * @category mapping\n * @since 3.9.0\n */\nexport const map = /*#__PURE__*/dual(2, (self, fn) => self.map(element => fn(element)));\n/**\n * Transforms both elements of a tuple using the given functions.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { mapBoth } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(\n *   mapBoth([\"hello\", 42], { onFirst: s => s.toUpperCase(), onSecond: n => n.toString() }),\n *   [\"HELLO\", \"42\"]\n * )\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapBoth = /*#__PURE__*/dual(2, (self, {\n  onFirst,\n  onSecond\n}) => [onFirst(self[0]), onSecond(self[1])]);\n/**\n * Transforms the first component of a tuple using a given function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { mapFirst } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(\n *   mapFirst([\"hello\", 42], s => s.toUpperCase()),\n *   [\"HELLO\", 42]\n * )\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapFirst = /*#__PURE__*/dual(2, (self, f) => [f(self[0]), self[1]]);\n/**\n * Transforms the second component of a tuple using a given function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { mapSecond } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(\n *   mapSecond([\"hello\", 42], n => n.toString()),\n *   [\"hello\", \"42\"]\n * )\n * ```\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapSecond = /*#__PURE__*/dual(2, (self, f) => [self[0], f(self[1])]);\n/**\n * Swaps the two elements of a tuple.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { swap } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(swap([\"hello\", 42]), [42, \"hello\"])\n * ```\n *\n * @since 2.0.0\n */\nexport const swap = self => [self[1], self[0]];\n/**\n * Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\n * by applying each `Equivalence` to the corresponding element of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const getEquivalence = Equivalence.tuple;\n/**\n * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\n * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\n * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\n * of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const getOrder = order.tuple;\n/**\n * Appends an element to the end of a tuple.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendElement = /*#__PURE__*/dual(2, (self, that) => [...self, that]);\n/**\n * Retrieves the element at a specified index from a tuple.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Tuple } from \"effect\"\n *\n * assert.deepStrictEqual(Tuple.at([1, 'hello', true], 1), 'hello')\n * ```\n *\n * @category getters\n * @since 3.4.0\n */\nexport const at = /*#__PURE__*/dual(2, (self, index) => self[index]);\nexport {\n/**\n * Determine if an `Array` is a tuple with exactly `N` elements, narrowing down the type to `TupleOf`.\n *\n * An `Array` is considered to be a `TupleOf` if its length is exactly `N`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isTupleOf } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(isTupleOf([1, 2, 3], 3), true);\n * assert.deepStrictEqual(isTupleOf([1, 2, 3], 2), false);\n * assert.deepStrictEqual(isTupleOf([1, 2, 3], 4), false);\n *\n * const arr: number[] = [1, 2, 3];\n * if (isTupleOf(arr, 3)) {\n *   console.log(arr);\n *   // ^? [number, number, number]\n * }\n *\n * ```\n * @category guards\n * @since 3.3.0\n */\nisTupleOf,\n/**\n * Determine if an `Array` is a tuple with at least `N` elements, narrowing down the type to `TupleOfAtLeast`.\n *\n * An `Array` is considered to be a `TupleOfAtLeast` if its length is at least `N`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isTupleOfAtLeast } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 3), true);\n * assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 2), true);\n * assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 4), false);\n *\n * const arr: number[] = [1, 2, 3, 4];\n * if (isTupleOfAtLeast(arr, 3)) {\n *   console.log(arr);\n *   // ^? [number, number, number, ...number[]]\n * }\n *\n * ```\n * @category guards\n * @since 3.3.0\n */\nisTupleOfAtLeast } from \"./Predicate.js\";\n//# sourceMappingURL=Tuple.js.map","/**\n * This module provides utility functions for working with arrays in TypeScript.\n *\n * @since 2.0.0\n */\nimport * as E from \"./Either.js\";\nimport * as Equal from \"./Equal.js\";\nimport * as Equivalence from \"./Equivalence.js\";\nimport { dual, identity } from \"./Function.js\";\nimport * as readonlyArray from \"./internal/array.js\";\nimport * as doNotation from \"./internal/doNotation.js\";\nimport * as EffectIterable from \"./Iterable.js\";\nimport * as O from \"./Option.js\";\nimport * as Order from \"./Order.js\";\nimport { isBoolean } from \"./Predicate.js\";\nimport * as Record from \"./Record.js\";\nimport * as Tuple from \"./Tuple.js\";\n/**\n * Builds a `NonEmptyArray` from an non-empty collection of elements.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.make(1, 2, 3)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const make = (...elements) => elements;\n/**\n * Creates a new `Array` of the specified length.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.allocate<number>(3)\n * console.log(result) // [ <3 empty items> ]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const allocate = n => new Array(n);\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * **Example**\n *\n * ```ts\n * import { makeBy } from \"effect/Array\"\n *\n * const result = makeBy(5, n => n * 2)\n * console.log(result) // [0, 2, 4, 6, 8]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const makeBy = /*#__PURE__*/dual(2, (n, f) => {\n  const max = Math.max(1, Math.floor(n));\n  const out = new Array(max);\n  for (let i = 0; i < max; i++) {\n    out[i] = f(i);\n  }\n  return out;\n});\n/**\n * Return a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * **Example**\n *\n * ```ts\n * import { range } from \"effect/Array\"\n *\n * const result = range(1, 3)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const range = (start, end) => start <= end ? makeBy(end - start + 1, i => start + i) : [start];\n/**\n * Return a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.replicate(\"a\", 3)\n * console.log(result) // [\"a\", \"a\", \"a\"]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const replicate = /*#__PURE__*/dual(2, (a, n) => makeBy(n, () => a));\n/**\n * Creates a new `Array` from an iterable collection of values.\n * If the input is already an array, it returns the input as-is.\n * Otherwise, it converts the iterable collection to an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.fromIterable(new Set([1, 2, 3]))\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterable = collection => Array.isArray(collection) ? collection : Array.from(collection);\n/**\n * Creates a new `Array` from a value that might not be an iterable.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.ensure(\"a\")) // [\"a\"]\n * console.log(Array.ensure([\"a\"])) // [\"a\"]\n * console.log(Array.ensure([\"a\", \"b\", \"c\"])) // [\"a\", \"b\", \"c\"]\n * ```\n *\n * @category constructors\n * @since 3.3.0\n */\nexport const ensure = self => Array.isArray(self) ? self : [self];\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.fromRecord({ a: 1, b: 2, c: 3 })\n * console.log(result) // [[\"a\", 1], [\"b\", 2], [\"c\", 3]]\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const fromRecord = Record.toEntries;\n/**\n * Converts an `Option` to an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * console.log(Array.fromOption(Option.some(1))) // [1]\n * console.log(Array.fromOption(Option.none())) // []\n * ```\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const fromOption = O.toArray;\n/**\n * Matches the elements of an array, applying functions to cases of empty and non-empty arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const match = Array.match({\n *   onEmpty: () => \"empty\",\n *   onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`\n * })\n * console.log(match([])) // \"empty\"\n * console.log(match([1, 2, 3])) // \"head: 1, tail: 2\"\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const match = /*#__PURE__*/dual(2, (self, {\n  onEmpty,\n  onNonEmpty\n}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());\n/**\n * Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const matchLeft = Array.matchLeft({\n *   onEmpty: () => \"empty\",\n *   onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`\n * })\n * console.log(matchLeft([])) // \"empty\"\n * console.log(matchLeft([1, 2, 3])) // \"head: 1, tail: 2\"\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const matchLeft = /*#__PURE__*/dual(2, (self, {\n  onEmpty,\n  onNonEmpty\n}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());\n/**\n * Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const matchRight = Array.matchRight({\n *   onEmpty: () => \"empty\",\n *   onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`\n * })\n * console.log(matchRight([])) // \"empty\"\n * console.log(matchRight([1, 2, 3])) // \"init: 2, last: 3\"\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const matchRight = /*#__PURE__*/dual(2, (self, {\n  onEmpty,\n  onNonEmpty\n}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty());\n/**\n * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.prepend([2, 3, 4], 1)\n * console.log(result) // [1, 2, 3, 4]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prepend = /*#__PURE__*/dual(2, (self, head) => [head, ...self]);\n/**\n * Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\n * If either array is non-empty, the result is also a non-empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.prependAll([2, 3], [0, 1])\n * console.log(result) // [0, 1, 2, 3]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAll = /*#__PURE__*/dual(2, (self, that) => fromIterable(that).concat(fromIterable(self)));\n/**\n * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.append([1, 2, 3], 4);\n * console.log(result) // [1, 2, 3, 4]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const append = /*#__PURE__*/dual(2, (self, last) => [...self, last]);\n/**\n * Concatenates two arrays (or iterables), combining their elements.\n * If either array is non-empty, the result is also a non-empty array.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendAll = /*#__PURE__*/dual(2, (self, that) => fromIterable(self).concat(fromIterable(that)));\n/**\n * Accumulates values from an `Iterable` starting from the left, storing\n * each intermediate result in an array. Useful for tracking the progression of\n * a value through a series of transformations.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\";\n *\n * const result = Array.scan([1, 2, 3, 4], 0, (acc, value) => acc + value)\n * console.log(result) // [0, 1, 3, 6, 10]\n *\n * // Explanation:\n * // This function starts with the initial value (0 in this case)\n * // and adds each element of the array to this accumulator one by one,\n * // keeping track of the cumulative sum after each addition.\n * // Each of these sums is captured in the resulting array.\n * ```\n *\n * @category folding\n * @since 2.0.0\n */\nexport const scan = /*#__PURE__*/dual(3, (self, b, f) => {\n  const out = [b];\n  let i = 0;\n  for (const a of self) {\n    out[i + 1] = f(out[i], a);\n    i++;\n  }\n  return out;\n});\n/**\n * Accumulates values from an `Iterable` starting from the right, storing\n * each intermediate result in an array. Useful for tracking the progression of\n * a value through a series of transformations.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\";\n *\n * const result = Array.scanRight([1, 2, 3, 4], 0, (acc, value) => acc + value)\n * console.log(result) // [10, 9, 7, 4, 0]\n * ```\n *\n * @category folding\n * @since 2.0.0\n */\nexport const scanRight = /*#__PURE__*/dual(3, (self, b, f) => {\n  const input = fromIterable(self);\n  const out = new Array(input.length + 1);\n  out[input.length] = b;\n  for (let i = input.length - 1; i >= 0; i--) {\n    out[i] = f(out[i + 1], input[i]);\n  }\n  return out;\n});\n/**\n * Determine if `unknown` is an Array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isArray(null)) // false\n * console.log(Array.isArray([1, 2, 3])) // true\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isArray = Array.isArray;\n/**\n * Determine if an `Array` is empty narrowing down the type to `[]`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isEmptyArray([])) // true\n * console.log(Array.isEmptyArray([1, 2, 3])) // false\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmptyArray = self => self.length === 0;\n/**\n * Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isEmptyReadonlyArray([])) // true\n * console.log(Array.isEmptyReadonlyArray([1, 2, 3])) // false\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmptyReadonlyArray = isEmptyArray;\n/**\n * Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.\n *\n * An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isNonEmptyArray([])) // false\n * console.log(Array.isNonEmptyArray([1, 2, 3])) // true\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNonEmptyArray = readonlyArray.isNonEmptyArray;\n/**\n * Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.\n *\n * A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * console.log(Array.isNonEmptyReadonlyArray([])) // false\n * console.log(Array.isNonEmptyReadonlyArray([1, 2, 3])) // true\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNonEmptyReadonlyArray = readonlyArray.isNonEmptyArray;\n/**\n * Return the number of elements in a `ReadonlyArray`.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const length = self => self.length;\nconst isOutOfBound = (i, as) => i < 0 || i >= as.length;\nconst clamp = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));\n/**\n * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const get = /*#__PURE__*/dual(2, (self, index) => {\n  const i = Math.floor(index);\n  return isOutOfBound(i, self) ? O.none() : O.some(self[i]);\n});\n/**\n * Gets an element unsafely, will throw on out of bounds.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet = /*#__PURE__*/dual(2, (self, index) => {\n  const i = Math.floor(index);\n  if (isOutOfBound(i, self)) {\n    throw new Error(`Index ${i} out of bounds`);\n  }\n  return self[i];\n});\n/**\n * Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\";\n *\n * const result = Array.unprepend([1, 2, 3, 4])\n * console.log(result) // [1, [2, 3, 4]]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const unprepend = self => [headNonEmpty(self), tailNonEmpty(self)];\n/**\n * Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\";\n *\n * const result = Array.unappend([1, 2, 3, 4])\n * console.log(result) // [[1, 2, 3], 4]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const unappend = self => [initNonEmpty(self), lastNonEmpty(self)];\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const head = /*#__PURE__*/get(0);\n/**\n * Get the first element of a non empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.headNonEmpty([1, 2, 3, 4])\n * console.log(result) // 1\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const headNonEmpty = /*#__PURE__*/unsafeGet(0);\n/**\n * Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const last = self => isNonEmptyReadonlyArray(self) ? O.some(lastNonEmpty(self)) : O.none();\n/**\n * Get the last element of a non empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.lastNonEmpty([1, 2, 3, 4])\n * console.log(result) // 4\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const lastNonEmpty = self => self[self.length - 1];\n/**\n * Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const tail = self => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? O.some(tailNonEmpty(input)) : O.none();\n};\n/**\n * Get all but the first element of a `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.tailNonEmpty([1, 2, 3, 4])\n * console.log(result) // [2, 3, 4]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const tailNonEmpty = self => self.slice(1);\n/**\n * Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const init = self => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? O.some(initNonEmpty(input)) : O.none();\n};\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.initNonEmpty([1, 2, 3, 4])\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const initNonEmpty = self => self.slice(0, -1);\n/**\n * Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.take([1, 2, 3, 4, 5], 3)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const take = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  return input.slice(0, clamp(n, input));\n});\n/**\n * Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.takeRight([1, 2, 3, 4, 5], 3)\n * console.log(result) // [3, 4, 5]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const takeRight = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  const i = clamp(n, input);\n  return i === 0 ? [] : input.slice(-i);\n});\n/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\n * console.log(result) // [1, 3, 2]\n *\n * // Explanation:\n * // - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n * // - The next element (`3`) is also less than `4`, so it adds `3`.\n * // - The next element (`2`) is again less than `4`, so it adds `2`.\n * // - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const takeWhile = /*#__PURE__*/dual(2, (self, predicate) => {\n  let i = 0;\n  const out = [];\n  for (const a of self) {\n    if (!predicate(a, i)) {\n      break;\n    }\n    out.push(a);\n    i++;\n  }\n  return out;\n});\nconst spanIndex = (self, predicate) => {\n  let i = 0;\n  for (const a of self) {\n    if (!predicate(a, i)) {\n      break;\n    }\n    i++;\n  }\n  return i;\n};\n/**\n * Split an `Iterable` into two parts:\n *\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const span = /*#__PURE__*/dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));\n/**\n * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.drop([1, 2, 3, 4, 5], 2)\n * console.log(result) // [3, 4, 5]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const drop = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  return input.slice(clamp(n, input), input.length);\n});\n/**\n * Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dropRight([1, 2, 3, 4, 5], 2)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const dropRight = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  return input.slice(0, input.length - clamp(n, input));\n});\n/**\n * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)\n * console.log(result) // [4, 5]\n * ```\n *\n * @category getters\n * @since 2.0.0\n */\nexport const dropWhile = /*#__PURE__*/dual(2, (self, predicate) => fromIterable(self).slice(spanIndex(self, predicate)));\n/**\n * Return the first index for which a predicate holds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)\n * console.log(result) // Option.some(2)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirstIndex = /*#__PURE__*/dual(2, (self, predicate) => {\n  let i = 0;\n  for (const a of self) {\n    if (predicate(a, i)) {\n      return O.some(i);\n    }\n    i++;\n  }\n  return O.none();\n});\n/**\n * Return the last index for which a predicate holds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)\n * console.log(result) // Option.some(1)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLastIndex = /*#__PURE__*/dual(2, (self, predicate) => {\n  const input = fromIterable(self);\n  for (let i = input.length - 1; i >= 0; i--) {\n    if (predicate(input[i], i)) {\n      return O.some(i);\n    }\n  }\n  return O.none();\n});\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\n * console.log(result) // Option.some(4)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst = EffectIterable.findFirst;\n/**\n * Finds the last element in an iterable collection that satisfies the given predicate or refinement.\n * Returns an `Option` containing the found element, or `Option.none` if no element matches.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\n * console.log(result) // Option.some(4)\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLast = /*#__PURE__*/dual(2, (self, f) => {\n  const input = fromIterable(self);\n  for (let i = input.length - 1; i >= 0; i--) {\n    const a = input[i];\n    const o = f(a, i);\n    if (isBoolean(o)) {\n      if (o) {\n        return O.some(a);\n      }\n    } else {\n      if (O.isSome(o)) {\n        return o;\n      }\n    }\n  }\n  return O.none();\n});\n/**\n * Insert an element at the specified index, creating a new `NonEmptyArray`,\n * or return `None` if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.insertAt(['a', 'b', 'c', 'e'], 3, 'd')\n * console.log(result) // Option.some(['a', 'b', 'c', 'd', 'e'])\n * ```\n *\n * @since 2.0.0\n */\nexport const insertAt = /*#__PURE__*/dual(3, (self, i, b) => {\n  const out = Array.from(self);\n  //             v--- `= self.length` is ok, it means inserting in last position\n  if (i < 0 || i > out.length) {\n    return O.none();\n  }\n  out.splice(i, 0, b);\n  return O.some(out);\n});\n/**\n * Change the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.replace(['a', 'b', 'c', 'd'], 1, 'z')\n * console.log(result) // ['a', 'z', 'c', 'd']\n * ```\n *\n * @since 2.0.0\n */\nexport const replace = /*#__PURE__*/dual(3, (self, i, b) => modify(self, i, () => b));\n/**\n * Replaces an element in an array with the given value, returning an option of the updated array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.replaceOption([1, 2, 3], 1, 4)\n * console.log(result) // Option.some([1, 4, 3])\n * ```\n *\n * @since 2.0.0\n */\nexport const replaceOption = /*#__PURE__*/dual(3, (self, i, b) => modifyOption(self, i, () => b));\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.modify([1, 2, 3, 4], 2, (n) => n * 2)\n * console.log(result) // [1, 2, 6, 4]\n * ```\n *\n * @since 2.0.0\n */\nexport const modify = /*#__PURE__*/dual(3, (self, i, f) => O.getOrElse(modifyOption(self, i, f), () => Array.from(self)));\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return `None` if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const input = [1, 2, 3, 4]\n * const result = Array.modifyOption(input, 2, (n) => n * 2)\n * console.log(result) // Option.some([1, 2, 6, 4])\n *\n * const outOfBoundsResult = Array.modifyOption(input, 5, (n) => n * 2)\n * console.log(outOfBoundsResult) // Option.none()\n * ```\n *\n * @since 2.0.0\n */\nexport const modifyOption = /*#__PURE__*/dual(3, (self, i, f) => {\n  const out = Array.from(self);\n  if (isOutOfBound(i, out)) {\n    return O.none();\n  }\n  const next = f(out[i]);\n  // @ts-expect-error\n  out[i] = next;\n  return O.some(out);\n});\n/**\n * Delete the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const input = [1, 2, 3, 4]\n * const result = Array.remove(input, 2)\n * console.log(result) // [1, 2, 4]\n *\n * const outOfBoundsResult = Array.remove(input, 5)\n * console.log(outOfBoundsResult) // [1, 2, 3, 4]\n * ```\n *\n * @since 2.0.0\n */\nexport const remove = /*#__PURE__*/dual(2, (self, i) => {\n  const out = Array.from(self);\n  if (isOutOfBound(i, out)) {\n    return out;\n  }\n  out.splice(i, 1);\n  return out;\n});\n/**\n * Reverse an `Iterable`, creating a new `Array`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.reverse([1, 2, 3, 4])\n * console.log(result) // [4, 3, 2, 1]\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const reverse = self => Array.from(self).reverse();\n/**\n * Create a new array with elements sorted in increasing order based on the specified comparator.\n * If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.\n *\n * @category sorting\n * @since 2.0.0\n */\nexport const sort = /*#__PURE__*/dual(2, (self, O) => {\n  const out = Array.from(self);\n  out.sort(O);\n  return out;\n});\n/**\n * Sorts an array based on a provided mapping function and order. The mapping\n * function transforms the elements into a value that can be compared, and the\n * order defines how those values should be sorted.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Order } from \"effect\"\n *\n * const result = Array.sortWith([\"aaa\", \"b\", \"cc\"], (s) => s.length, Order.number)\n * console.log(result) // [\"b\", \"cc\", \"aaa\"]\n *\n * // Explanation:\n * // The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n * // converts each string into its length, and the `Order.number` specifies that the lengths should\n * // be sorted in ascending order.\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const sortWith = /*#__PURE__*/dual(3, (self, f, order) => Array.from(self).map(a => [a, f(a)]).sort((a, b) => order(a[1], b[1])).map(x => x[0]));\n/**\n * Sorts the elements of an `Iterable` in increasing order based on the provided\n * orders. The elements are compared using the first order in `orders`, then the\n * second order if the first comparison is equal, and so on.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Order, pipe } from \"effect\"\n *\n * const users = [\n *   { name: \"Alice\", age: 30 },\n *   { name: \"Bob\", age: 25 },\n *   { name: \"Charlie\", age: 30 }\n * ]\n *\n * const result = pipe(\n *   users,\n *   Array.sortBy(\n *     Order.mapInput(Order.number, (user: (typeof users)[number]) => user.age),\n *     Order.mapInput(Order.string, (user: (typeof users)[number]) => user.name)\n *   )\n * )\n *\n * console.log(result)\n * // [\n * //   { name: \"Bob\", age: 25 },\n * //   { name: \"Alice\", age: 30 },\n * //   { name: \"Charlie\", age: 30 }\n * // ]\n *\n * // Explanation:\n * // The array of users is sorted first by age in ascending order. When ages are equal,\n * // the users are further sorted by name in ascending order.\n * ```\n *\n * @category sorting\n * @since 2.0.0\n */\nexport const sortBy = (...orders) => {\n  const sortByAll = sort(Order.combineAll(orders));\n  return self => {\n    const input = fromIterable(self);\n    if (isNonEmptyReadonlyArray(input)) {\n      return sortByAll(input);\n    }\n    return [];\n  };\n};\n/**\n * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n * If one input `Iterable` is short, excess elements of the\n * longer `Iterable` are discarded.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.zip([1, 2, 3], ['a', 'b'])\n * console.log(result) // [[1, 'a'], [2, 'b']]\n * ```\n *\n * @category zipping\n * @since 2.0.0\n */\nexport const zip = /*#__PURE__*/dual(2, (self, that) => zipWith(self, that, Tuple.make));\n/**\n * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\n * console.log(result) // [5, 7, 9]\n * ```\n *\n * @category zipping\n * @since 2.0.0\n */\nexport const zipWith = /*#__PURE__*/dual(3, (self, that, f) => {\n  const as = fromIterable(self);\n  const bs = fromIterable(that);\n  if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {\n    const out = [f(headNonEmpty(as), headNonEmpty(bs))];\n    const len = Math.min(as.length, bs.length);\n    for (let i = 1; i < len; i++) {\n      out[i] = f(as[i], bs[i]);\n    }\n    return out;\n  }\n  return [];\n});\n/**\n * This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.unzip([[1, \"a\"], [2, \"b\"], [3, \"c\"]])\n * console.log(result) // [[1, 2, 3], ['a', 'b', 'c']]\n * ```\n *\n * @since 2.0.0\n */\nexport const unzip = self => {\n  const input = fromIterable(self);\n  if (isNonEmptyReadonlyArray(input)) {\n    const fa = [input[0][0]];\n    const fb = [input[0][1]];\n    for (let i = 1; i < input.length; i++) {\n      fa[i] = input[i][0];\n      fb[i] = input[i][1];\n    }\n    return [fa, fb];\n  }\n  return [[], []];\n};\n/**\n * Places an element in between members of an `Iterable`.\n * If the input is a non-empty array, the result is also a non-empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.intersperse([1, 2, 3], 0)\n * console.log(result) // [1, 0, 2, 0, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const intersperse = /*#__PURE__*/dual(2, (self, middle) => {\n  const input = fromIterable(self);\n  if (isNonEmptyReadonlyArray(input)) {\n    const out = [headNonEmpty(input)];\n    const tail = tailNonEmpty(input);\n    for (let i = 0; i < tail.length; i++) {\n      if (i < tail.length) {\n        out.push(middle);\n      }\n      out.push(tail[i]);\n    }\n    return out;\n  }\n  return [];\n});\n/**\n * Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)\n * console.log(result) // [10, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const modifyNonEmptyHead = /*#__PURE__*/dual(2, (self, f) => [f(headNonEmpty(self)), ...tailNonEmpty(self)]);\n/**\n * Change the head, creating a new `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.setNonEmptyHead([1, 2, 3], 10)\n * console.log(result) // [10, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const setNonEmptyHead = /*#__PURE__*/dual(2, (self, b) => modifyNonEmptyHead(self, () => b));\n/**\n * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)\n * console.log(result) // [1, 2, 6]\n * ```\n *\n * @since 2.0.0\n */\nexport const modifyNonEmptyLast = /*#__PURE__*/dual(2, (self, f) => append(initNonEmpty(self), f(lastNonEmpty(self))));\n/**\n * Change the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.setNonEmptyLast([1, 2, 3], 4)\n * console.log(result) // [1, 2, 4]\n * ```\n *\n * @since 2.0.0\n */\nexport const setNonEmptyLast = /*#__PURE__*/dual(2, (self, b) => modifyNonEmptyLast(self, () => b));\n/**\n * Rotate an `Iterable` by `n` steps.\n * If the input is a non-empty array, the result is also a non-empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.rotate(['a', 'b', 'c', 'd'], 2)\n * console.log(result) // ['c', 'd', 'a', 'b']\n * ```\n *\n * @since 2.0.0\n */\nexport const rotate = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  if (isNonEmptyReadonlyArray(input)) {\n    const len = input.length;\n    const m = Math.round(n) % len;\n    if (isOutOfBound(Math.abs(m), input) || m === 0) {\n      return copy(input);\n    }\n    if (m < 0) {\n      const [f, s] = splitNonEmptyAt(input, -m);\n      return appendAll(s, f);\n    } else {\n      return rotate(self, m - len);\n    }\n  }\n  return [];\n});\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const isEquivalent = (a: number, b: number) => a === b\n * const containsNumber = Array.containsWith(isEquivalent)\n * const result = pipe([1, 2, 3, 4], containsNumber(3))\n * console.log(result) // true\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const containsWith = isEquivalent => dual(2, (self, a) => {\n  for (const i of self) {\n    if (isEquivalent(a, i)) {\n      return true;\n    }\n  }\n  return false;\n});\nconst _equivalence = /*#__PURE__*/Equal.equivalence();\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))\n * console.log(result) // true\n * ```\n *\n * @category elements\n * @since 2.0.0\n */\nexport const contains = /*#__PURE__*/containsWith(_equivalence);\n/**\n * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n * value and the rest of the `Array`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\n * console.log(result) // [2, 4, 6, 8, 10]\n *\n * // Explanation:\n * // The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n * // The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n * // resulting in a new array `[2, 4, 6, 8, 10]`.\n * ```\n *\n * @since 2.0.0\n */\nexport const chop = /*#__PURE__*/dual(2, (self, f) => {\n  const input = fromIterable(self);\n  if (isNonEmptyReadonlyArray(input)) {\n    const [b, rest] = f(input);\n    const out = [b];\n    let next = rest;\n    while (readonlyArray.isNonEmptyArray(next)) {\n      const [b, rest] = f(next);\n      out.push(b);\n      next = rest;\n    }\n    return out;\n  }\n  return [];\n});\n/**\n * Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.\n * The value of `n` can be `0`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.splitAt([1, 2, 3, 4, 5], 3)\n * console.log(result) // [[1, 2, 3], [4, 5]]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitAt = /*#__PURE__*/dual(2, (self, n) => {\n  const input = Array.from(self);\n  const _n = Math.floor(n);\n  if (isNonEmptyReadonlyArray(input)) {\n    if (_n >= 1) {\n      return splitNonEmptyAt(input, _n);\n    }\n    return [[], input];\n  }\n  return [input, []];\n});\n/**\n * Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.\n * The value of `n` must be `>= 1`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.splitNonEmptyAt([\"a\", \"b\", \"c\", \"d\", \"e\"], 3)\n * console.log(result) // [[\"a\", \"b\", \"c\"], [\"d\", \"e\"]]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitNonEmptyAt = /*#__PURE__*/dual(2, (self, n) => {\n  const _n = Math.max(1, Math.floor(n));\n  return _n >= self.length ? [copy(self), []] : [prepend(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)];\n});\n/**\n * Splits this iterable into `n` equally sized arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.split([1, 2, 3, 4, 5, 6, 7, 8], 3)\n * console.log(result) // [[1, 2, 3], [4, 5, 6], [7, 8]]\n * ```\n *\n * @since 2.0.0\n * @category splitting\n */\nexport const split = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  return chunksOf(input, Math.ceil(input.length / Math.floor(n)));\n});\n/**\n * Splits this iterable on the first element that matches this predicate.\n * Returns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.splitWhere([1, 2, 3, 4, 5], n => n > 3)\n * console.log(result) // [[1, 2, 3], [4, 5]]\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitWhere = /*#__PURE__*/dual(2, (self, predicate) => span(self, (a, i) => !predicate(a, i)));\n/**\n * Copies an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.copy([1, 2, 3])\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const copy = self => self.slice();\n/**\n * Pads an array.\n * Returns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.\n * If `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.\n * If `n` is less than or equal to 0, the returned array will be an empty array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.pad([1, 2, 3], 6, 0)\n * console.log(result) // [1, 2, 3, 0, 0, 0]\n * ```\n *\n * @since 3.8.4\n */\nexport const pad = /*#__PURE__*/dual(3, (self, n, fill) => {\n  if (self.length >= n) {\n    return take(self, n);\n  }\n  return appendAll(self, makeBy(n - self.length, () => fill));\n});\n/**\n * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts skip-type-checking\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `self`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.chunksOf([1, 2, 3, 4, 5], 2)\n * console.log(result) // [[1, 2], [3, 4], [5]]\n *\n * // Explanation:\n * // The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n * // It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n * // the last chunk contains the remaining elements.\n * // The result is `[[1, 2], [3, 4], [5]]`.\n * ```\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const chunksOf = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  if (isNonEmptyReadonlyArray(input)) {\n    return chop(input, splitNonEmptyAt(n));\n  }\n  return [];\n});\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.groupWith([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"a\"], (x, y) => x === y)\n * console.log(result) // [[\"a\", \"a\"], [\"b\", \"b\", \"b\"], [\"c\"], [\"a\"]]\n * ```\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const groupWith = /*#__PURE__*/dual(2, (self, isEquivalent) => chop(self, as => {\n  const h = headNonEmpty(as);\n  const out = [h];\n  let i = 1;\n  for (; i < as.length; i++) {\n    const a = as[i];\n    if (isEquivalent(a, h)) {\n      out.push(a);\n    } else {\n      break;\n    }\n  }\n  return [out, as.slice(i)];\n}));\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.group([1, 1, 2, 2, 2, 3, 1])\n * console.log(result) // [[1, 1], [2, 2, 2], [3], [1]]\n * ```\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const group = /*#__PURE__*/groupWith( /*#__PURE__*/Equal.equivalence());\n/**\n * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const people = [\n *   { name: \"Alice\", group: \"A\" },\n *   { name: \"Bob\", group: \"B\" },\n *   { name: \"Charlie\", group: \"A\" }\n * ]\n *\n * const result = Array.groupBy(people, person => person.group)\n * console.log(result)\n * // {\n * //  A: [{ name: \"Alice\", group: \"A\" }, { name: \"Charlie\", group: \"A\" }],\n * //  B: [{ name: \"Bob\", group: \"B\" }]\n * // }\n * ```\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const groupBy = /*#__PURE__*/dual(2, (self, f) => {\n  const out = {};\n  for (const a of self) {\n    const k = f(a);\n    if (Object.prototype.hasOwnProperty.call(out, k)) {\n      out[k].push(a);\n    } else {\n      out[k] = [a];\n    }\n  }\n  return out;\n});\n/**\n * Calculates the union of two arrays using the provided equivalence relation.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\n * console.log(union) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const unionWith = /*#__PURE__*/dual(3, (self, that, isEquivalent) => {\n  const a = fromIterable(self);\n  const b = fromIterable(that);\n  if (isNonEmptyReadonlyArray(a)) {\n    if (isNonEmptyReadonlyArray(b)) {\n      const dedupe = dedupeWith(isEquivalent);\n      return dedupe(appendAll(a, b));\n    }\n    return a;\n  }\n  return b;\n});\n/**\n * Creates a union of two arrays, removing duplicates.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.union([1, 2], [2, 3])\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const union = /*#__PURE__*/dual(2, (self, that) => unionWith(self, that, _equivalence));\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]\n * const array2 = [{ id: 3 }, { id: 4 }, { id: 1 }]\n * const isEquivalent = (a: { id: number }, b: { id: number }) => a.id === b.id\n * const result = Array.intersectionWith(isEquivalent)(array2)(array1)\n * console.log(result) // [{ id: 1 }, { id: 3 }]\n * ```\n *\n * @since 2.0.0\n */\nexport const intersectionWith = isEquivalent => {\n  const has = containsWith(isEquivalent);\n  return dual(2, (self, that) => fromIterable(self).filter(a => has(that, a)));\n};\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.intersection([1, 2, 3], [3, 4, 1])\n * console.log(result) // [1, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const intersection = /*#__PURE__*/intersectionWith(_equivalence);\n/**\n * Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const array1 = [1, 2, 3]\n * const array2 = [2, 3, 4]\n * const difference = Array.differenceWith<number>((a, b) => a === b)(array1, array2)\n * console.log(difference) // [1]\n * ```\n *\n * @since 2.0.0\n */\nexport const differenceWith = isEquivalent => {\n  const has = containsWith(isEquivalent);\n  return dual(2, (self, that) => fromIterable(self).filter(a => !has(that, a)));\n};\n/**\n * Creates a `Array` of values not included in the other given `Iterable`.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const difference = Array.difference([1, 2, 3], [2, 3, 4])\n * console.log(difference) // [1]\n * ```\n *\n * @since 2.0.0\n */\nexport const difference = /*#__PURE__*/differenceWith(_equivalence);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const empty = () => [];\n/**\n * Constructs a new `NonEmptyArray<A>` from the specified value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const of = a => [a];\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport const map = /*#__PURE__*/dual(2, (self, f) => self.map(f));\n/**\n * Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  if (isEmptyReadonlyArray(self)) {\n    return [];\n  }\n  const out = [];\n  for (let i = 0; i < self.length; i++) {\n    const inner = f(self[i], i);\n    for (let j = 0; j < inner.length; j++) {\n      out.push(inner[j]);\n    }\n  }\n  return out;\n});\n/**\n * Combines multiple arrays into a single array by concatenating all elements\n * from each nested array. This function ensures that the structure of nested\n * arrays is collapsed into a single, flat array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.flatten([[1, 2], [], [3, 4], [], [5, 6]])\n * console.log(result) // [1, 2, 3, 4, 5, 6]\n * ```\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatten = /*#__PURE__*/flatMap(identity);\n/**\n * Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.\n * This method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n *\n * const result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);\n * console.log(result) // [4, 16]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const filterMap = /*#__PURE__*/dual(2, (self, f) => {\n  const as = fromIterable(self);\n  const out = [];\n  for (let i = 0; i < as.length; i++) {\n    const o = f(as[i], i);\n    if (O.isSome(o)) {\n      out.push(o.value);\n    }\n  }\n  return out;\n});\n/**\n * Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.\n * This method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.\n * This is useful when you need to transform an array but only up to the point where a certain condition holds true.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n *\n * const result = Array.filterMapWhile([2, 4, 5], toSquareTillOdd)\n * console.log(result) // [4, 16]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const filterMapWhile = /*#__PURE__*/dual(2, (self, f) => {\n  let i = 0;\n  const out = [];\n  for (const a of self) {\n    const b = f(a, i);\n    if (O.isSome(b)) {\n      out.push(b.value);\n    } else {\n      break;\n    }\n    i++;\n  }\n  return out;\n});\n/**\n * Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.\n * This function is particularly useful for operations where each element can result in two possible types,\n * and you want to separate these types into different collections. For instance, separating validation results\n * into successes and failures.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Either } from \"effect\";\n *\n * const isEven = (x: number) => x % 2 === 0\n *\n * const result = Array.partitionMap([1, 2, 3, 4, 5], x =>\n *   isEven(x) ? Either.right(x) : Either.left(x)\n * )\n * console.log(result)\n * // [\n * //   [1, 3, 5],\n * //   [2, 4]\n * // ]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partitionMap = /*#__PURE__*/dual(2, (self, f) => {\n  const left = [];\n  const right = [];\n  const as = fromIterable(self);\n  for (let i = 0; i < as.length; i++) {\n    const e = f(as[i], i);\n    if (E.isLeft(e)) {\n      left.push(e.left);\n    } else {\n      right.push(e.right);\n    }\n  }\n  return [left, right];\n});\n/**\n * Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Option } from \"effect\"\n *\n * const result = Array.getSomes([Option.some(1), Option.none(), Option.some(2)])\n * console.log(result) // [1, 2]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getSomes = /*#__PURE__*/filterMap(identity);\n/**\n * Retrieves the `Left` values from an `Iterable` of `Either`s, collecting them into an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Either } from \"effect\"\n *\n * const result = Array.getLefts([Either.right(1), Either.left(\"err\"), Either.right(2)])\n * console.log(result) // [\"err\"]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getLefts = self => {\n  const out = [];\n  for (const a of self) {\n    if (E.isLeft(a)) {\n      out.push(a.left);\n    }\n  }\n  return out;\n};\n/**\n * Retrieves the `Right` values from an `Iterable` of `Either`s, collecting them into an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Either } from \"effect\"\n *\n * const result = Array.getRights([Either.right(1), Either.left(\"err\"), Either.right(2)])\n * console.log(result) // [1, 2]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getRights = self => {\n  const out = [];\n  for (const a of self) {\n    if (E.isRight(a)) {\n      out.push(a.right);\n    }\n  }\n  return out;\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport const filter = /*#__PURE__*/dual(2, (self, predicate) => {\n  const as = fromIterable(self);\n  const out = [];\n  for (let i = 0; i < as.length; i++) {\n    if (predicate(as[i], i)) {\n      out.push(as[i]);\n    }\n  }\n  return out;\n});\n/**\n * Separate elements based on a predicate that also exposes the index of the element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\n * console.log(result) // [[1, 3], [2, 4]]\n * ```\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partition = /*#__PURE__*/dual(2, (self, predicate) => {\n  const left = [];\n  const right = [];\n  const as = fromIterable(self);\n  for (let i = 0; i < as.length; i++) {\n    if (predicate(as[i], i)) {\n      right.push(as[i]);\n    } else {\n      left.push(as[i]);\n    }\n  }\n  return [left, right];\n});\n/**\n * Separates an `Iterable` into two arrays based on a predicate.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const separate = /*#__PURE__*/partitionMap(identity);\n/**\n * Reduces an array from the left.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)\n * console.log(result) // 6\n * ```\n *\n * @category folding\n * @since 2.0.0\n */\nexport const reduce = /*#__PURE__*/dual(3, (self, b, f) => fromIterable(self).reduce((b, a, i) => f(b, a, i), b));\n/**\n * Reduces an array from the right.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)\n * console.log(result) // 6\n * ```\n *\n * @category folding\n * @since 2.0.0\n */\nexport const reduceRight = /*#__PURE__*/dual(3, (self, b, f) => fromIterable(self).reduceRight((b, a, i) => f(b, a, i), b));\n/**\n * Lifts a predicate into an array.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const isEven = (n: number) => n % 2 === 0\n * const to = Array.liftPredicate(isEven)\n * console.log(to(1)) // []\n * console.log(to(2)) // [2]\n * ```\n *\n * @category lifting\n * @since 2.0.0\n */\nexport const liftPredicate = predicate => b => predicate(b) ? [b] : [];\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport const liftOption = f => (...a) => fromOption(f(...a));\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport const fromNullable = a => a == null ? empty() : [a];\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport const liftNullable = f => (...a) => fromNullable(f(...a));\n/**\n * Maps over an array and flattens the result, removing null and undefined values.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.flatMapNullable([1, 2, 3], n => (n % 2 === 0 ? null : n))\n * console.log(result) // [1, 3]\n *\n * // Explanation:\n * // The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers\n * // and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened\n * // to remove null values, resulting in [1, 3].\n * ```\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMapNullable = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => fromNullable(f(a))));\n/**\n * Lifts a function that returns an `Either` into a function that returns an array.\n * If the `Either` is a left, it returns an empty array.\n * If the `Either` is a right, it returns an array with the right value.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Either } from \"effect\"\n *\n * const parseNumber = (s: string): Either.Either<number, Error> =>\n *   isNaN(Number(s)) ? Either.left(new Error(\"Not a number\")) : Either.right(Number(s))\n *\n * const liftedParseNumber = Array.liftEither(parseNumber)\n *\n * const result1 = liftedParseNumber(\"42\")\n * console.log(result1) // [42]\n *\n * const result2 = liftedParseNumber(\"not a number\")\n * console.log(result2) // []\n *\n * // Explanation:\n * // The function parseNumber is lifted to return an array.\n * // When parsing \"42\", it returns an Either.left with the number 42, resulting in [42].\n * // When parsing \"not a number\", it returns an Either.right with an error, resulting in an empty array [].\n * ```\n *\n * @category lifting\n * @since 2.0.0\n */\nexport const liftEither = f => (...a) => {\n  const e = f(...a);\n  return E.isLeft(e) ? [] : [e.right];\n};\n/**\n * Check if a predicate holds true for every `ReadonlyArray` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const every = /*#__PURE__*/dual(2, (self, refinement) => self.every(refinement));\n/**\n * Check if a predicate holds true for some `ReadonlyArray` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const some = /*#__PURE__*/dual(2, (self, predicate) => self.some(predicate));\n/**\n * Extends an array with a function that maps each subarray to a value.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.extend([1, 2, 3], as => as.length)\n * console.log(result) // [3, 2, 1]\n *\n * // Explanation:\n * // The function maps each subarray starting from each element to its length.\n * // The subarrays are: [1, 2, 3], [2, 3], [3].\n * // The lengths are: 3, 2, 1.\n * // Therefore, the result is [3, 2, 1].\n * ```\n *\n * @since 2.0.0\n */\nexport const extend = /*#__PURE__*/dual(2, (self, f) => self.map((_, i, as) => f(as.slice(i))));\n/**\n * Finds the minimum element in an array based on a comparator.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Order } from \"effect\"\n *\n * const result = Array.min([3, 1, 2], Order.number)\n * console.log(result) // 1\n * ```\n *\n * @since 2.0.0\n */\nexport const min = /*#__PURE__*/dual(2, (self, O) => self.reduce(Order.min(O)));\n/**\n * Finds the maximum element in an array based on a comparator.\n *\n * **Example**\n *\n * ```ts\n * import { Array, Order } from \"effect\"\n *\n * const result = Array.max([3, 1, 2], Order.number)\n * console.log(result) // 3\n * ```\n *\n * @since 2.0.0\n */\nexport const max = /*#__PURE__*/dual(2, (self, O) => self.reduce(Order.max(O)));\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const unfold = (b, f) => {\n  const out = [];\n  let next = b;\n  let o;\n  while (O.isSome(o = f(next))) {\n    const [a, b] = o.value;\n    out.push(a);\n    next = b;\n  }\n  return out;\n};\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category instances\n * @since 2.0.0\n */\nexport const getOrder = Order.array;\n/**\n * Creates an equivalence relation for arrays.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const eq = Array.getEquivalence<number>((a, b) => a === b)\n * console.log(eq([1, 2, 3], [1, 2, 3])) // true\n * ```\n *\n * @category instances\n * @since 2.0.0\n */\nexport const getEquivalence = Equivalence.array;\n/**\n * Performs a side-effect for each element of the `Iterable`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * Array.forEach([1, 2, 3], n => console.log(n)) // 1, 2, 3\n * ```\n *\n * @since 2.0.0\n */\nexport const forEach = /*#__PURE__*/dual(2, (self, f) => fromIterable(self).forEach((a, i) => f(a, i)));\n/**\n * Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\n * preserving the order of the first occurrence of each element.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const dedupeWith = /*#__PURE__*/dual(2, (self, isEquivalent) => {\n  const input = fromIterable(self);\n  if (isNonEmptyReadonlyArray(input)) {\n    const out = [headNonEmpty(input)];\n    const rest = tailNonEmpty(input);\n    for (const r of rest) {\n      if (out.every(a => !isEquivalent(r, a))) {\n        out.push(r);\n      }\n    }\n    return out;\n  }\n  return [];\n});\n/**\n * Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.\n * The equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.\n *\n * @since 2.0.0\n */\nexport const dedupe = self => dedupeWith(self, Equal.equivalence());\n/**\n * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dedupeAdjacentWith([1, 1, 2, 2, 3, 3], (a, b) => a === b)\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const dedupeAdjacentWith = /*#__PURE__*/dual(2, (self, isEquivalent) => {\n  const out = [];\n  let lastA = O.none();\n  for (const a of self) {\n    if (O.isNone(lastA) || !isEquivalent(a, lastA.value)) {\n      out.push(a);\n      lastA = O.some(a);\n    }\n  }\n  return out;\n});\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.dedupeAdjacent([1, 1, 2, 2, 3, 3])\n * console.log(result) // [1, 2, 3]\n * ```\n *\n * @since 2.0.0\n */\nexport const dedupeAdjacent = /*#__PURE__*/dedupeAdjacentWith( /*#__PURE__*/Equal.equivalence());\n/**\n * Joins the elements together with \"sep\" in the middle.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const strings = [\"a\", \"b\", \"c\"]\n * const joined = Array.join(strings, \"-\")\n * console.log(joined) // \"a-b-c\"\n * ```\n *\n * @since 2.0.0\n * @category folding\n */\nexport const join = /*#__PURE__*/dual(2, (self, sep) => fromIterable(self).join(sep));\n/**\n * Statefully maps over the chunk, producing new elements of type `B`.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.mapAccum([1, 2, 3], 0, (acc, n) => [acc + n, acc + n])\n * console.log(result) // [6, [1, 3, 6]]\n * ```\n *\n * @since 2.0.0\n * @category folding\n */\nexport const mapAccum = /*#__PURE__*/dual(3, (self, s, f) => {\n  let i = 0;\n  let s1 = s;\n  const out = [];\n  for (const a of self) {\n    const r = f(s1, a, i);\n    s1 = r[0];\n    out.push(r[1]);\n    i++;\n  }\n  return [s1, out];\n});\n/**\n * Zips this chunk crosswise with the specified chunk using the specified combiner.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.cartesianWith([1, 2], [\"a\", \"b\"], (a, b) => `${a}-${b}`)\n * console.log(result) // [\"1-a\", \"1-b\", \"2-a\", \"2-b\"]\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const cartesianWith = /*#__PURE__*/dual(3, (self, that, f) => flatMap(self, a => map(that, b => f(a, b))));\n/**\n * Zips this chunk crosswise with the specified chunk.\n *\n * **Example**\n *\n * ```ts\n * import { Array } from \"effect\"\n *\n * const result = Array.cartesian([1, 2], [\"a\", \"b\"])\n * console.log(result) // [[1, \"a\"], [1, \"b\"], [2, \"a\"], [2, \"b\"]]\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const cartesian = /*#__PURE__*/dual(2, (self, that) => cartesianWith(self, that, (a, b) => [a, b]));\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n *\n * It can be used to simulate \"array comprehension\".\n * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const doResult = pipe(\n *   Array.Do,\n *   Array.bind(\"x\", () => [1, 3, 5]),\n *   Array.bind(\"y\", () => [2, 4, 6]),\n *   Array.filter(({ x, y }) => x < y), // condition\n *   Array.map(({ x, y }) => [x, y] as const) // transformation\n * )\n * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n *\n * // equivalent\n * const x = [1, 3, 5],\n *       y = [2, 4, 6],\n *       result = [];\n * for(let i = 0; i < x.length; i++) {\n *   for(let j = 0; j < y.length; j++) {\n *     const _x = x[i], _y = y[j];\n *     if(_x < _y) result.push([_x, _y] as const)\n *   }\n * }\n * ```\n *\n * @see {@link bindTo}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 3.2.0\n */\nexport const Do = /*#__PURE__*/of({});\n/**\n * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n *\n * It can be used to simulate \"array comprehension\".\n * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const doResult = pipe(\n *   Array.Do,\n *   Array.bind(\"x\", () => [1, 3, 5]),\n *   Array.bind(\"y\", () => [2, 4, 6]),\n *   Array.filter(({ x, y }) => x < y), // condition\n *   Array.map(({ x, y }) => [x, y] as const) // transformation\n * )\n * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n *\n * // equivalent\n * const x = [1, 3, 5],\n *       y = [2, 4, 6],\n *       result = [];\n * for(let i = 0; i < x.length; i++) {\n *   for(let j = 0; j < y.length; j++) {\n *     const _x = x[i], _y = y[j];\n *     if(_x < _y) result.push([_x, _y] as const)\n *   }\n * }\n * ```\n *\n * @see {@link bindTo}\n * @see {@link Do}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 3.2.0\n */\nexport const bind = /*#__PURE__*/doNotation.bind(map, flatMap);\n/**\n * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n *\n * It can be used to simulate \"array comprehension\".\n * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const doResult = pipe(\n *   Array.Do,\n *   Array.bind(\"x\", () => [1, 3, 5]),\n *   Array.bind(\"y\", () => [2, 4, 6]),\n *   Array.filter(({ x, y }) => x < y), // condition\n *   Array.map(({ x, y }) => [x, y] as const) // transformation\n * )\n * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n *\n * // equivalent\n * const x = [1, 3, 5],\n *       y = [2, 4, 6],\n *       result = [];\n * for(let i = 0; i < x.length; i++) {\n *   for(let j = 0; j < y.length; j++) {\n *     const _x = x[i], _y = y[j];\n *     if(_x < _y) result.push([_x, _y] as const)\n *   }\n * }\n * ```\n *\n * @see {@link bindTo}\n * @see {@link Do}\n * @see {@link let_ let}\n *\n * @category do notation\n * @since 3.2.0\n */\nexport const bindTo = /*#__PURE__*/doNotation.bindTo(map);\nconst let_ = /*#__PURE__*/doNotation.let_(map);\nexport {\n/**\n * The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n *\n * It can be used to simulate \"array comprehension\".\n * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n *\n * **Example**\n *\n * ```ts\n * import { Array, pipe } from \"effect\"\n *\n * const doResult = pipe(\n *   Array.Do,\n *   Array.bind(\"x\", () => [1, 3, 5]),\n *   Array.bind(\"y\", () => [2, 4, 6]),\n *   Array.filter(({ x, y }) => x < y), // condition\n *   Array.map(({ x, y }) => [x, y] as const) // transformation\n * )\n * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n *\n * // equivalent\n * const x = [1, 3, 5],\n *       y = [2, 4, 6],\n *       result = [];\n * for(let i = 0; i < x.length; i++) {\n *   for(let j = 0; j < y.length; j++) {\n *     const _x = x[i], _y = y[j];\n *     if(_x < _y) result.push([_x, _y] as const)\n *   }\n * }\n *\n * ```\n *\n * @see {@link bindTo}\n * @see {@link bind}\n * @see {@link Do}\n *\n * @category do notation\n * @since 3.2.0\n */\nlet_ as let };\n//# sourceMappingURL=Array.js.map","/**\n * @since 2.0.0\n */\n/** @internal */\nexport const isNonEmptyArray = self => self.length > 0;\n//# sourceMappingURL=array.js.map","/**\n * This module provides utility functions and type class instances for working with the `number` type in TypeScript.\n * It includes functions for basic arithmetic operations, as well as type class instances for\n * `Equivalence` and `Order`.\n *\n * @since 2.0.0\n */\nimport * as equivalence from \"./Equivalence.js\";\nimport { dual } from \"./Function.js\";\nimport * as option from \"./internal/option.js\";\nimport * as order from \"./Order.js\";\nimport * as predicate from \"./Predicate.js\";\n/**\n * Tests if a value is a `number`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isNumber } from \"effect/Number\"\n *\n * assert.deepStrictEqual(isNumber(2), true)\n * assert.deepStrictEqual(isNumber(\"2\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNumber = predicate.isNumber;\n/**\n * Provides an addition operation on `number`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { sum } from \"effect/Number\"\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const sum = /*#__PURE__*/dual(2, (self, that) => self + that);\n/**\n * Provides a multiplication operation on `number`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { multiply } from \"effect/Number\"\n *\n * assert.deepStrictEqual(multiply(2, 3), 6)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const multiply = /*#__PURE__*/dual(2, (self, that) => self * that);\n/**\n * Provides a subtraction operation on `number`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { subtract } from \"effect/Number\"\n *\n * assert.deepStrictEqual(subtract(2, 3), -1)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const subtract = /*#__PURE__*/dual(2, (self, that) => self - that);\n/**\n * Provides a division operation on `number`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Number, Option } from \"effect\"\n *\n * assert.deepStrictEqual(Number.divide(6, 3), Option.some(2))\n * assert.deepStrictEqual(Number.divide(6, 0), Option.none())\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const divide = /*#__PURE__*/dual(2, (self, that) => that === 0 ? option.none : option.some(self / that));\n/**\n * Provides a division operation on `number`s.\n *\n * Throws a `RangeError` if the divisor is `0`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { unsafeDivide } from \"effect/Number\"\n *\n * assert.deepStrictEqual(unsafeDivide(6, 3), 2)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const unsafeDivide = /*#__PURE__*/dual(2, (self, that) => self / that);\n/**\n * Returns the result of adding `1` to a given number.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { increment } from \"effect/Number\"\n *\n * assert.deepStrictEqual(increment(2), 3)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const increment = n => n + 1;\n/**\n * Decrements a number by `1`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { decrement } from \"effect/Number\"\n *\n * assert.deepStrictEqual(decrement(3), 2)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const decrement = n => n - 1;\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Equivalence = equivalence.number;\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Order = order.number;\n/**\n * Returns `true` if the first argument is less than the second, otherwise `false`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { lessThan } from \"effect/Number\"\n *\n * assert.deepStrictEqual(lessThan(2, 3), true)\n * assert.deepStrictEqual(lessThan(3, 3), false)\n * assert.deepStrictEqual(lessThan(4, 3), false)\n * ```\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const lessThan = /*#__PURE__*/order.lessThan(Order);\n/**\n * Returns a function that checks if a given `number` is less than or equal to the provided one.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { lessThanOrEqualTo } from \"effect/Number\"\n *\n * assert.deepStrictEqual(lessThanOrEqualTo(2, 3), true)\n * assert.deepStrictEqual(lessThanOrEqualTo(3, 3), true)\n * assert.deepStrictEqual(lessThanOrEqualTo(4, 3), false)\n * ```\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const lessThanOrEqualTo = /*#__PURE__*/order.lessThanOrEqualTo(Order);\n/**\n * Returns `true` if the first argument is greater than the second, otherwise `false`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { greaterThan } from \"effect/Number\"\n *\n * assert.deepStrictEqual(greaterThan(2, 3), false)\n * assert.deepStrictEqual(greaterThan(3, 3), false)\n * assert.deepStrictEqual(greaterThan(4, 3), true)\n * ```\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const greaterThan = /*#__PURE__*/order.greaterThan(Order);\n/**\n * Returns a function that checks if a given `number` is greater than or equal to the provided one.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { greaterThanOrEqualTo } from \"effect/Number\"\n *\n * assert.deepStrictEqual(greaterThanOrEqualTo(2, 3), false)\n * assert.deepStrictEqual(greaterThanOrEqualTo(3, 3), true)\n * assert.deepStrictEqual(greaterThanOrEqualTo(4, 3), true)\n * ```\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const greaterThanOrEqualTo = /*#__PURE__*/order.greaterThanOrEqualTo(Order);\n/**\n * Checks if a `number` is between a `minimum` and `maximum` value (inclusive).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Number } from \"effect\"\n *\n * const between = Number.between({ minimum: 0, maximum: 5 })\n *\n * assert.deepStrictEqual(between(3), true)\n * assert.deepStrictEqual(between(-1), false)\n * assert.deepStrictEqual(between(6), false)\n * ```\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const between = /*#__PURE__*/order.between(Order);\n/**\n * Restricts the given `number` to be within the range specified by the `minimum` and `maximum` values.\n *\n * - If the `number` is less than the `minimum` value, the function returns the `minimum` value.\n * - If the `number` is greater than the `maximum` value, the function returns the `maximum` value.\n * - Otherwise, it returns the original `number`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Number } from \"effect\"\n *\n * const clamp = Number.clamp({ minimum: 1, maximum: 5 })\n *\n * assert.equal(clamp(3), 3)\n * assert.equal(clamp(0), 1)\n * assert.equal(clamp(6), 5)\n * ```\n *\n * @since 2.0.0\n */\nexport const clamp = /*#__PURE__*/order.clamp(Order);\n/**\n * Returns the minimum between two `number`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { min } from \"effect/Number\"\n *\n * assert.deepStrictEqual(min(2, 3), 2)\n * ```\n *\n * @since 2.0.0\n */\nexport const min = /*#__PURE__*/order.min(Order);\n/**\n * Returns the maximum between two `number`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { max } from \"effect/Number\"\n *\n * assert.deepStrictEqual(max(2, 3), 3)\n * ```\n *\n * @since 2.0.0\n */\nexport const max = /*#__PURE__*/order.max(Order);\n/**\n * Determines the sign of a given `number`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { sign } from \"effect/Number\"\n *\n * assert.deepStrictEqual(sign(-5), -1)\n * assert.deepStrictEqual(sign(0), 0)\n * assert.deepStrictEqual(sign(5), 1)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const sign = n => Order(n, 0);\n/**\n * Takes an `Iterable` of `number`s and returns their sum as a single `number`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { sumAll } from \"effect/Number\"\n *\n * assert.deepStrictEqual(sumAll([2, 3, 4]), 9)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const sumAll = collection => {\n  let out = 0;\n  for (const n of collection) {\n    out += n;\n  }\n  return out;\n};\n/**\n * Takes an `Iterable` of `number`s and returns their multiplication as a single `number`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { multiplyAll } from \"effect/Number\"\n *\n * assert.deepStrictEqual(multiplyAll([2, 3, 4]), 24)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const multiplyAll = collection => {\n  let out = 1;\n  for (const n of collection) {\n    if (n === 0) {\n      return 0;\n    }\n    out *= n;\n  }\n  return out;\n};\n/**\n * Returns the remainder left over when one operand is divided by a second operand.\n *\n * It always takes the sign of the dividend.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { remainder } from \"effect/Number\"\n *\n * assert.deepStrictEqual(remainder(2, 2), 0)\n * assert.deepStrictEqual(remainder(3, 2), 1)\n * assert.deepStrictEqual(remainder(-4, 2), -0)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const remainder = /*#__PURE__*/dual(2, (self, divisor) => {\n  // https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\n  const selfDecCount = (self.toString().split(\".\")[1] || \"\").length;\n  const divisorDecCount = (divisor.toString().split(\".\")[1] || \"\").length;\n  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;\n  const selfInt = parseInt(self.toFixed(decCount).replace(\".\", \"\"));\n  const divisorInt = parseInt(divisor.toFixed(decCount).replace(\".\", \"\"));\n  return selfInt % divisorInt / Math.pow(10, decCount);\n});\n/**\n * Returns the next power of 2 from the given number.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { nextPow2 } from \"effect/Number\"\n *\n * assert.deepStrictEqual(nextPow2(5), 8)\n * assert.deepStrictEqual(nextPow2(17), 32)\n * ```\n *\n * @category math\n * @since 2.0.0\n */\nexport const nextPow2 = n => {\n  const nextPow = Math.ceil(Math.log(n) / Math.log(2));\n  return Math.max(Math.pow(2, nextPow), 2);\n};\n/**\n * Tries to parse a `number` from a `string` using the `Number()` function.\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const parse = s => {\n  if (s === \"NaN\") {\n    return option.some(NaN);\n  }\n  if (s === \"Infinity\") {\n    return option.some(Infinity);\n  }\n  if (s === \"-Infinity\") {\n    return option.some(-Infinity);\n  }\n  if (s.trim() === \"\") {\n    return option.none;\n  }\n  const n = Number(s);\n  return Number.isNaN(n) ? option.none : option.some(n);\n};\n/**\n * Returns the number rounded with the given precision.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { round } from \"effect/Number\"\n *\n * assert.deepStrictEqual(round(1.1234, 2), 1.12)\n * assert.deepStrictEqual(round(1.567, 2), 1.57)\n * ```\n *\n * @category math\n * @since 3.8.0\n */\nexport const round = /*#__PURE__*/dual(2, (self, precision) => {\n  const factor = Math.pow(10, precision);\n  return Math.round(self * factor) / factor;\n});\n//# sourceMappingURL=Number.js.map","import * as Equal from \"../Equal.js\";\nimport { dual } from \"../Function.js\";\nimport { globalValue } from \"../GlobalValue.js\";\nimport * as Hash from \"../Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport { EffectPrototype, effectVariance } from \"./effectable.js\";\nimport * as option from \"./option.js\";\n/** @internal */\nexport const TagTypeId = /*#__PURE__*/Symbol.for(\"effect/Context/Tag\");\n/** @internal */\nexport const ReferenceTypeId = /*#__PURE__*/Symbol.for(\"effect/Context/Reference\");\n/** @internal */\nconst STMSymbolKey = \"effect/STM\";\n/** @internal */\nexport const STMTypeId = /*#__PURE__*/Symbol.for(STMSymbolKey);\n/** @internal */\nexport const TagProto = {\n  ...EffectPrototype,\n  _op: \"Tag\",\n  [STMTypeId]: effectVariance,\n  [TagTypeId]: {\n    _Service: _ => _,\n    _Identifier: _ => _\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Tag\",\n      key: this.key,\n      stack: this.stack\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  of(self) {\n    return self;\n  },\n  context(self) {\n    return make(this, self);\n  }\n};\nexport const ReferenceProto = {\n  ...TagProto,\n  [ReferenceTypeId]: ReferenceTypeId\n};\n/** @internal */\nexport const makeGenericTag = key => {\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 2;\n  const creationError = new Error();\n  Error.stackTraceLimit = limit;\n  const tag = Object.create(TagProto);\n  Object.defineProperty(tag, \"stack\", {\n    get() {\n      return creationError.stack;\n    }\n  });\n  tag.key = key;\n  return tag;\n};\n/** @internal */\nexport const Tag = id => () => {\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 2;\n  const creationError = new Error();\n  Error.stackTraceLimit = limit;\n  function TagClass() {}\n  Object.setPrototypeOf(TagClass, TagProto);\n  TagClass.key = id;\n  Object.defineProperty(TagClass, \"stack\", {\n    get() {\n      return creationError.stack;\n    }\n  });\n  return TagClass;\n};\n/** @internal */\nexport const Reference = () => (id, options) => {\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 2;\n  const creationError = new Error();\n  Error.stackTraceLimit = limit;\n  function ReferenceClass() {}\n  Object.setPrototypeOf(ReferenceClass, ReferenceProto);\n  ReferenceClass.key = id;\n  ReferenceClass.defaultValue = options.defaultValue;\n  Object.defineProperty(ReferenceClass, \"stack\", {\n    get() {\n      return creationError.stack;\n    }\n  });\n  return ReferenceClass;\n};\n/** @internal */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/Context\");\n/** @internal */\nexport const ContextProto = {\n  [TypeId]: {\n    _Services: _ => _\n  },\n  [Equal.symbol](that) {\n    if (isContext(that)) {\n      if (this.unsafeMap.size === that.unsafeMap.size) {\n        for (const k of this.unsafeMap.keys()) {\n          if (!that.unsafeMap.has(k) || !Equal.equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  },\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.number(this.unsafeMap.size));\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Context\",\n      services: Array.from(this.unsafeMap).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n};\n/** @internal */\nexport const makeContext = unsafeMap => {\n  const context = Object.create(ContextProto);\n  context.unsafeMap = unsafeMap;\n  return context;\n};\nconst serviceNotFoundError = tag => {\n  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : \"\"}`);\n  if (tag.stack) {\n    const lines = tag.stack.split(\"\\n\");\n    if (lines.length > 2) {\n      const afterAt = lines[2].match(/at (.*)/);\n      if (afterAt) {\n        error.message = error.message + ` (defined at ${afterAt[1]})`;\n      }\n    }\n  }\n  if (error.stack) {\n    const lines = error.stack.split(\"\\n\");\n    lines.splice(1, 3);\n    error.stack = lines.join(\"\\n\");\n  }\n  return error;\n};\n/** @internal */\nexport const isContext = u => hasProperty(u, TypeId);\n/** @internal */\nexport const isTag = u => hasProperty(u, TagTypeId);\n/** @internal */\nexport const isReference = u => hasProperty(u, ReferenceTypeId);\nconst _empty = /*#__PURE__*/makeContext( /*#__PURE__*/new Map());\n/** @internal */\nexport const empty = () => _empty;\n/** @internal */\nexport const make = (tag, service) => makeContext(new Map([[tag.key, service]]));\n/** @internal */\nexport const add = /*#__PURE__*/dual(3, (self, tag, service) => {\n  const map = new Map(self.unsafeMap);\n  map.set(tag.key, service);\n  return makeContext(map);\n});\nconst defaultValueCache = /*#__PURE__*/globalValue(\"effect/Context/defaultValueCache\", () => new Map());\nconst getDefaultValue = tag => {\n  if (defaultValueCache.has(tag.key)) {\n    return defaultValueCache.get(tag.key);\n  }\n  const value = tag.defaultValue();\n  defaultValueCache.set(tag.key, value);\n  return value;\n};\n/** @internal */\nexport const unsafeGetReference = (self, tag) => {\n  return self.unsafeMap.has(tag.key) ? self.unsafeMap.get(tag.key) : getDefaultValue(tag);\n};\n/** @internal */\nexport const unsafeGet = /*#__PURE__*/dual(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag.key)) {\n    if (ReferenceTypeId in tag) return getDefaultValue(tag);\n    throw serviceNotFoundError(tag);\n  }\n  return self.unsafeMap.get(tag.key);\n});\n/** @internal */\nexport const get = unsafeGet;\n/** @internal */\nexport const getOrElse = /*#__PURE__*/dual(3, (self, tag, orElse) => {\n  if (!self.unsafeMap.has(tag.key)) {\n    return isReference(tag) ? getDefaultValue(tag) : orElse();\n  }\n  return self.unsafeMap.get(tag.key);\n});\n/** @internal */\nexport const getOption = /*#__PURE__*/dual(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag.key)) {\n    return isReference(tag) ? option.some(getDefaultValue(tag)) : option.none;\n  }\n  return option.some(self.unsafeMap.get(tag.key));\n});\n/** @internal */\nexport const merge = /*#__PURE__*/dual(2, (self, that) => {\n  const map = new Map(self.unsafeMap);\n  for (const [tag, s] of that.unsafeMap) {\n    map.set(tag, s);\n  }\n  return makeContext(map);\n});\n/** @internal */\nexport const mergeAll = (...ctxs) => {\n  const map = new Map();\n  for (const ctx of ctxs) {\n    for (const [tag, s] of ctx.unsafeMap) {\n      map.set(tag, s);\n    }\n  }\n  return makeContext(map);\n};\n/** @internal */\nexport const pick = (...tags) => self => {\n  const tagSet = new Set(tags.map(_ => _.key));\n  const newEnv = new Map();\n  for (const [tag, s] of self.unsafeMap.entries()) {\n    if (tagSet.has(tag)) {\n      newEnv.set(tag, s);\n    }\n  }\n  return makeContext(newEnv);\n};\n/** @internal */\nexport const omit = (...tags) => self => {\n  const newEnv = new Map(self.unsafeMap);\n  for (const tag of tags) {\n    newEnv.delete(tag.key);\n  }\n  return makeContext(newEnv);\n};\n//# sourceMappingURL=context.js.map","import * as internal from \"./internal/context.js\";\nconst TagTypeId = internal.TagTypeId;\nconst ReferenceTypeId = internal.ReferenceTypeId;\n/**\n * Creates a new `Tag` instance with an optional key parameter.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.GenericTag(\"PORT\").key === Context.GenericTag(\"PORT\").key, true)\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const GenericTag = internal.makeGenericTag;\nconst TypeId = internal.TypeId;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const unsafeMake = internal.makeContext;\n/**\n * Checks if the provided argument is a `Context`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isContext(Context.empty()), true)\n * ```\n *\n * @since 2.0.0\n * @category guards\n */\nexport const isContext = internal.isContext;\n/**\n * Checks if the provided argument is a `Tag`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isTag(Context.GenericTag(\"Tag\")), true)\n * ```\n *\n * @since 2.0.0\n * @category guards\n */\nexport const isTag = internal.isTag;\n/**\n * Checks if the provided argument is a `Reference`.\n *\n * @since 3.11.0\n * @category guards\n * @experimental\n */\nexport const isReference = internal.isReference;\n/**\n * Returns an empty `Context`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isContext(Context.empty()), true)\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = internal.empty;\n/**\n * Creates a new `Context` with a single service associated to the tag.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * Adds a service to a given `Context`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context, pipe } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const someContext = Context.make(Port, { PORT: 8080 })\n *\n * const Services = pipe(\n *   someContext,\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n * ```\n *\n * @since 2.0.0\n */\nexport const add = internal.add;\n/**\n * Get a service from the context that corresponds to the given tag.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = pipe(\n *   Context.make(Port, { PORT: 8080 }),\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n * ```\n *\n * @since 2.0.0\n * @category getters\n */\nexport const get = internal.get;\n/**\n * Get a service from the context that corresponds to the given tag, or\n * use the fallback value.\n *\n * @since 3.7.0\n * @category getters\n */\nexport const getOrElse = internal.getOrElse;\n/**\n * Get a service from the context that corresponds to the given tag.\n * This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.\n *\n * For a safer version see {@link getOption}.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })\n * assert.throws(() => Context.unsafeGet(Services, Timeout))\n * ```\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet = internal.unsafeGet;\n/**\n * Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not\n * found, the `Option` object will be `None`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context, Option } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\n * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n * ```\n *\n * @since 2.0.0\n * @category getters\n */\nexport const getOption = internal.getOption;\n/**\n * Merges two `Context`s, returning a new `Context` containing the services of both.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const firstContext = Context.make(Port, { PORT: 8080 })\n * const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n *\n * const Services = Context.merge(firstContext, secondContext)\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n * ```\n *\n * @since 2.0.0\n */\nexport const merge = internal.merge;\n/**\n * Merges any number of `Context`s, returning a new `Context` containing the services of all.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n * const Host = Context.GenericTag<{ HOST: string }>(\"Host\")\n *\n * const firstContext = Context.make(Port, { PORT: 8080 })\n * const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n * const thirdContext = Context.make(Host, { HOST: \"localhost\" })\n *\n * const Services = Context.mergeAll(firstContext, secondContext, thirdContext)\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n * assert.deepStrictEqual(Context.get(Services, Host), { HOST: \"localhost\" })\n * ```\n *\n * @since 3.12.0\n */\nexport const mergeAll = internal.mergeAll;\n/**\n * Returns a new `Context` that contains only the specified services.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Context, Option } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const someContext = pipe(\n *   Context.make(Port, { PORT: 8080 }),\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * const Services = pipe(someContext, Context.pick(Port))\n *\n * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\n * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n * ```\n *\n * @since 2.0.0\n */\nexport const pick = internal.pick;\n/**\n * @since 2.0.0\n */\nexport const omit = internal.omit;\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context, Layer } from \"effect\"\n *\n * class MyTag extends Context.Tag(\"MyTag\")<\n *  MyTag,\n *  { readonly myNum: number }\n * >() {\n *  static Live = Layer.succeed(this, { myNum: 108 })\n * }\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const Tag = internal.Tag;\n/**\n * Creates a context tag with a default value.\n *\n * **Details**\n *\n * `Context.Reference` allows you to create a tag that can hold a value. You can\n * provide a default value for the service, which will automatically be used\n * when the context is accessed, or override it with a custom implementation\n * when needed.\n *\n * @example\n * ```ts\n * // Title: Declaring a Tag with a default value\n * import * as assert from \"node:assert\"\n * import { Context, Effect } from \"effect\"\n *\n * class SpecialNumber extends Context.Reference<SpecialNumber>()(\n *   \"SpecialNumber\",\n *   { defaultValue: () => 2048 }\n * ) {}\n *\n * //      ┌─── Effect<void, never, never>\n * //      ▼\n * const program = Effect.gen(function* () {\n *   const specialNumber = yield* SpecialNumber\n *   console.log(`The special number is ${specialNumber}`)\n * })\n *\n * // No need to provide the SpecialNumber implementation\n * Effect.runPromise(program)\n * // Output: The special number is 2048\n * ```\n *\n * @example\n * ```ts\n * // Title: Overriding the default value\n * import { Context, Effect } from \"effect\"\n *\n * class SpecialNumber extends Context.Reference<SpecialNumber>()(\n *   \"SpecialNumber\",\n *   { defaultValue: () => 2048 }\n * ) {}\n *\n * const program = Effect.gen(function* () {\n *   const specialNumber = yield* SpecialNumber\n *   console.log(`The special number is ${specialNumber}`)\n * })\n *\n * Effect.runPromise(program.pipe(Effect.provideService(SpecialNumber, -1)))\n * // Output: The special number is -1\n * ```\n *\n * @since 3.11.0\n * @category constructors\n * @experimental\n */\nexport const Reference = internal.Reference;\n//# sourceMappingURL=Context.js.map","/**\n * @since 2.0.0\n */\nimport * as RA from \"./Array.js\";\nimport * as Equal from \"./Equal.js\";\nimport * as Equivalence from \"./Equivalence.js\";\nimport { dual, identity, pipe } from \"./Function.js\";\nimport * as Hash from \"./Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"./Inspectable.js\";\nimport * as O from \"./Option.js\";\nimport * as Order from \"./Order.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nimport { hasProperty } from \"./Predicate.js\";\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Chunk\");\nfunction copy(src, srcPos, dest, destPos, len) {\n  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {\n    dest[destPos + i - srcPos] = src[i];\n  }\n  return dest;\n}\nconst emptyArray = [];\n/**\n * Compares the two chunks of equal length using the specified function\n *\n * @category equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = isEquivalent => Equivalence.make((self, that) => self.length === that.length && toReadonlyArray(self).every((value, i) => isEquivalent(value, unsafeGet(that, i))));\nconst _equivalence = /*#__PURE__*/getEquivalence(Equal.equals);\nconst ChunkProto = {\n  [TypeId]: {\n    _A: _ => _\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"Chunk\",\n      values: toReadonlyArray(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  [Equal.symbol](that) {\n    return isChunk(that) && _equivalence(this, that);\n  },\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.array(toReadonlyArray(this)));\n  },\n  [Symbol.iterator]() {\n    switch (this.backing._tag) {\n      case \"IArray\":\n        {\n          return this.backing.array[Symbol.iterator]();\n        }\n      case \"IEmpty\":\n        {\n          return emptyArray[Symbol.iterator]();\n        }\n      default:\n        {\n          return toReadonlyArray(this)[Symbol.iterator]();\n        }\n    }\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst makeChunk = backing => {\n  const chunk = Object.create(ChunkProto);\n  chunk.backing = backing;\n  switch (backing._tag) {\n    case \"IEmpty\":\n      {\n        chunk.length = 0;\n        chunk.depth = 0;\n        chunk.left = chunk;\n        chunk.right = chunk;\n        break;\n      }\n    case \"IConcat\":\n      {\n        chunk.length = backing.left.length + backing.right.length;\n        chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);\n        chunk.left = backing.left;\n        chunk.right = backing.right;\n        break;\n      }\n    case \"IArray\":\n      {\n        chunk.length = backing.array.length;\n        chunk.depth = 0;\n        chunk.left = _empty;\n        chunk.right = _empty;\n        break;\n      }\n    case \"ISingleton\":\n      {\n        chunk.length = 1;\n        chunk.depth = 0;\n        chunk.left = _empty;\n        chunk.right = _empty;\n        break;\n      }\n    case \"ISlice\":\n      {\n        chunk.length = backing.length;\n        chunk.depth = backing.chunk.depth + 1;\n        chunk.left = _empty;\n        chunk.right = _empty;\n        break;\n      }\n  }\n  return chunk;\n};\n/**\n * Checks if `u` is a `Chunk<unknown>`\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const isChunk = u => hasProperty(u, TypeId);\nconst _empty = /*#__PURE__*/makeChunk({\n  _tag: \"IEmpty\"\n});\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const empty = () => _empty;\n/**\n * Builds a `NonEmptyChunk` from an non-empty collection of elements.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const make = (...as) => unsafeFromNonEmptyArray(as);\n/**\n * Builds a `NonEmptyChunk` from a single element.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const of = a => makeChunk({\n  _tag: \"ISingleton\",\n  a\n});\n/**\n * Creates a new `Chunk` from an iterable collection of values.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterable = self => isChunk(self) ? self : unsafeFromArray(RA.fromIterable(self));\nconst copyToArray = (self, array, initial) => {\n  switch (self.backing._tag) {\n    case \"IArray\":\n      {\n        copy(self.backing.array, 0, array, initial, self.length);\n        break;\n      }\n    case \"IConcat\":\n      {\n        copyToArray(self.left, array, initial);\n        copyToArray(self.right, array, initial + self.left.length);\n        break;\n      }\n    case \"ISingleton\":\n      {\n        array[initial] = self.backing.a;\n        break;\n      }\n    case \"ISlice\":\n      {\n        let i = 0;\n        let j = initial;\n        while (i < self.length) {\n          array[j] = unsafeGet(self, i);\n          i += 1;\n          j += 1;\n        }\n        break;\n      }\n  }\n};\nconst toArray_ = self => toReadonlyArray(self).slice();\n/**\n * Converts a `Chunk` into an `Array`. If the provided `Chunk` is non-empty\n * (`NonEmptyChunk`), the function will return a `NonEmptyArray`, ensuring the\n * non-empty property is preserved.\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toArray = toArray_;\nconst toReadonlyArray_ = self => {\n  switch (self.backing._tag) {\n    case \"IEmpty\":\n      {\n        return emptyArray;\n      }\n    case \"IArray\":\n      {\n        return self.backing.array;\n      }\n    default:\n      {\n        const arr = new Array(self.length);\n        copyToArray(self, arr, 0);\n        self.backing = {\n          _tag: \"IArray\",\n          array: arr\n        };\n        self.left = _empty;\n        self.right = _empty;\n        self.depth = 0;\n        return arr;\n      }\n  }\n};\n/**\n * Converts a `Chunk` into a `ReadonlyArray`. If the provided `Chunk` is\n * non-empty (`NonEmptyChunk`), the function will return a\n * `NonEmptyReadonlyArray`, ensuring the non-empty property is preserved.\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toReadonlyArray = toReadonlyArray_;\nconst reverseChunk = self => {\n  switch (self.backing._tag) {\n    case \"IEmpty\":\n    case \"ISingleton\":\n      return self;\n    case \"IArray\":\n      {\n        return makeChunk({\n          _tag: \"IArray\",\n          array: RA.reverse(self.backing.array)\n        });\n      }\n    case \"IConcat\":\n      {\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: reverse(self.backing.right),\n          right: reverse(self.backing.left)\n        });\n      }\n    case \"ISlice\":\n      return unsafeFromArray(RA.reverse(toReadonlyArray(self)));\n  }\n};\n/**\n * Reverses the order of elements in a `Chunk`.\n * Importantly, if the input chunk is a `NonEmptyChunk`, the reversed chunk will also be a `NonEmptyChunk`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Chunk } from \"effect\"\n *\n * const numbers = Chunk.make(1, 2, 3)\n * const reversedNumbers = Chunk.reverse(numbers)\n * assert.deepStrictEqual(reversedNumbers, Chunk.make(3, 2, 1))\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const reverse = reverseChunk;\n/**\n * This function provides a safe way to read a value at a particular index from a `Chunk`.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const get = /*#__PURE__*/dual(2, (self, index) => index < 0 || index >= self.length ? O.none() : O.some(unsafeGet(self, index)));\n/**\n * Wraps an array into a chunk without copying, unsafe on mutable arrays\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeFromArray = self => self.length === 0 ? empty() : self.length === 1 ? of(self[0]) : makeChunk({\n  _tag: \"IArray\",\n  array: self\n});\n/**\n * Wraps an array into a chunk without copying, unsafe on mutable arrays\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeFromNonEmptyArray = self => unsafeFromArray(self);\n/**\n * Gets an element unsafely, will throw on out of bounds\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet = /*#__PURE__*/dual(2, (self, index) => {\n  switch (self.backing._tag) {\n    case \"IEmpty\":\n      {\n        throw new Error(`Index out of bounds`);\n      }\n    case \"ISingleton\":\n      {\n        if (index !== 0) {\n          throw new Error(`Index out of bounds`);\n        }\n        return self.backing.a;\n      }\n    case \"IArray\":\n      {\n        if (index >= self.length || index < 0) {\n          throw new Error(`Index out of bounds`);\n        }\n        return self.backing.array[index];\n      }\n    case \"IConcat\":\n      {\n        return index < self.left.length ? unsafeGet(self.left, index) : unsafeGet(self.right, index - self.left.length);\n      }\n    case \"ISlice\":\n      {\n        return unsafeGet(self.backing.chunk, index + self.backing.offset);\n      }\n  }\n});\n/**\n * Appends the specified element to the end of the `Chunk`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const append = /*#__PURE__*/dual(2, (self, a) => appendAll(self, of(a)));\n/**\n * Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prepend = /*#__PURE__*/dual(2, (self, elem) => appendAll(of(elem), self));\n/**\n * Takes the first up to `n` elements from the chunk\n *\n * @since 2.0.0\n */\nexport const take = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return _empty;\n  } else if (n >= self.length) {\n    return self;\n  } else {\n    switch (self.backing._tag) {\n      case \"ISlice\":\n        {\n          return makeChunk({\n            _tag: \"ISlice\",\n            chunk: self.backing.chunk,\n            length: n,\n            offset: self.backing.offset\n          });\n        }\n      case \"IConcat\":\n        {\n          if (n > self.left.length) {\n            return makeChunk({\n              _tag: \"IConcat\",\n              left: self.left,\n              right: take(self.right, n - self.left.length)\n            });\n          }\n          return take(self.left, n);\n        }\n      default:\n        {\n          return makeChunk({\n            _tag: \"ISlice\",\n            chunk: self,\n            offset: 0,\n            length: n\n          });\n        }\n    }\n  }\n});\n/**\n * Drops the first up to `n` elements from the chunk\n *\n * @since 2.0.0\n */\nexport const drop = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return self;\n  } else if (n >= self.length) {\n    return _empty;\n  } else {\n    switch (self.backing._tag) {\n      case \"ISlice\":\n        {\n          return makeChunk({\n            _tag: \"ISlice\",\n            chunk: self.backing.chunk,\n            offset: self.backing.offset + n,\n            length: self.backing.length - n\n          });\n        }\n      case \"IConcat\":\n        {\n          if (n > self.left.length) {\n            return drop(self.right, n - self.left.length);\n          }\n          return makeChunk({\n            _tag: \"IConcat\",\n            left: drop(self.left, n),\n            right: self.right\n          });\n        }\n      default:\n        {\n          return makeChunk({\n            _tag: \"ISlice\",\n            chunk: self,\n            offset: n,\n            length: self.length - n\n          });\n        }\n    }\n  }\n});\n/**\n * Drops the last `n` elements.\n *\n * @since 2.0.0\n */\nexport const dropRight = /*#__PURE__*/dual(2, (self, n) => take(self, Math.max(0, self.length - n)));\n/**\n * Drops all elements so long as the predicate returns true.\n *\n * @since 2.0.0\n */\nexport const dropWhile = /*#__PURE__*/dual(2, (self, predicate) => {\n  const arr = toReadonlyArray(self);\n  const len = arr.length;\n  let i = 0;\n  while (i < len && predicate(arr[i])) {\n    i++;\n  }\n  return drop(self, i);\n});\n/**\n * Prepends the specified prefix chunk to the beginning of the specified chunk.\n * If either chunk is non-empty, the result is also a non-empty chunk.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Chunk } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray),\n *   [\"a\", \"b\", 1, 2]\n * )\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAll = /*#__PURE__*/dual(2, (self, that) => appendAll(that, self));\n/**\n * Concatenates two chunks, combining their elements.\n * If either chunk is non-empty, the result is also a non-empty chunk.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Chunk } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray),\n *   [1, 2, \"a\", \"b\"]\n * )\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendAll = /*#__PURE__*/dual(2, (self, that) => {\n  if (self.backing._tag === \"IEmpty\") {\n    return that;\n  }\n  if (that.backing._tag === \"IEmpty\") {\n    return self;\n  }\n  const diff = that.depth - self.depth;\n  if (Math.abs(diff) <= 1) {\n    return makeChunk({\n      _tag: \"IConcat\",\n      left: self,\n      right: that\n    });\n  } else if (diff < -1) {\n    if (self.left.depth >= self.right.depth) {\n      const nr = appendAll(self.right, that);\n      return makeChunk({\n        _tag: \"IConcat\",\n        left: self.left,\n        right: nr\n      });\n    } else {\n      const nrr = appendAll(self.right.right, that);\n      if (nrr.depth === self.depth - 3) {\n        const nr = makeChunk({\n          _tag: \"IConcat\",\n          left: self.right.left,\n          right: nrr\n        });\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: self.left,\n          right: nr\n        });\n      } else {\n        const nl = makeChunk({\n          _tag: \"IConcat\",\n          left: self.left,\n          right: self.right.left\n        });\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: nl,\n          right: nrr\n        });\n      }\n    }\n  } else {\n    if (that.right.depth >= that.left.depth) {\n      const nl = appendAll(self, that.left);\n      return makeChunk({\n        _tag: \"IConcat\",\n        left: nl,\n        right: that.right\n      });\n    } else {\n      const nll = appendAll(self, that.left.left);\n      if (nll.depth === that.depth - 3) {\n        const nl = makeChunk({\n          _tag: \"IConcat\",\n          left: nll,\n          right: that.left.right\n        });\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: nl,\n          right: that.right\n        });\n      } else {\n        const nr = makeChunk({\n          _tag: \"IConcat\",\n          left: that.left.right,\n          right: that.right\n        });\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: nll,\n          right: nr\n        });\n      }\n    }\n  }\n});\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterMap = /*#__PURE__*/dual(2, (self, f) => unsafeFromArray(RA.filterMap(self, f)));\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filter = /*#__PURE__*/dual(2, (self, predicate) => unsafeFromArray(RA.filter(self, predicate)));\n/**\n * Transforms all elements of the chunk for as long as the specified function returns some value\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterMapWhile = /*#__PURE__*/dual(2, (self, f) => unsafeFromArray(RA.filterMapWhile(self, f)));\n/**\n * Filter out optional values\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const compact = self => filterMap(self, identity);\n/**\n * Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  if (self.backing._tag === \"ISingleton\") {\n    return f(self.backing.a, 0);\n  }\n  let out = _empty;\n  let i = 0;\n  for (const k of self) {\n    out = appendAll(out, f(k, i++));\n  }\n  return out;\n});\n/**\n * Iterates over each element of a `Chunk` and applies a function to it.\n *\n * **Details**\n *\n * This function processes every element of the given `Chunk`, calling the\n * provided function `f` on each element. It does not return a new value;\n * instead, it is primarily used for side effects, such as logging or\n * accumulating data in an external variable.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const forEach = /*#__PURE__*/dual(2, (self, f) => toReadonlyArray(self).forEach(f));\n/**\n * Flattens a chunk of chunks into a single chunk by concatenating all chunks.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatten = /*#__PURE__*/flatMap(identity);\n/**\n * Groups elements in chunks of up to `n` elements.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const chunksOf = /*#__PURE__*/dual(2, (self, n) => {\n  const gr = [];\n  let current = [];\n  toReadonlyArray(self).forEach(a => {\n    current.push(a);\n    if (current.length >= n) {\n      gr.push(unsafeFromArray(current));\n      current = [];\n    }\n  });\n  if (current.length > 0) {\n    gr.push(unsafeFromArray(current));\n  }\n  return unsafeFromArray(gr);\n});\n/**\n * Creates a Chunk of unique values that are included in all given Chunks.\n *\n * The order and references of result values are determined by the Chunk.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const intersection = /*#__PURE__*/dual(2, (self, that) => unsafeFromArray(RA.intersection(toReadonlyArray(self), toReadonlyArray(that))));\n/**\n * Determines if the chunk is empty.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isEmpty = self => self.length === 0;\n/**\n * Determines if the chunk is not empty.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isNonEmpty = self => self.length > 0;\n/**\n * Returns the first element of this chunk if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const head = /*#__PURE__*/get(0);\n/**\n * Returns the first element of this chunk.\n *\n * It will throw an error if the chunk is empty.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeHead = self => unsafeGet(self, 0);\n/**\n * Returns the first element of this non empty chunk.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const headNonEmpty = unsafeHead;\n/**\n * Returns the last element of this chunk if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const last = self => get(self, self.length - 1);\n/**\n * Returns the last element of this chunk.\n *\n * It will throw an error if the chunk is empty.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeLast = self => unsafeGet(self, self.length - 1);\n/**\n * Returns the last element of this non empty chunk.\n *\n * @since 3.4.0\n * @category elements\n */\nexport const lastNonEmpty = unsafeLast;\n/**\n * Transforms the elements of a chunk using the specified mapping function.\n * If the input chunk is non-empty, the resulting chunk will also be non-empty.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Chunk } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   Chunk.map(Chunk.make(1, 2), (n) => n + 1),\n *   Chunk.make(2, 3)\n * )\n * ```\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map = /*#__PURE__*/dual(2, (self, f) => self.backing._tag === \"ISingleton\" ? of(f(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), RA.map((a, i) => f(a, i)))));\n/**\n * Statefully maps over the chunk, producing new elements of type `B`.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const mapAccum = /*#__PURE__*/dual(3, (self, s, f) => {\n  const [s1, as] = RA.mapAccum(self, s, f);\n  return [s1, unsafeFromArray(as)];\n});\n/**\n * Separate elements based on a predicate that also exposes the index of the element.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partition = /*#__PURE__*/dual(2, (self, predicate) => pipe(RA.partition(toReadonlyArray(self), predicate), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));\n/**\n * Partitions the elements of this chunk into two chunks using f.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partitionMap = /*#__PURE__*/dual(2, (self, f) => pipe(RA.partitionMap(toReadonlyArray(self), f), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));\n/**\n * Partitions the elements of this chunk into two chunks.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const separate = self => pipe(RA.separate(toReadonlyArray(self)), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]);\n/**\n * Retireves the size of the chunk\n *\n * @since 2.0.0\n * @category elements\n */\nexport const size = self => self.length;\n/**\n * Sort the elements of a Chunk in increasing order, creating a new Chunk.\n *\n * @since 2.0.0\n * @category sorting\n */\nexport const sort = /*#__PURE__*/dual(2, (self, O) => unsafeFromArray(RA.sort(toReadonlyArray(self), O)));\n/**\n * @since 2.0.0\n * @category sorting\n */\nexport const sortWith = /*#__PURE__*/dual(3, (self, f, order) => sort(self, Order.mapInput(order, f)));\n/**\n *  Returns two splits of this chunk at the specified index.\n *\n * @since 2.0.0\n * @category splitting\n */\nexport const splitAt = /*#__PURE__*/dual(2, (self, n) => [take(self, n), drop(self, n)]);\n/**\n * Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.\n * The value of `n` must be `>= 1`.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitNonEmptyAt = /*#__PURE__*/dual(2, (self, n) => {\n  const _n = Math.max(1, Math.floor(n));\n  return _n >= self.length ? [self, empty()] : [take(self, _n), drop(self, _n)];\n});\n/**\n * Splits this chunk into `n` equally sized chunks.\n *\n * @since 2.0.0\n * @category splitting\n */\nexport const split = /*#__PURE__*/dual(2, (self, n) => chunksOf(self, Math.ceil(self.length / Math.floor(n))));\n/**\n * Splits this chunk on the first element that matches this predicate.\n * Returns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitWhere = /*#__PURE__*/dual(2, (self, predicate) => {\n  let i = 0;\n  for (const a of toReadonlyArray(self)) {\n    if (predicate(a)) {\n      break;\n    } else {\n      i++;\n    }\n  }\n  return splitAt(self, i);\n});\n/**\n * Returns every elements after the first.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const tail = self => self.length > 0 ? O.some(drop(self, 1)) : O.none();\n/**\n * Returns every elements after the first.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const tailNonEmpty = self => drop(self, 1);\n/**\n * Takes the last `n` elements.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const takeRight = /*#__PURE__*/dual(2, (self, n) => drop(self, self.length - n));\n/**\n * Takes all elements so long as the predicate returns true.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const takeWhile = /*#__PURE__*/dual(2, (self, predicate) => {\n  const out = [];\n  for (const a of toReadonlyArray(self)) {\n    if (predicate(a)) {\n      out.push(a);\n    } else {\n      break;\n    }\n  }\n  return unsafeFromArray(out);\n});\n/**\n * Creates a Chunks of unique values, in order, from all given Chunks.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const union = /*#__PURE__*/dual(2, (self, that) => unsafeFromArray(RA.union(toReadonlyArray(self), toReadonlyArray(that))));\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const dedupe = self => unsafeFromArray(RA.dedupe(toReadonlyArray(self)));\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const dedupeAdjacent = self => unsafeFromArray(RA.dedupeAdjacent(self));\n/**\n * Takes a `Chunk` of pairs and return two corresponding `Chunk`s.\n *\n * Note: The function is reverse of `zip`.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const unzip = self => {\n  const [left, right] = RA.unzip(self);\n  return [unsafeFromArray(left), unsafeFromArray(right)];\n};\n/**\n * Zips this chunk pointwise with the specified chunk using the specified combiner.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipWith = /*#__PURE__*/dual(3, (self, that, f) => unsafeFromArray(RA.zipWith(self, that, f)));\n/**\n * Zips this chunk pointwise with the specified chunk.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zip = /*#__PURE__*/dual(2, (self, that) => zipWith(self, that, (a, b) => [a, b]));\n/**\n * Delete the element at the specified index, creating a new `Chunk`.\n *\n * @since 2.0.0\n */\nexport const remove = /*#__PURE__*/dual(2, (self, i) => unsafeFromArray(RA.remove(toReadonlyArray(self), i)));\n/**\n * @since 2.0.0\n */\nexport const modifyOption = /*#__PURE__*/dual(3, (self, i, f) => O.map(RA.modifyOption(toReadonlyArray(self), i, f), unsafeFromArray));\n/**\n * Apply a function to the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nexport const modify = /*#__PURE__*/dual(3, (self, i, f) => O.getOrElse(modifyOption(self, i, f), () => self));\n/**\n * Change the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nexport const replace = /*#__PURE__*/dual(3, (self, i, b) => modify(self, i, () => b));\n/**\n * @since 2.0.0\n */\nexport const replaceOption = /*#__PURE__*/dual(3, (self, i, b) => modifyOption(self, i, () => b));\n/**\n * Return a Chunk of length n with element i initialized with f(i).\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const makeBy = /*#__PURE__*/dual(2, (n, f) => fromIterable(RA.makeBy(n, f)));\n/**\n * Create a non empty `Chunk` containing a range of integers, including both endpoints.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const range = (start, end) => start <= end ? makeBy(end - start + 1, i => start + i) : of(start);\n// -------------------------------------------------------------------------------------\n// re-exports from ReadonlyArray\n// -------------------------------------------------------------------------------------\n/**\n * Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const contains = RA.contains;\n/**\n * Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const containsWith = RA.containsWith;\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst = RA.findFirst;\n/**\n * Return the first index for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirstIndex = RA.findFirstIndex;\n/**\n * Find the last element for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLast = RA.findLast;\n/**\n * Return the last index for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLastIndex = RA.findLastIndex;\n/**\n * Check if a predicate holds true for every `Chunk` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const every = /*#__PURE__*/dual(2, (self, refinement) => RA.fromIterable(self).every(refinement));\n/**\n * Check if a predicate holds true for some `Chunk` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const some = /*#__PURE__*/dual(2, (self, predicate) => RA.fromIterable(self).some(predicate));\n/**\n * Joins the elements together with \"sep\" in the middle.\n *\n * @category folding\n * @since 2.0.0\n */\nexport const join = RA.join;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport const reduce = RA.reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport const reduceRight = RA.reduceRight;\n/**\n * Creates a `Chunk` of values not included in the other given `Chunk` using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Chunk`.\n *\n * @since 3.2.0\n */\nexport const differenceWith = isEquivalent => {\n  return dual(2, (self, that) => unsafeFromArray(RA.differenceWith(isEquivalent)(that, self)));\n};\n/**\n * Creates a `Chunk` of values not included in the other given `Chunk`.\n * The order and references of result values are determined by the first `Chunk`.\n *\n * @since 3.2.0\n */\nexport const difference = /*#__PURE__*/dual(2, (self, that) => unsafeFromArray(RA.difference(that, self)));\n//# sourceMappingURL=Chunk.js.map","/**\n * @since 2.0.0\n */\nimport * as Equal from \"./Equal.js\";\nimport { dual } from \"./Function.js\";\nimport * as Hash from \"./Hash.js\";\nimport { NodeInspectSymbol } from \"./Inspectable.js\";\nimport * as Option from \"./Option.js\";\nimport * as order from \"./Order.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nimport { hasProperty, isBigInt, isNumber, isString } from \"./Predicate.js\";\nconst TypeId = /*#__PURE__*/Symbol.for(\"effect/Duration\");\nconst bigint0 = /*#__PURE__*/BigInt(0);\nconst bigint24 = /*#__PURE__*/BigInt(24);\nconst bigint60 = /*#__PURE__*/BigInt(60);\nconst bigint1e3 = /*#__PURE__*/BigInt(1_000);\nconst bigint1e6 = /*#__PURE__*/BigInt(1_000_000);\nconst bigint1e9 = /*#__PURE__*/BigInt(1_000_000_000);\nconst DURATION_REGEX = /^(-?\\d+(?:\\.\\d+)?)\\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;\n/**\n * @since 2.0.0\n */\nexport const decode = input => {\n  if (isDuration(input)) {\n    return input;\n  } else if (isNumber(input)) {\n    return millis(input);\n  } else if (isBigInt(input)) {\n    return nanos(input);\n  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {\n    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {\n      return zero;\n    }\n    if (input[0] === Infinity || input[1] === Infinity) {\n      return infinity;\n    }\n    return nanos(BigInt(Math.round(input[0] * 1_000_000_000)) + BigInt(Math.round(input[1])));\n  } else if (isString(input)) {\n    const match = DURATION_REGEX.exec(input);\n    if (match) {\n      const [_, valueStr, unit] = match;\n      const value = Number(valueStr);\n      switch (unit) {\n        case \"nano\":\n        case \"nanos\":\n          return nanos(BigInt(valueStr));\n        case \"micro\":\n        case \"micros\":\n          return micros(BigInt(valueStr));\n        case \"milli\":\n        case \"millis\":\n          return millis(value);\n        case \"second\":\n        case \"seconds\":\n          return seconds(value);\n        case \"minute\":\n        case \"minutes\":\n          return minutes(value);\n        case \"hour\":\n        case \"hours\":\n          return hours(value);\n        case \"day\":\n        case \"days\":\n          return days(value);\n        case \"week\":\n        case \"weeks\":\n          return weeks(value);\n      }\n    }\n  }\n  throw new Error(\"Invalid DurationInput\");\n};\n/**\n * @since 2.5.0\n */\nexport const decodeUnknown = /*#__PURE__*/Option.liftThrowable(decode);\nconst zeroValue = {\n  _tag: \"Millis\",\n  millis: 0\n};\nconst infinityValue = {\n  _tag: \"Infinity\"\n};\nconst DurationProto = {\n  [TypeId]: TypeId,\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.structure(this.value));\n  },\n  [Equal.symbol](that) {\n    return isDuration(that) && equals(this, that);\n  },\n  toString() {\n    return `Duration(${format(this)})`;\n  },\n  toJSON() {\n    switch (this.value._tag) {\n      case \"Millis\":\n        return {\n          _id: \"Duration\",\n          _tag: \"Millis\",\n          millis: this.value.millis\n        };\n      case \"Nanos\":\n        return {\n          _id: \"Duration\",\n          _tag: \"Nanos\",\n          hrtime: toHrTime(this)\n        };\n      case \"Infinity\":\n        return {\n          _id: \"Duration\",\n          _tag: \"Infinity\"\n        };\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst make = input => {\n  const duration = Object.create(DurationProto);\n  if (isNumber(input)) {\n    if (isNaN(input) || input <= 0) {\n      duration.value = zeroValue;\n    } else if (!Number.isFinite(input)) {\n      duration.value = infinityValue;\n    } else if (!Number.isInteger(input)) {\n      duration.value = {\n        _tag: \"Nanos\",\n        nanos: BigInt(Math.round(input * 1_000_000))\n      };\n    } else {\n      duration.value = {\n        _tag: \"Millis\",\n        millis: input\n      };\n    }\n  } else if (input <= bigint0) {\n    duration.value = zeroValue;\n  } else {\n    duration.value = {\n      _tag: \"Nanos\",\n      nanos: input\n    };\n  }\n  return duration;\n};\n/**\n * @since 2.0.0\n * @category guards\n */\nexport const isDuration = u => hasProperty(u, TypeId);\n/**\n * @since 2.0.0\n * @category guards\n */\nexport const isFinite = self => self.value._tag !== \"Infinity\";\n/**\n * @since 3.5.0\n * @category guards\n */\nexport const isZero = self => {\n  switch (self.value._tag) {\n    case \"Millis\":\n      {\n        return self.value.millis === 0;\n      }\n    case \"Nanos\":\n      {\n        return self.value.nanos === bigint0;\n      }\n    case \"Infinity\":\n      {\n        return false;\n      }\n  }\n};\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const zero = /*#__PURE__*/make(0);\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const infinity = /*#__PURE__*/make(Infinity);\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const nanos = nanos => make(nanos);\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const micros = micros => make(micros * bigint1e3);\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const millis = millis => make(millis);\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const seconds = seconds => make(seconds * 1000);\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const minutes = minutes => make(minutes * 60_000);\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const hours = hours => make(hours * 3_600_000);\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const days = days => make(days * 86_400_000);\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const weeks = weeks => make(weeks * 604_800_000);\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const toMillis = self => match(self, {\n  onMillis: millis => millis,\n  onNanos: nanos => Number(nanos) / 1_000_000\n});\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const toSeconds = self => match(self, {\n  onMillis: millis => millis / 1_000,\n  onNanos: nanos => Number(nanos) / 1_000_000_000\n});\n/**\n * @since 3.8.0\n * @category getters\n */\nexport const toMinutes = self => match(self, {\n  onMillis: millis => millis / 60_000,\n  onNanos: nanos => Number(nanos) / 60_000_000_000\n});\n/**\n * @since 3.8.0\n * @category getters\n */\nexport const toHours = self => match(self, {\n  onMillis: millis => millis / 3_600_000,\n  onNanos: nanos => Number(nanos) / 3_600_000_000_000\n});\n/**\n * @since 3.8.0\n * @category getters\n */\nexport const toDays = self => match(self, {\n  onMillis: millis => millis / 86_400_000,\n  onNanos: nanos => Number(nanos) / 86_400_000_000_000\n});\n/**\n * @since 3.8.0\n * @category getters\n */\nexport const toWeeks = self => match(self, {\n  onMillis: millis => millis / 604_800_000,\n  onNanos: nanos => Number(nanos) / 604_800_000_000_000\n});\n/**\n * Get the duration in nanoseconds as a bigint.\n *\n * If the duration is infinite, returns `Option.none()`\n *\n * @since 2.0.0\n * @category getters\n */\nexport const toNanos = self => {\n  const _self = decode(self);\n  switch (_self.value._tag) {\n    case \"Infinity\":\n      return Option.none();\n    case \"Nanos\":\n      return Option.some(_self.value.nanos);\n    case \"Millis\":\n      return Option.some(BigInt(Math.round(_self.value.millis * 1_000_000)));\n  }\n};\n/**\n * Get the duration in nanoseconds as a bigint.\n *\n * If the duration is infinite, it throws an error.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const unsafeToNanos = self => {\n  const _self = decode(self);\n  switch (_self.value._tag) {\n    case \"Infinity\":\n      throw new Error(\"Cannot convert infinite duration to nanos\");\n    case \"Nanos\":\n      return _self.value.nanos;\n    case \"Millis\":\n      return BigInt(Math.round(_self.value.millis * 1_000_000));\n  }\n};\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const toHrTime = self => {\n  const _self = decode(self);\n  switch (_self.value._tag) {\n    case \"Infinity\":\n      return [Infinity, 0];\n    case \"Nanos\":\n      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];\n    case \"Millis\":\n      return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1_000_000)];\n  }\n};\n/**\n * @since 2.0.0\n * @category pattern matching\n */\nexport const match = /*#__PURE__*/dual(2, (self, options) => {\n  const _self = decode(self);\n  switch (_self.value._tag) {\n    case \"Nanos\":\n      return options.onNanos(_self.value.nanos);\n    case \"Infinity\":\n      return options.onMillis(Infinity);\n    case \"Millis\":\n      return options.onMillis(_self.value.millis);\n  }\n});\n/**\n * @since 2.0.0\n * @category pattern matching\n */\nexport const matchWith = /*#__PURE__*/dual(3, (self, that, options) => {\n  const _self = decode(self);\n  const _that = decode(that);\n  if (_self.value._tag === \"Infinity\" || _that.value._tag === \"Infinity\") {\n    return options.onMillis(toMillis(_self), toMillis(_that));\n  } else if (_self.value._tag === \"Nanos\" || _that.value._tag === \"Nanos\") {\n    const selfNanos = _self.value._tag === \"Nanos\" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1_000_000));\n    const thatNanos = _that.value._tag === \"Nanos\" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1_000_000));\n    return options.onNanos(selfNanos, thatNanos);\n  }\n  return options.onMillis(_self.value.millis, _that.value.millis);\n});\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Order = /*#__PURE__*/order.make((self, that) => matchWith(self, that, {\n  onMillis: (self, that) => self < that ? -1 : self > that ? 1 : 0,\n  onNanos: (self, that) => self < that ? -1 : self > that ? 1 : 0\n}));\n/**\n * Checks if a `Duration` is between a `minimum` and `maximum` value.\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const between = /*#__PURE__*/order.between( /*#__PURE__*/order.mapInput(Order, decode));\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Equivalence = (self, that) => matchWith(self, that, {\n  onMillis: (self, that) => self === that,\n  onNanos: (self, that) => self === that\n});\nconst _min = /*#__PURE__*/order.min(Order);\n/**\n * @since 2.0.0\n */\nexport const min = /*#__PURE__*/dual(2, (self, that) => _min(decode(self), decode(that)));\nconst _max = /*#__PURE__*/order.max(Order);\n/**\n * @since 2.0.0\n * @category order\n */\nexport const max = /*#__PURE__*/dual(2, (self, that) => _max(decode(self), decode(that)));\nconst _clamp = /*#__PURE__*/order.clamp(Order);\n/**\n * @since 2.0.0\n * @category order\n */\nexport const clamp = /*#__PURE__*/dual(2, (self, options) => _clamp(decode(self), {\n  minimum: decode(options.minimum),\n  maximum: decode(options.maximum)\n}));\n/**\n * @since 2.4.19\n * @category math\n */\nexport const divide = /*#__PURE__*/dual(2, (self, by) => match(self, {\n  onMillis: millis => {\n    if (by === 0 || isNaN(by) || !Number.isFinite(by)) {\n      return Option.none();\n    }\n    return Option.some(make(millis / by));\n  },\n  onNanos: nanos => {\n    if (isNaN(by) || by <= 0 || !Number.isFinite(by)) {\n      return Option.none();\n    }\n    try {\n      return Option.some(make(nanos / BigInt(by)));\n    } catch (e) {\n      return Option.none();\n    }\n  }\n}));\n/**\n * @since 2.4.19\n * @category math\n */\nexport const unsafeDivide = /*#__PURE__*/dual(2, (self, by) => match(self, {\n  onMillis: millis => make(millis / by),\n  onNanos: nanos => {\n    if (isNaN(by) || by < 0 || Object.is(by, -0)) {\n      return zero;\n    } else if (Object.is(by, 0) || !Number.isFinite(by)) {\n      return infinity;\n    }\n    return make(nanos / BigInt(by));\n  }\n}));\n/**\n * @since 2.0.0\n * @category math\n */\nexport const times = /*#__PURE__*/dual(2, (self, times) => match(self, {\n  onMillis: millis => make(millis * times),\n  onNanos: nanos => make(nanos * BigInt(times))\n}));\n/**\n * @since 2.0.0\n * @category math\n */\nexport const subtract = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {\n  onMillis: (self, that) => make(self - that),\n  onNanos: (self, that) => make(self - that)\n}));\n/**\n * @since 2.0.0\n * @category math\n */\nexport const sum = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {\n  onMillis: (self, that) => make(self + that),\n  onNanos: (self, that) => make(self + that)\n}));\n/**\n * @since 2.0.0\n * @category predicates\n */\nexport const lessThan = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {\n  onMillis: (self, that) => self < that,\n  onNanos: (self, that) => self < that\n}));\n/**\n * @since 2.0.0\n * @category predicates\n */\nexport const lessThanOrEqualTo = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {\n  onMillis: (self, that) => self <= that,\n  onNanos: (self, that) => self <= that\n}));\n/**\n * @since 2.0.0\n * @category predicates\n */\nexport const greaterThan = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {\n  onMillis: (self, that) => self > that,\n  onNanos: (self, that) => self > that\n}));\n/**\n * @since 2.0.0\n * @category predicates\n */\nexport const greaterThanOrEqualTo = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {\n  onMillis: (self, that) => self >= that,\n  onNanos: (self, that) => self >= that\n}));\n/**\n * @since 2.0.0\n * @category predicates\n */\nexport const equals = /*#__PURE__*/dual(2, (self, that) => Equivalence(decode(self), decode(that)));\n/**\n * Converts a `Duration` to its parts.\n *\n * @since 3.8.0\n * @category conversions\n */\nexport const parts = self => {\n  const duration = decode(self);\n  if (duration.value._tag === \"Infinity\") {\n    return {\n      days: Infinity,\n      hours: Infinity,\n      minutes: Infinity,\n      seconds: Infinity,\n      millis: Infinity,\n      nanos: Infinity\n    };\n  }\n  const nanos = unsafeToNanos(duration);\n  const ms = nanos / bigint1e6;\n  const sec = ms / bigint1e3;\n  const min = sec / bigint60;\n  const hr = min / bigint60;\n  const days = hr / bigint24;\n  return {\n    days: Number(days),\n    hours: Number(hr % bigint24),\n    minutes: Number(min % bigint60),\n    seconds: Number(sec % bigint60),\n    millis: Number(ms % bigint1e3),\n    nanos: Number(nanos % bigint1e6)\n  };\n};\n/**\n * Converts a `Duration` to a human readable string.\n *\n * @since 2.0.0\n * @category conversions\n * @example\n * ```ts\n * import { Duration } from \"effect\"\n *\n * Duration.format(Duration.millis(1000)) // \"1s\"\n * Duration.format(Duration.millis(1001)) // \"1s 1ms\"\n * ```\n */\nexport const format = self => {\n  const duration = decode(self);\n  if (duration.value._tag === \"Infinity\") {\n    return \"Infinity\";\n  }\n  if (isZero(duration)) {\n    return \"0\";\n  }\n  const fragments = parts(duration);\n  const pieces = [];\n  if (fragments.days !== 0) {\n    pieces.push(`${fragments.days}d`);\n  }\n  if (fragments.hours !== 0) {\n    pieces.push(`${fragments.hours}h`);\n  }\n  if (fragments.minutes !== 0) {\n    pieces.push(`${fragments.minutes}m`);\n  }\n  if (fragments.seconds !== 0) {\n    pieces.push(`${fragments.seconds}s`);\n  }\n  if (fragments.millis !== 0) {\n    pieces.push(`${fragments.millis}ms`);\n  }\n  if (fragments.nanos !== 0) {\n    pieces.push(`${fragments.nanos}ns`);\n  }\n  return pieces.join(\" \");\n};\n/**\n * Formats a Duration into an ISO8601 duration string.\n *\n * Months are assumed to be 30 days and years are assumed to be 365 days.\n *\n * Milliseconds and nanoseconds are expressed as fractional seconds.\n *\n * @example\n * ```ts\n * import { Duration } from \"effect\"\n *\n * Duration.unsafeFormatIso(Duration.days(1)) // => \"P1D\"\n * Duration.unsafeFormatIso(Duration.minutes(90)) // => \"PT1H30M\"\n * Duration.unsafeFormatIso(Duration.millis(1500)) // => \"PT1.5S\"\n * ```\n *\n * @throws `RangeError` If the duration is not finite.\n *\n * @since 3.13.0\n * @category conversions\n */\nexport const unsafeFormatIso = self => {\n  const duration = decode(self);\n  if (!isFinite(duration)) {\n    throw new RangeError(\"Cannot format infinite duration\");\n  }\n  const fragments = [];\n  const {\n    days,\n    hours,\n    millis,\n    minutes,\n    nanos,\n    seconds\n  } = parts(duration);\n  let rest = days;\n  if (rest >= 365) {\n    const years = Math.floor(rest / 365);\n    rest %= 365;\n    fragments.push(`${years}Y`);\n  }\n  if (rest >= 30) {\n    const months = Math.floor(rest / 30);\n    rest %= 30;\n    fragments.push(`${months}M`);\n  }\n  if (rest >= 7) {\n    const weeks = Math.floor(rest / 7);\n    rest %= 7;\n    fragments.push(`${weeks}W`);\n  }\n  if (rest > 0) {\n    fragments.push(`${rest}D`);\n  }\n  if (hours !== 0 || minutes !== 0 || seconds !== 0 || millis !== 0 || nanos !== 0) {\n    fragments.push(\"T\");\n    if (hours !== 0) {\n      fragments.push(`${hours}H`);\n    }\n    if (minutes !== 0) {\n      fragments.push(`${minutes}M`);\n    }\n    if (seconds !== 0 || millis !== 0 || nanos !== 0) {\n      const total = BigInt(seconds) * bigint1e9 + BigInt(millis) * bigint1e6 + BigInt(nanos);\n      const str = (Number(total) / 1e9).toFixed(9).replace(/\\.?0+$/, \"\");\n      fragments.push(`${str}S`);\n    }\n  }\n  return `P${fragments.join(\"\") || \"T0S\"}`;\n};\n/**\n * Formats a Duration into an ISO8601 duration string.\n *\n * Months are assumed to be 30 days and years are assumed to be 365 days.\n *\n * Returns `Option.none()` if the duration is infinite.\n *\n * @example\n * ```ts\n * import { Duration, Option } from \"effect\"\n *\n * Duration.formatIso(Duration.days(1)) // => Option.some(\"P1D\")\n * Duration.formatIso(Duration.minutes(90)) // => Option.some(\"PT1H30M\")\n * Duration.formatIso(Duration.millis(1500)) // => Option.some(\"PT1.5S\")\n * Duration.formatIso(Duration.infinity) // => Option.none()\n * ```\n *\n * @since 3.13.0\n * @category conversions\n */\nexport const formatIso = self => {\n  const duration = decode(self);\n  return isFinite(duration) ? Option.some(unsafeFormatIso(duration)) : Option.none();\n};\n/**\n * Parses an ISO8601 duration string into a `Duration`.\n *\n * Months are assumed to be 30 days and years are assumed to be 365 days.\n *\n * @example\n * ```ts\n * import { Duration, Option } from \"effect\"\n *\n * Duration.fromIso(\"P1D\") // => Option.some(Duration.days(1))\n * Duration.fromIso(\"PT1H\") // => Option.some(Duration.hours(1))\n * Duration.fromIso(\"PT1M\") // => Option.some(Duration.minutes(1))\n * Duration.fromIso(\"PT1.5S\") // => Option.some(Duration.seconds(1.5))\n * ```\n *\n * @since 3.13.0\n * @category conversions\n */\nexport const fromIso = iso => {\n  const result = DURATION_ISO_REGEX.exec(iso);\n  if (result == null) {\n    return Option.none();\n  }\n  const [years, months, weeks, days, hours, mins, secs] = result.slice(1, 8).map(_ => _ ? Number(_) : 0);\n  const value = years * 365 * 24 * 60 * 60 + months * 30 * 24 * 60 * 60 + weeks * 7 * 24 * 60 * 60 + days * 24 * 60 * 60 + hours * 60 * 60 + mins * 60 + secs;\n  return Option.some(seconds(value));\n};\nconst DURATION_ISO_REGEX = /^P(?!$)(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?(?:T(?!$)(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?)?$/;\n//# sourceMappingURL=Duration.js.map","/** @internal */\nexport const SIZE = 5;\n/** @internal */\nexport const BUCKET_SIZE = /*#__PURE__*/Math.pow(2, SIZE);\n/** @internal */\nexport const MASK = BUCKET_SIZE - 1;\n/** @internal */\nexport const MAX_INDEX_NODE = BUCKET_SIZE / 2;\n/** @internal */\nexport const MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n//# sourceMappingURL=config.js.map","import { MASK } from \"./config.js\";\n/**\n * Hamming weight.\n *\n * Taken from: http://jsperf.com/hamming-weight\n *\n * @internal\n */\nexport function popcount(x) {\n  x -= x >> 1 & 0x55555555;\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = x + (x >> 4) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n/** @internal */\nexport function hashFragment(shift, h) {\n  return h >>> shift & MASK;\n}\n/** @internal */\nexport function toBitmap(x) {\n  return 1 << x;\n}\n/** @internal */\nexport function fromBitmap(bitmap, bit) {\n  return popcount(bitmap & bit - 1);\n}\n//# sourceMappingURL=bitwise.js.map","export const make = (value, previous) => ({\n  value,\n  previous\n});\n//# sourceMappingURL=stack.js.map","/** @internal */\nexport function arrayUpdate(mutate, at, v, arr) {\n  let out = arr;\n  if (!mutate) {\n    const len = arr.length;\n    out = new Array(len);\n    for (let i = 0; i < len; ++i) out[i] = arr[i];\n  }\n  out[at] = v;\n  return out;\n}\n/** @internal */\nexport function arraySpliceOut(mutate, at, arr) {\n  const newLen = arr.length - 1;\n  let i = 0;\n  let g = 0;\n  let out = arr;\n  if (mutate) {\n    i = g = at;\n  } else {\n    out = new Array(newLen);\n    while (i < at) out[g++] = arr[i++];\n  }\n  ;\n  ++i;\n  while (i <= newLen) out[g++] = arr[i++];\n  if (mutate) {\n    out.length = newLen;\n  }\n  return out;\n}\n/** @internal */\nexport function arraySpliceIn(mutate, at, v, arr) {\n  const len = arr.length;\n  if (mutate) {\n    let i = len;\n    while (i >= at) arr[i--] = arr[i];\n    arr[at] = v;\n    return arr;\n  }\n  let i = 0,\n    g = 0;\n  const out = new Array(len + 1);\n  while (i < at) out[g++] = arr[i++];\n  out[at] = v;\n  while (i < len) out[++g] = arr[i++];\n  return out;\n}\n//# sourceMappingURL=array.js.map","import { equals } from \"../../Equal.js\";\nimport * as O from \"../../Option.js\";\nimport { isTagged } from \"../../Predicate.js\";\nimport * as Stack from \"../stack.js\";\nimport { arraySpliceIn, arraySpliceOut, arrayUpdate } from \"./array.js\";\nimport { fromBitmap, hashFragment, toBitmap } from \"./bitwise.js\";\nimport { MAX_INDEX_NODE, MIN_ARRAY_NODE, SIZE } from \"./config.js\";\n/** @internal */\nexport class EmptyNode {\n  _tag = \"EmptyNode\";\n  modify(edit, _shift, f, hash, key, size) {\n    const v = f(O.none());\n    if (O.isNone(v)) return new EmptyNode();\n    ++size.value;\n    return new LeafNode(edit, hash, key, v);\n  }\n}\n/** @internal */\nexport function isEmptyNode(a) {\n  return isTagged(a, \"EmptyNode\");\n}\n/** @internal */\nexport function isLeafNode(node) {\n  return isEmptyNode(node) || node._tag === \"LeafNode\" || node._tag === \"CollisionNode\";\n}\n/** @internal */\nexport function canEditNode(node, edit) {\n  return isEmptyNode(node) ? false : edit === node.edit;\n}\n/** @internal */\nexport class LeafNode {\n  edit;\n  hash;\n  key;\n  value;\n  _tag = \"LeafNode\";\n  constructor(edit, hash, key, value) {\n    this.edit = edit;\n    this.hash = hash;\n    this.key = key;\n    this.value = value;\n  }\n  modify(edit, shift, f, hash, key, size) {\n    if (equals(key, this.key)) {\n      const v = f(this.value);\n      if (v === this.value) return this;else if (O.isNone(v)) {\n        ;\n        --size.value;\n        return new EmptyNode();\n      }\n      if (canEditNode(this, edit)) {\n        this.value = v;\n        return this;\n      }\n      return new LeafNode(edit, hash, key, v);\n    }\n    const v = f(O.none());\n    if (O.isNone(v)) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));\n  }\n}\n/** @internal */\nexport class CollisionNode {\n  edit;\n  hash;\n  children;\n  _tag = \"CollisionNode\";\n  constructor(edit, hash, children) {\n    this.edit = edit;\n    this.hash = hash;\n    this.children = children;\n  }\n  modify(edit, shift, f, hash, key, size) {\n    if (hash === this.hash) {\n      const canEdit = canEditNode(this, edit);\n      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);\n      if (list === this.children) return this;\n      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0]; // collapse single element collision list\n    }\n    const v = f(O.none());\n    if (O.isNone(v)) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));\n  }\n  updateCollisionList(mutate, edit, hash, list, f, key, size) {\n    const len = list.length;\n    for (let i = 0; i < len; ++i) {\n      const child = list[i];\n      if (\"key\" in child && equals(key, child.key)) {\n        const value = child.value;\n        const newValue = f(value);\n        if (newValue === value) return list;\n        if (O.isNone(newValue)) {\n          ;\n          --size.value;\n          return arraySpliceOut(mutate, i, list);\n        }\n        return arrayUpdate(mutate, i, new LeafNode(edit, hash, key, newValue), list);\n      }\n    }\n    const newValue = f(O.none());\n    if (O.isNone(newValue)) return list;\n    ++size.value;\n    return arrayUpdate(mutate, len, new LeafNode(edit, hash, key, newValue), list);\n  }\n}\n/** @internal */\nexport class IndexedNode {\n  edit;\n  mask;\n  children;\n  _tag = \"IndexedNode\";\n  constructor(edit, mask, children) {\n    this.edit = edit;\n    this.mask = mask;\n    this.children = children;\n  }\n  modify(edit, shift, f, hash, key, size) {\n    const mask = this.mask;\n    const children = this.children;\n    const frag = hashFragment(shift, hash);\n    const bit = toBitmap(frag);\n    const indx = fromBitmap(mask, bit);\n    const exists = mask & bit;\n    const canEdit = canEditNode(this, edit);\n    if (!exists) {\n      const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash, key, size);\n      if (!_newChild) return this;\n      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));\n    }\n    const current = children[indx];\n    const child = current.modify(edit, shift + SIZE, f, hash, key, size);\n    if (current === child) return this;\n    let bitmap = mask;\n    let newChildren;\n    if (isEmptyNode(child)) {\n      // remove\n      bitmap &= ~bit;\n      if (!bitmap) return new EmptyNode();\n      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {\n        return children[indx ^ 1]; // collapse\n      }\n      newChildren = arraySpliceOut(canEdit, indx, children);\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, indx, child, children);\n    }\n    if (canEdit) {\n      this.mask = bitmap;\n      this.children = newChildren;\n      return this;\n    }\n    return new IndexedNode(edit, bitmap, newChildren);\n  }\n}\n/** @internal */\nexport class ArrayNode {\n  edit;\n  size;\n  children;\n  _tag = \"ArrayNode\";\n  constructor(edit, size, children) {\n    this.edit = edit;\n    this.size = size;\n    this.children = children;\n  }\n  modify(edit, shift, f, hash, key, size) {\n    let count = this.size;\n    const children = this.children;\n    const frag = hashFragment(shift, hash);\n    const child = children[frag];\n    const newChild = (child || new EmptyNode()).modify(edit, shift + SIZE, f, hash, key, size);\n    if (child === newChild) return this;\n    const canEdit = canEditNode(this, edit);\n    let newChildren;\n    if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n      // add\n      ;\n      ++count;\n      newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n      // remove\n      ;\n      --count;\n      if (count <= MIN_ARRAY_NODE) {\n        return pack(edit, count, frag, children);\n      }\n      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children);\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    }\n    if (canEdit) {\n      this.size = count;\n      this.children = newChildren;\n      return this;\n    }\n    return new ArrayNode(edit, count, newChildren);\n  }\n}\nfunction pack(edit, count, removed, elements) {\n  const children = new Array(count - 1);\n  let g = 0;\n  let bitmap = 0;\n  for (let i = 0, len = elements.length; i < len; ++i) {\n    if (i !== removed) {\n      const elem = elements[i];\n      if (elem && !isEmptyNode(elem)) {\n        children[g++] = elem;\n        bitmap |= 1 << i;\n      }\n    }\n  }\n  return new IndexedNode(edit, bitmap, children);\n}\nfunction expand(edit, frag, child, bitmap, subNodes) {\n  const arr = [];\n  let bit = bitmap;\n  let count = 0;\n  for (let i = 0; bit; ++i) {\n    if (bit & 1) arr[i] = subNodes[count++];\n    bit >>>= 1;\n  }\n  arr[frag] = child;\n  return new ArrayNode(edit, count + 1, arr);\n}\nfunction mergeLeavesInner(edit, shift, h1, n1, h2, n2) {\n  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);\n  const subH1 = hashFragment(shift, h1);\n  const subH2 = hashFragment(shift, h2);\n  if (subH1 === subH2) {\n    return child => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);\n  } else {\n    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];\n    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);\n  }\n}\nfunction mergeLeaves(edit, shift, h1, n1, h2, n2) {\n  let stack = undefined;\n  let currentShift = shift;\n  while (true) {\n    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);\n    if (typeof res === \"function\") {\n      stack = Stack.make(res, stack);\n      currentShift = currentShift + SIZE;\n    } else {\n      let final = res;\n      while (stack != null) {\n        final = stack.value(final);\n        stack = stack.previous;\n      }\n      return final;\n    }\n  }\n}\n//# sourceMappingURL=node.js.map","import * as Equal from \"../Equal.js\";\nimport * as Dual from \"../Function.js\";\nimport { identity, pipe } from \"../Function.js\";\nimport * as Hash from \"../Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport { fromBitmap, hashFragment, toBitmap } from \"./hashMap/bitwise.js\";\nimport { SIZE } from \"./hashMap/config.js\";\nimport * as Node from \"./hashMap/node.js\";\nconst HashMapSymbolKey = \"effect/HashMap\";\n/** @internal */\nexport const HashMapTypeId = /*#__PURE__*/Symbol.for(HashMapSymbolKey);\nconst HashMapProto = {\n  [HashMapTypeId]: HashMapTypeId,\n  [Symbol.iterator]() {\n    return new HashMapIterator(this, (k, v) => [k, v]);\n  },\n  [Hash.symbol]() {\n    let hash = Hash.hash(HashMapSymbolKey);\n    for (const item of this) {\n      hash ^= pipe(Hash.hash(item[0]), Hash.combine(Hash.hash(item[1])));\n    }\n    return Hash.cached(this, hash);\n  },\n  [Equal.symbol](that) {\n    if (isHashMap(that)) {\n      if (that._size !== this._size) {\n        return false;\n      }\n      for (const item of this) {\n        const elem = pipe(that, getHash(item[0], Hash.hash(item[0])));\n        if (Option.isNone(elem)) {\n          return false;\n        } else {\n          if (!Equal.equals(item[1], elem.value)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"HashMap\",\n      values: Array.from(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst makeImpl = (editable, edit, root, size) => {\n  const map = Object.create(HashMapProto);\n  map._editable = editable;\n  map._edit = edit;\n  map._root = root;\n  map._size = size;\n  return map;\n};\nclass HashMapIterator {\n  map;\n  f;\n  v;\n  constructor(map, f) {\n    this.map = map;\n    this.f = f;\n    this.v = visitLazy(this.map._root, this.f, undefined);\n  }\n  next() {\n    if (Option.isNone(this.v)) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    const v0 = this.v.value;\n    this.v = applyCont(v0.cont);\n    return {\n      done: false,\n      value: v0.value\n    };\n  }\n  [Symbol.iterator]() {\n    return new HashMapIterator(this.map, this.f);\n  }\n}\nconst applyCont = cont => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : Option.none();\nconst visitLazy = (node, f, cont = undefined) => {\n  switch (node._tag) {\n    case \"LeafNode\":\n      {\n        if (Option.isSome(node.value)) {\n          return Option.some({\n            value: f(node.key, node.value.value),\n            cont\n          });\n        }\n        return applyCont(cont);\n      }\n    case \"CollisionNode\":\n    case \"ArrayNode\":\n    case \"IndexedNode\":\n      {\n        const children = node.children;\n        return visitLazyChildren(children.length, children, 0, f, cont);\n      }\n    default:\n      {\n        return applyCont(cont);\n      }\n  }\n};\nconst visitLazyChildren = (len, children, i, f, cont) => {\n  while (i < len) {\n    const child = children[i++];\n    if (child && !Node.isEmptyNode(child)) {\n      return visitLazy(child, f, [len, children, i, f, cont]);\n    }\n  }\n  return applyCont(cont);\n};\nconst _empty = /*#__PURE__*/makeImpl(false, 0, /*#__PURE__*/new Node.EmptyNode(), 0);\n/** @internal */\nexport const empty = () => _empty;\n/** @internal */\nexport const make = (...entries) => fromIterable(entries);\n/** @internal */\nexport const fromIterable = entries => {\n  const map = beginMutation(empty());\n  for (const entry of entries) {\n    set(map, entry[0], entry[1]);\n  }\n  return endMutation(map);\n};\n/** @internal */\nexport const isHashMap = u => hasProperty(u, HashMapTypeId);\n/** @internal */\nexport const isEmpty = self => self && Node.isEmptyNode(self._root);\n/** @internal */\nexport const get = /*#__PURE__*/Dual.dual(2, (self, key) => getHash(self, key, Hash.hash(key)));\n/** @internal */\nexport const getHash = /*#__PURE__*/Dual.dual(3, (self, key, hash) => {\n  let node = self._root;\n  let shift = 0;\n  while (true) {\n    switch (node._tag) {\n      case \"LeafNode\":\n        {\n          return Equal.equals(key, node.key) ? node.value : Option.none();\n        }\n      case \"CollisionNode\":\n        {\n          if (hash === node.hash) {\n            const children = node.children;\n            for (let i = 0, len = children.length; i < len; ++i) {\n              const child = children[i];\n              if (\"key\" in child && Equal.equals(key, child.key)) {\n                return child.value;\n              }\n            }\n          }\n          return Option.none();\n        }\n      case \"IndexedNode\":\n        {\n          const frag = hashFragment(shift, hash);\n          const bit = toBitmap(frag);\n          if (node.mask & bit) {\n            node = node.children[fromBitmap(node.mask, bit)];\n            shift += SIZE;\n            break;\n          }\n          return Option.none();\n        }\n      case \"ArrayNode\":\n        {\n          node = node.children[hashFragment(shift, hash)];\n          if (node) {\n            shift += SIZE;\n            break;\n          }\n          return Option.none();\n        }\n      default:\n        return Option.none();\n    }\n  }\n});\n/** @internal */\nexport const unsafeGet = /*#__PURE__*/Dual.dual(2, (self, key) => {\n  const element = getHash(self, key, Hash.hash(key));\n  if (Option.isNone(element)) {\n    throw new Error(\"Expected map to contain key\");\n  }\n  return element.value;\n});\n/** @internal */\nexport const has = /*#__PURE__*/Dual.dual(2, (self, key) => Option.isSome(getHash(self, key, Hash.hash(key))));\n/** @internal */\nexport const hasHash = /*#__PURE__*/Dual.dual(3, (self, key, hash) => Option.isSome(getHash(self, key, hash)));\n/** @internal */\nexport const set = /*#__PURE__*/Dual.dual(3, (self, key, value) => modifyAt(self, key, () => Option.some(value)));\n/** @internal */\nexport const setTree = /*#__PURE__*/Dual.dual(3, (self, newRoot, newSize) => {\n  if (self._editable) {\n    ;\n    self._root = newRoot;\n    self._size = newSize;\n    return self;\n  }\n  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);\n});\n/** @internal */\nexport const keys = self => new HashMapIterator(self, key => key);\n/** @internal */\nexport const values = self => new HashMapIterator(self, (_, value) => value);\n/** @internal */\nexport const entries = self => new HashMapIterator(self, (key, value) => [key, value]);\n/** @internal */\nexport const size = self => self._size;\n/** @internal */\nexport const beginMutation = self => makeImpl(true, self._edit + 1, self._root, self._size);\n/** @internal */\nexport const endMutation = self => {\n  ;\n  self._editable = false;\n  return self;\n};\n/** @internal */\nexport const mutate = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const transient = beginMutation(self);\n  f(transient);\n  return endMutation(transient);\n});\n/** @internal */\nexport const modifyAt = /*#__PURE__*/Dual.dual(3, (self, key, f) => modifyHash(self, key, Hash.hash(key), f));\n/** @internal */\nexport const modifyHash = /*#__PURE__*/Dual.dual(4, (self, key, hash, f) => {\n  const size = {\n    value: self._size\n  };\n  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash, key, size);\n  return pipe(self, setTree(newRoot, size.value));\n});\n/** @internal */\nexport const modify = /*#__PURE__*/Dual.dual(3, (self, key, f) => modifyAt(self, key, Option.map(f)));\n/** @internal */\nexport const union = /*#__PURE__*/Dual.dual(2, (self, that) => {\n  const result = beginMutation(self);\n  forEach(that, (v, k) => set(result, k, v));\n  return endMutation(result);\n});\n/** @internal */\nexport const remove = /*#__PURE__*/Dual.dual(2, (self, key) => modifyAt(self, key, Option.none));\n/** @internal */\nexport const removeMany = /*#__PURE__*/Dual.dual(2, (self, keys) => mutate(self, map => {\n  for (const key of keys) {\n    remove(key)(map);\n  }\n}));\n/**\n * Maps over the entries of the `HashMap` using the specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map = /*#__PURE__*/Dual.dual(2, (self, f) => reduce(self, empty(), (map, value, key) => set(map, key, f(value, key))));\n/** @internal */\nexport const flatMap = /*#__PURE__*/Dual.dual(2, (self, f) => reduce(self, empty(), (zero, value, key) => mutate(zero, map => forEach(f(value, key), (value, key) => set(map, key, value)))));\n/** @internal */\nexport const forEach = /*#__PURE__*/Dual.dual(2, (self, f) => reduce(self, void 0, (_, value, key) => f(value, key)));\n/** @internal */\nexport const reduce = /*#__PURE__*/Dual.dual(3, (self, zero, f) => {\n  const root = self._root;\n  if (root._tag === \"LeafNode\") {\n    return Option.isSome(root.value) ? f(zero, root.value.value, root.key) : zero;\n  }\n  if (root._tag === \"EmptyNode\") {\n    return zero;\n  }\n  const toVisit = [root.children];\n  let children;\n  while (children = toVisit.pop()) {\n    for (let i = 0, len = children.length; i < len;) {\n      const child = children[i++];\n      if (child && !Node.isEmptyNode(child)) {\n        if (child._tag === \"LeafNode\") {\n          if (Option.isSome(child.value)) {\n            zero = f(zero, child.value.value, child.key);\n          }\n        } else {\n          toVisit.push(child.children);\n        }\n      }\n    }\n  }\n  return zero;\n});\n/** @internal */\nexport const filter = /*#__PURE__*/Dual.dual(2, (self, f) => mutate(empty(), map => {\n  for (const [k, a] of self) {\n    if (f(a, k)) {\n      set(map, k, a);\n    }\n  }\n}));\n/** @internal */\nexport const compact = self => filterMap(self, identity);\n/** @internal */\nexport const filterMap = /*#__PURE__*/Dual.dual(2, (self, f) => mutate(empty(), map => {\n  for (const [k, a] of self) {\n    const option = f(a, k);\n    if (Option.isSome(option)) {\n      set(map, k, option.value);\n    }\n  }\n}));\n/** @internal */\nexport const findFirst = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  for (const ka of self) {\n    if (predicate(ka[1], ka[0])) {\n      return Option.some(ka);\n    }\n  }\n  return Option.none();\n});\n/** @internal */\nexport const some = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  for (const ka of self) {\n    if (predicate(ka[1], ka[0])) {\n      return true;\n    }\n  }\n  return false;\n});\n//# sourceMappingURL=hashMap.js.map","import * as Equal from \"../Equal.js\";\nimport { dual } from \"../Function.js\";\nimport * as Hash from \"../Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport * as HM from \"./hashMap.js\";\nconst HashSetSymbolKey = \"effect/HashSet\";\n/** @internal */\nexport const HashSetTypeId = /*#__PURE__*/Symbol.for(HashSetSymbolKey);\nconst HashSetProto = {\n  [HashSetTypeId]: HashSetTypeId,\n  [Symbol.iterator]() {\n    return HM.keys(this._keyMap);\n  },\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.combine(Hash.hash(this._keyMap))(Hash.hash(HashSetSymbolKey)));\n  },\n  [Equal.symbol](that) {\n    if (isHashSet(that)) {\n      return HM.size(this._keyMap) === HM.size(that._keyMap) && Equal.equals(this._keyMap, that._keyMap);\n    }\n    return false;\n  },\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"HashSet\",\n      values: Array.from(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const makeImpl = keyMap => {\n  const set = Object.create(HashSetProto);\n  set._keyMap = keyMap;\n  return set;\n};\n/** @internal */\nexport const isHashSet = u => hasProperty(u, HashSetTypeId);\nconst _empty = /*#__PURE__*/makeImpl( /*#__PURE__*/HM.empty());\n/** @internal */\nexport const empty = () => _empty;\n/** @internal */\nexport const fromIterable = elements => {\n  const set = beginMutation(empty());\n  for (const value of elements) {\n    add(set, value);\n  }\n  return endMutation(set);\n};\n/** @internal */\nexport const make = (...elements) => {\n  const set = beginMutation(empty());\n  for (const value of elements) {\n    add(set, value);\n  }\n  return endMutation(set);\n};\n/** @internal */\nexport const has = /*#__PURE__*/dual(2, (self, value) => HM.has(self._keyMap, value));\n/** @internal */\nexport const some = /*#__PURE__*/dual(2, (self, f) => {\n  let found = false;\n  for (const value of self) {\n    found = f(value);\n    if (found) {\n      break;\n    }\n  }\n  return found;\n});\n/** @internal */\nexport const every = /*#__PURE__*/dual(2, (self, refinement) => !some(self, a => !refinement(a)));\n/** @internal */\nexport const isSubset = /*#__PURE__*/dual(2, (self, that) => every(self, value => has(that, value)));\n/** @internal */\nexport const values = self => HM.keys(self._keyMap);\n/** @internal */\nexport const size = self => HM.size(self._keyMap);\n/** @internal */\nexport const beginMutation = self => makeImpl(HM.beginMutation(self._keyMap));\n/** @internal */\nexport const endMutation = self => {\n  ;\n  self._keyMap._editable = false;\n  return self;\n};\n/** @internal */\nexport const mutate = /*#__PURE__*/dual(2, (self, f) => {\n  const transient = beginMutation(self);\n  f(transient);\n  return endMutation(transient);\n});\n/** @internal */\nexport const add = /*#__PURE__*/dual(2, (self, value) => self._keyMap._editable ? (HM.set(value, true)(self._keyMap), self) : makeImpl(HM.set(value, true)(self._keyMap)));\n/** @internal */\nexport const remove = /*#__PURE__*/dual(2, (self, value) => self._keyMap._editable ? (HM.remove(value)(self._keyMap), self) : makeImpl(HM.remove(value)(self._keyMap)));\n/** @internal */\nexport const difference = /*#__PURE__*/dual(2, (self, that) => mutate(self, set => {\n  for (const value of that) {\n    remove(set, value);\n  }\n}));\n/** @internal */\nexport const intersection = /*#__PURE__*/dual(2, (self, that) => mutate(empty(), set => {\n  for (const value of that) {\n    if (has(value)(self)) {\n      add(value)(set);\n    }\n  }\n}));\n/** @internal */\nexport const union = /*#__PURE__*/dual(2, (self, that) => mutate(empty(), set => {\n  forEach(self, value => add(set, value));\n  for (const value of that) {\n    add(set, value);\n  }\n}));\n/** @internal */\nexport const toggle = /*#__PURE__*/dual(2, (self, value) => has(self, value) ? remove(self, value) : add(self, value));\n/** @internal */\nexport const map = /*#__PURE__*/dual(2, (self, f) => mutate(empty(), set => {\n  forEach(self, a => {\n    const b = f(a);\n    if (!has(set, b)) {\n      add(set, b);\n    }\n  });\n}));\n/** @internal */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => mutate(empty(), set => {\n  forEach(self, a => {\n    for (const b of f(a)) {\n      if (!has(set, b)) {\n        add(set, b);\n      }\n    }\n  });\n}));\n/** @internal */\nexport const forEach = /*#__PURE__*/dual(2, (self, f) => HM.forEach(self._keyMap, (_, k) => f(k)));\n/** @internal */\nexport const reduce = /*#__PURE__*/dual(3, (self, zero, f) => HM.reduce(self._keyMap, zero, (z, _, a) => f(z, a)));\n/** @internal */\nexport const filter = /*#__PURE__*/dual(2, (self, f) => {\n  return mutate(empty(), set => {\n    const iterator = values(self);\n    let next;\n    while (!(next = iterator.next()).done) {\n      const value = next.value;\n      if (f(value)) {\n        add(set, value);\n      }\n    }\n  });\n});\n/** @internal */\nexport const partition = /*#__PURE__*/dual(2, (self, predicate) => {\n  const iterator = values(self);\n  let next;\n  const right = beginMutation(empty());\n  const left = beginMutation(empty());\n  while (!(next = iterator.next()).done) {\n    const value = next.value;\n    if (predicate(value)) {\n      add(right, value);\n    } else {\n      add(left, value);\n    }\n  }\n  return [endMutation(left), endMutation(right)];\n});\n//# sourceMappingURL=hashSet.js.map","/**\n * @since 2.0.0\n */\nimport * as HS from \"./internal/hashSet.js\";\nconst TypeId = HS.HashSetTypeId;\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isHashSet = HS.isHashSet;\n/**\n * Creates an empty `HashSet`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = HS.empty;\n/**\n * Creates a new `HashSet` from an iterable collection of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable = HS.fromIterable;\n/**\n * Construct a new `HashSet` from a variable number of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = HS.make;\n/**\n * Checks if the specified value exists in the `HashSet`.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const has = HS.has;\n/**\n * Check if a predicate holds true for some `HashSet` element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const some = HS.some;\n/**\n * Check if a predicate holds true for every `HashSet` element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const every = HS.every;\n/**\n * Returns `true` if and only if every element in the this `HashSet` is an\n * element of the second set,\n *\n * **NOTE**: the hash and equal of both sets must be the same.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isSubset = HS.isSubset;\n/**\n * Returns an `IterableIterator` of the values in the `HashSet`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const values = HS.values;\n/**\n * Returns an `Array` of the values within the `HashSet`.\n *\n * @since 3.13.0\n * @category getters\n */\nexport const toValues = self => Array.from(values(self));\n/**\n * Calculates the number of values in the `HashSet`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size = HS.size;\n/**\n * Marks the `HashSet` as mutable.\n *\n * @since 2.0.0\n */\nexport const beginMutation = HS.beginMutation;\n/**\n * Marks the `HashSet` as immutable.\n *\n * @since 2.0.0\n */\nexport const endMutation = HS.endMutation;\n/**\n * Mutates the `HashSet` within the context of the provided function.\n *\n * @since 2.0.0\n */\nexport const mutate = HS.mutate;\n/**\n * Adds a value to the `HashSet`.\n *\n * @since 2.0.0\n */\nexport const add = HS.add;\n/**\n * Removes a value from the `HashSet`.\n *\n * @since 2.0.0\n */\nexport const remove = HS.remove;\n/**\n * Computes the set difference between this `HashSet` and the specified\n * `Iterable<A>`.\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @since 2.0.0\n */\nexport const difference = HS.difference;\n/**\n * Returns a `HashSet` of values which are present in both this set and that\n * `Iterable<A>`.\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @since 2.0.0\n */\nexport const intersection = HS.intersection;\n/**\n * Computes the set union `(`self` + `that`)` between this `HashSet` and the\n * specified `Iterable<A>`.\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @since 2.0.0\n */\nexport const union = HS.union;\n/**\n * Checks if a value is present in the `HashSet`. If it is present, the value\n * will be removed from the `HashSet`, otherwise the value will be added to the\n * `HashSet`.\n *\n * @since 2.0.0\n */\nexport const toggle = HS.toggle;\n/**\n * Maps over the values of the `HashSet` using the specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map = HS.map;\n/**\n * Chains over the values of the `HashSet` using the specified function.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap = HS.flatMap;\n/**\n * Applies the specified function to the values of the `HashSet`.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const forEach = HS.forEach;\n/**\n * Reduces the specified state over the values of the `HashSet`.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduce = HS.reduce;\n/**\n * Filters values out of a `HashSet` using the specified predicate.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filter = HS.filter;\n/**\n * Partition the values of a `HashSet` using the specified predicate.\n *\n * If a value matches the predicate, it will be placed into the `HashSet` on the\n * right side of the resulting `Tuple`, otherwise the value will be placed into\n * the left side.\n *\n * @since 2.0.0\n * @category partitioning\n */\nexport const partition = HS.partition;\n//# sourceMappingURL=HashSet.js.map","import * as Equal from \"../Equal.js\";\nimport { dual, pipe } from \"../Function.js\";\nimport { globalValue } from \"../GlobalValue.js\";\nimport * as Hash from \"../Hash.js\";\nimport * as HashSet from \"../HashSet.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\";\nimport * as MutableRef from \"../MutableRef.js\";\nimport * as Option from \"../Option.js\";\nimport { hasProperty } from \"../Predicate.js\";\n/** @internal */\nconst FiberIdSymbolKey = \"effect/FiberId\";\n/** @internal */\nexport const FiberIdTypeId = /*#__PURE__*/Symbol.for(FiberIdSymbolKey);\n/** @internal */\nconst OP_NONE = \"None\";\n/** @internal */\nconst OP_RUNTIME = \"Runtime\";\n/** @internal */\nconst OP_COMPOSITE = \"Composite\";\nconst emptyHash = /*#__PURE__*/Hash.string(`${FiberIdSymbolKey}-${OP_NONE}`);\n/** @internal */\nclass None {\n  [FiberIdTypeId] = FiberIdTypeId;\n  _tag = OP_NONE;\n  id = -1;\n  startTimeMillis = -1;\n  [Hash.symbol]() {\n    return emptyHash;\n  }\n  [Equal.symbol](that) {\n    return isFiberId(that) && that._tag === OP_NONE;\n  }\n  toString() {\n    return format(this.toJSON());\n  }\n  toJSON() {\n    return {\n      _id: \"FiberId\",\n      _tag: this._tag\n    };\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n}\n/** @internal */\nclass Runtime {\n  id;\n  startTimeMillis;\n  [FiberIdTypeId] = FiberIdTypeId;\n  _tag = OP_RUNTIME;\n  constructor(id, startTimeMillis) {\n    this.id = id;\n    this.startTimeMillis = startTimeMillis;\n  }\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));\n  }\n  [Equal.symbol](that) {\n    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;\n  }\n  toString() {\n    return format(this.toJSON());\n  }\n  toJSON() {\n    return {\n      _id: \"FiberId\",\n      _tag: this._tag,\n      id: this.id,\n      startTimeMillis: this.startTimeMillis\n    };\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n}\n/** @internal */\nclass Composite {\n  left;\n  right;\n  [FiberIdTypeId] = FiberIdTypeId;\n  _tag = OP_COMPOSITE;\n  constructor(left, right) {\n    this.left = left;\n    this.right = right;\n  }\n  _hash;\n  [Hash.symbol]() {\n    return pipe(Hash.string(`${FiberIdSymbolKey}-${this._tag}`), Hash.combine(Hash.hash(this.left)), Hash.combine(Hash.hash(this.right)), Hash.cached(this));\n  }\n  [Equal.symbol](that) {\n    return isFiberId(that) && that._tag === OP_COMPOSITE && Equal.equals(this.left, that.left) && Equal.equals(this.right, that.right);\n  }\n  toString() {\n    return format(this.toJSON());\n  }\n  toJSON() {\n    return {\n      _id: \"FiberId\",\n      _tag: this._tag,\n      left: toJSON(this.left),\n      right: toJSON(this.right)\n    };\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n}\n/** @internal */\nexport const none = /*#__PURE__*/new None();\n/** @internal */\nexport const runtime = (id, startTimeMillis) => {\n  return new Runtime(id, startTimeMillis);\n};\n/** @internal */\nexport const composite = (left, right) => {\n  return new Composite(left, right);\n};\n/** @internal */\nexport const isFiberId = self => hasProperty(self, FiberIdTypeId);\n/** @internal */\nexport const isNone = self => {\n  return self._tag === OP_NONE || pipe(toSet(self), HashSet.every(id => isNone(id)));\n};\n/** @internal */\nexport const isRuntime = self => {\n  return self._tag === OP_RUNTIME;\n};\n/** @internal */\nexport const isComposite = self => {\n  return self._tag === OP_COMPOSITE;\n};\n/** @internal */\nexport const combine = /*#__PURE__*/dual(2, (self, that) => {\n  if (self._tag === OP_NONE) {\n    return that;\n  }\n  if (that._tag === OP_NONE) {\n    return self;\n  }\n  return new Composite(self, that);\n});\n/** @internal */\nexport const combineAll = fiberIds => {\n  return pipe(fiberIds, HashSet.reduce(none, (a, b) => combine(b)(a)));\n};\n/** @internal */\nexport const getOrElse = /*#__PURE__*/dual(2, (self, that) => isNone(self) ? that : self);\n/** @internal */\nexport const ids = self => {\n  switch (self._tag) {\n    case OP_NONE:\n      {\n        return HashSet.empty();\n      }\n    case OP_RUNTIME:\n      {\n        return HashSet.make(self.id);\n      }\n    case OP_COMPOSITE:\n      {\n        return pipe(ids(self.left), HashSet.union(ids(self.right)));\n      }\n  }\n};\nconst _fiberCounter = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/Fiber/Id/_fiberCounter\"), () => MutableRef.make(0));\n/** @internal */\nexport const make = (id, startTimeSeconds) => {\n  return new Runtime(id, startTimeSeconds);\n};\n/** @internal */\nexport const threadName = self => {\n  const identifiers = Array.from(ids(self)).map(n => `#${n}`).join(\",\");\n  return identifiers;\n};\n/** @internal */\nexport const toOption = self => {\n  const fiberIds = toSet(self);\n  if (HashSet.size(fiberIds) === 0) {\n    return Option.none();\n  }\n  let first = true;\n  let acc;\n  for (const fiberId of fiberIds) {\n    if (first) {\n      acc = fiberId;\n      first = false;\n    } else {\n      // @ts-expect-error\n      acc = pipe(acc, combine(fiberId));\n    }\n  }\n  // @ts-expect-error\n  return Option.some(acc);\n};\n/** @internal */\nexport const toSet = self => {\n  switch (self._tag) {\n    case OP_NONE:\n      {\n        return HashSet.empty();\n      }\n    case OP_RUNTIME:\n      {\n        return HashSet.make(self);\n      }\n    case OP_COMPOSITE:\n      {\n        return pipe(toSet(self.left), HashSet.union(toSet(self.right)));\n      }\n  }\n};\n/** @internal */\nexport const unsafeMake = () => {\n  const id = MutableRef.get(_fiberCounter);\n  pipe(_fiberCounter, MutableRef.set(id + 1));\n  return new Runtime(id, Date.now());\n};\n//# sourceMappingURL=fiberId.js.map","import * as internal from \"./internal/fiberId.js\";\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const FiberIdTypeId = internal.FiberIdTypeId;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const none = internal.none;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const runtime = internal.runtime;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const composite = internal.composite;\n/**\n * Returns `true` if the specified unknown value is a `FiberId`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isFiberId = internal.isFiberId;\n/**\n * Returns `true` if the `FiberId` is a `None`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isNone = internal.isNone;\n/**\n * Returns `true` if the `FiberId` is a `Runtime`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isRuntime = internal.isRuntime;\n/**\n * Returns `true` if the `FiberId` is a `Composite`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isComposite = internal.isComposite;\n/**\n * Combine two `FiberId`s.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const combine = internal.combine;\n/**\n * Combines a set of `FiberId`s into a single `FiberId`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const combineAll = internal.combineAll;\n/**\n * Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const getOrElse = internal.getOrElse;\n/**\n * Get the set of identifiers for this `FiberId`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const ids = internal.ids;\n/**\n * Creates a new `FiberId`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * Creates a string representing the name of the current thread of execution\n * represented by the specified `FiberId`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const threadName = internal.threadName;\n/**\n * Convert a `FiberId` into an `Option<FiberId>`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toOption = internal.toOption;\n/**\n * Convert a `FiberId` into a `HashSet<FiberId>`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toSet = internal.toSet;\n/**\n * Unsafely creates a new `FiberId`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeMake = internal.unsafeMake;\n//# sourceMappingURL=FiberId.js.map","/**\n * @since 2.0.0\n */\nimport * as HM from \"./internal/hashMap.js\";\nimport * as keySet_ from \"./internal/hashMap/keySet.js\";\nconst TypeId = HM.HashMapTypeId;\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isHashMap = HM.isHashMap;\n/**\n * Creates a new `HashMap`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = HM.empty;\n/**\n * Constructs a new `HashMap` from an array of key/value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = HM.make;\n/**\n * Creates a new `HashMap` from an iterable collection of key/value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable = HM.fromIterable;\n/**\n * Checks if the `HashMap` contains any entries.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isEmpty = HM.isEmpty;\n/**\n * Safely lookup the value for the specified key in the `HashMap` using the\n * internal hashing function.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const get = HM.get;\n/**\n * Lookup the value for the specified key in the `HashMap` using a custom hash.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const getHash = HM.getHash;\n/**\n * Unsafely lookup the value for the specified key in the `HashMap` using the\n * internal hashing function.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet = HM.unsafeGet;\n/**\n * Checks if the specified key has an entry in the `HashMap`.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const has = HM.has;\n/**\n * Checks if the specified key has an entry in the `HashMap` using a custom\n * hash.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const hasHash = HM.hasHash;\n/**\n * Sets the specified key to the specified value using the internal hashing\n * function.\n *\n * @since 2.0.0\n */\nexport const set = HM.set;\n/**\n * Returns an `IterableIterator` of the keys within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const keys = HM.keys;\n/**\n * Returns a `HashSet` of keys within the `HashMap`.\n *\n * @since 2.0.0\n * @category getter\n */\nexport const keySet = keySet_.keySet;\n/**\n * Returns an `IterableIterator` of the values within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const values = HM.values;\n/**\n * Returns an `Array` of the values within the `HashMap`.\n *\n * @since 3.13.0\n * @category getters\n */\nexport const toValues = self => Array.from(values(self));\n/**\n * Returns an `IterableIterator` of the entries within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const entries = HM.entries;\n/**\n * Returns an `Array<[K, V]>` of the entries within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const toEntries = self => Array.from(entries(self));\n/**\n * Returns the number of entries within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size = HM.size;\n/**\n * Marks the `HashMap` as mutable.\n *\n * @since 2.0.0\n */\nexport const beginMutation = HM.beginMutation;\n/**\n * Marks the `HashMap` as immutable.\n *\n * @since 2.0.0\n */\nexport const endMutation = HM.endMutation;\n/**\n * Mutates the `HashMap` within the context of the provided function.\n *\n * @since 2.0.0\n */\nexport const mutate = HM.mutate;\n/**\n * Set or remove the specified key in the `HashMap` using the specified\n * update function. The value of the specified key will be computed using the\n * provided hash.\n *\n * The update function will be invoked with the current value of the key if it\n * exists, or `None` if no such value exists.\n *\n * @since 2.0.0\n */\nexport const modifyAt = HM.modifyAt;\n/**\n * Alter the value of the specified key in the `HashMap` using the specified\n * update function. The value of the specified key will be computed using the\n * provided hash.\n *\n * The update function will be invoked with the current value of the key if it\n * exists, or `None` if no such value exists.\n *\n * This function will always either update or insert a value into the `HashMap`.\n *\n * @since 2.0.0\n */\nexport const modifyHash = HM.modifyHash;\n/**\n * Updates the value of the specified key within the `HashMap` if it exists.\n *\n * @since 2.0.0\n */\nexport const modify = HM.modify;\n/**\n * Performs a union of this `HashMap` and that `HashMap`.\n *\n * @since 2.0.0\n */\nexport const union = HM.union;\n/**\n * Remove the entry for the specified key in the `HashMap` using the internal\n * hashing function.\n *\n * @since 2.0.0\n */\nexport const remove = HM.remove;\n/**\n * Removes all entries in the `HashMap` which have the specified keys.\n *\n * @since 2.0.0\n */\nexport const removeMany = HM.removeMany;\n/**\n * Maps over the entries of the `HashMap` using the specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map = HM.map;\n/**\n * Chains over the entries of the `HashMap` using the specified function.\n *\n * **NOTE**: the hash and equal of both maps have to be the same.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap = HM.flatMap;\n/**\n * Applies the specified function to the entries of the `HashMap`.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const forEach = HM.forEach;\n/**\n * Reduces the specified state over the entries of the `HashMap`.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduce = HM.reduce;\n/**\n * Filters entries out of a `HashMap` using the specified predicate.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filter = HM.filter;\n/**\n * Filters out `None` values from a `HashMap` of `Options`s.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const compact = HM.compact;\n/**\n * Maps over the entries of the `HashMap` using the specified partial function\n * and filters out `None` values.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterMap = HM.filterMap;\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst = HM.findFirst;\n/**\n * Checks if any entry in a hashmap meets a specific condition.\n *\n * @since 3.13.0\n * @category elements\n */\nexport const some = HM.some;\n//# sourceMappingURL=HashMap.js.map","/**\n * A data type for immutable linked lists representing ordered collections of elements of type `A`.\n *\n * This data type is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.\n *\n * **Performance**\n *\n * - Time: `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list. This includes the index-based lookup of elements, `length`, `append` and `reverse`.\n * - Space: `List` implements structural sharing of the tail list. This means that many operations are either zero- or constant-memory cost.\n *\n * @since 2.0.0\n */\n/**\n * This file is ported from\n *\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n */\nimport * as Arr from \"./Array.js\";\nimport * as Chunk from \"./Chunk.js\";\nimport * as Either from \"./Either.js\";\nimport * as Equal from \"./Equal.js\";\nimport * as Equivalence from \"./Equivalence.js\";\nimport { dual, identity, unsafeCoerce } from \"./Function.js\";\nimport * as Hash from \"./Hash.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"./Inspectable.js\";\nimport * as Option from \"./Option.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nimport { hasProperty } from \"./Predicate.js\";\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/List\");\n/**\n * Converts the specified `List` to an `Array`.\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toArray = self => Arr.fromIterable(self);\n/**\n * @category equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = isEquivalent => Equivalence.mapInput(Arr.getEquivalence(isEquivalent), toArray);\nconst _equivalence = /*#__PURE__*/getEquivalence(Equal.equals);\nconst ConsProto = {\n  [TypeId]: TypeId,\n  _tag: \"Cons\",\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"List\",\n      _tag: \"Cons\",\n      values: toArray(this).map(toJSON)\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  [Equal.symbol](that) {\n    return isList(that) && this._tag === that._tag && _equivalence(this, that);\n  },\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.array(toArray(this)));\n  },\n  [Symbol.iterator]() {\n    let done = false;\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let self = this;\n    return {\n      next() {\n        if (done) {\n          return this.return();\n        }\n        if (self._tag === \"Nil\") {\n          done = true;\n          return this.return();\n        }\n        const value = self.head;\n        self = self.tail;\n        return {\n          done,\n          value\n        };\n      },\n      return(value) {\n        if (!done) {\n          done = true;\n        }\n        return {\n          done: true,\n          value\n        };\n      }\n    };\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst makeCons = (head, tail) => {\n  const cons = Object.create(ConsProto);\n  cons.head = head;\n  cons.tail = tail;\n  return cons;\n};\nconst NilHash = /*#__PURE__*/Hash.string(\"Nil\");\nconst NilProto = {\n  [TypeId]: TypeId,\n  _tag: \"Nil\",\n  toString() {\n    return format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"List\",\n      _tag: \"Nil\"\n    };\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  [Hash.symbol]() {\n    return NilHash;\n  },\n  [Equal.symbol](that) {\n    return isList(that) && this._tag === that._tag;\n  },\n  [Symbol.iterator]() {\n    return {\n      next() {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n    };\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst _Nil = /*#__PURE__*/Object.create(NilProto);\n/**\n * Returns `true` if the specified value is a `List`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isList = u => hasProperty(u, TypeId);\n/**\n * Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isNil = self => self._tag === \"Nil\";\n/**\n * Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isCons = self => self._tag === \"Cons\";\n/**\n * Returns the number of elements contained in the specified `List`\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size = self => {\n  let these = self;\n  let len = 0;\n  while (!isNil(these)) {\n    len += 1;\n    these = these.tail;\n  }\n  return len;\n};\n/**\n * Constructs a new empty `List<A>`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const nil = () => _Nil;\n/**\n * Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const cons = (head, tail) => makeCons(head, tail);\n/**\n * Constructs a new empty `List<A>`.\n *\n * Alias of {@link nil}.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = nil;\n/**\n * Constructs a new `List<A>` from the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const of = value => makeCons(value, _Nil);\n/**\n * Creates a new `List` from an iterable collection of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable = prefix => {\n  const iterator = prefix[Symbol.iterator]();\n  let next;\n  if ((next = iterator.next()) && !next.done) {\n    const result = makeCons(next.value, _Nil);\n    let curr = result;\n    while ((next = iterator.next()) && !next.done) {\n      const temp = makeCons(next.value, _Nil);\n      curr.tail = temp;\n      curr = temp;\n    }\n    return result;\n  } else {\n    return _Nil;\n  }\n};\n/**\n * Constructs a new `List<A>` from the specified values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = (...elements) => fromIterable(elements);\n/**\n * Appends the specified element to the end of the `List`, creating a new `Cons`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const append = /*#__PURE__*/dual(2, (self, element) => appendAll(self, of(element)));\n/**\n * Concatenates two lists, combining their elements.\n * If either list is non-empty, the result is also a non-empty list.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { List } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   List.make(1, 2).pipe(List.appendAll(List.make(\"a\", \"b\")), List.toArray),\n *   [1, 2, \"a\", \"b\"]\n * )\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendAll = /*#__PURE__*/dual(2, (self, that) => prependAll(that, self));\n/**\n * Prepends the specified element to the beginning of the list.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prepend = /*#__PURE__*/dual(2, (self, element) => cons(element, self));\n/**\n * Prepends the specified prefix list to the beginning of the specified list.\n * If either list is non-empty, the result is also a non-empty list.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { List } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   List.make(1, 2).pipe(List.prependAll(List.make(\"a\", \"b\")), List.toArray),\n *   [\"a\", \"b\", 1, 2]\n * )\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAll = /*#__PURE__*/dual(2, (self, prefix) => {\n  if (isNil(self)) {\n    return prefix;\n  } else if (isNil(prefix)) {\n    return self;\n  } else {\n    const result = makeCons(prefix.head, self);\n    let curr = result;\n    let that = prefix.tail;\n    while (!isNil(that)) {\n      const temp = makeCons(that.head, self);\n      curr.tail = temp;\n      curr = temp;\n      that = that.tail;\n    }\n    return result;\n  }\n});\n/**\n * Prepends the specified prefix list (in reverse order) to the beginning of the\n * specified list.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAllReversed = /*#__PURE__*/dual(2, (self, prefix) => {\n  let out = self;\n  let pres = prefix;\n  while (isCons(pres)) {\n    out = makeCons(pres.head, out);\n    pres = pres.tail;\n  }\n  return out;\n});\n/**\n * Drops the first `n` elements from the specified list.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const drop = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return self;\n  }\n  if (n >= size(self)) {\n    return _Nil;\n  }\n  let these = self;\n  let i = 0;\n  while (!isNil(these) && i < n) {\n    these = these.tail;\n    i += 1;\n  }\n  return these;\n});\n/**\n * Check if a predicate holds true for every `List` element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const every = /*#__PURE__*/dual(2, (self, refinement) => {\n  for (const a of self) {\n    if (!refinement(a)) {\n      return false;\n    }\n  }\n  return true;\n});\n/**\n * Check if a predicate holds true for some `List` element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const some = /*#__PURE__*/dual(2, (self, predicate) => {\n  let these = self;\n  while (!isNil(these)) {\n    if (predicate(these.head)) {\n      return true;\n    }\n    these = these.tail;\n  }\n  return false;\n});\n/**\n * Filters a list using the specified predicate.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const filter = /*#__PURE__*/dual(2, (self, predicate) => noneIn(self, predicate, false));\n// everything seen so far is not included\nconst noneIn = (self, predicate, isFlipped) => {\n  while (true) {\n    if (isNil(self)) {\n      return _Nil;\n    } else {\n      if (predicate(self.head) !== isFlipped) {\n        return allIn(self, self.tail, predicate, isFlipped);\n      } else {\n        self = self.tail;\n      }\n    }\n  }\n};\n// everything from 'start' is included, if everything from this point is in we can return the origin\n// start otherwise if we discover an element that is out we must create a new partial list.\nconst allIn = (start, remaining, predicate, isFlipped) => {\n  while (true) {\n    if (isNil(remaining)) {\n      return start;\n    } else {\n      if (predicate(remaining.head) !== isFlipped) {\n        remaining = remaining.tail;\n      } else {\n        return partialFill(start, remaining, predicate, isFlipped);\n      }\n    }\n  }\n};\n// we have seen elements that should be included then one that should be excluded, start building\nconst partialFill = (origStart, firstMiss, predicate, isFlipped) => {\n  const newHead = makeCons(unsafeHead(origStart), _Nil);\n  let toProcess = unsafeTail(origStart);\n  let currentLast = newHead;\n  // we know that all elements are :: until at least firstMiss.tail\n  while (!(toProcess === firstMiss)) {\n    const newElem = makeCons(unsafeHead(toProcess), _Nil);\n    currentLast.tail = newElem;\n    currentLast = unsafeCoerce(newElem);\n    toProcess = unsafeCoerce(toProcess.tail);\n  }\n  // at this point newHead points to a list which is a duplicate of all the 'in' elements up to the first miss.\n  // currentLast is the last element in that list.\n  // now we are going to try and share as much of the tail as we can, only moving elements across when we have to.\n  let next = firstMiss.tail;\n  let nextToCopy = unsafeCoerce(next); // the next element we would need to copy to our list if we cant share.\n  while (!isNil(next)) {\n    // generally recommended is next.isNonEmpty but this incurs an extra method call.\n    const head = unsafeHead(next);\n    if (predicate(head) !== isFlipped) {\n      next = next.tail;\n    } else {\n      // its not a match - do we have outstanding elements?\n      while (!(nextToCopy === next)) {\n        const newElem = makeCons(unsafeHead(nextToCopy), _Nil);\n        currentLast.tail = newElem;\n        currentLast = newElem;\n        nextToCopy = unsafeCoerce(nextToCopy.tail);\n      }\n      nextToCopy = unsafeCoerce(next.tail);\n      next = next.tail;\n    }\n  }\n  // we have remaining elements - they are unchanged attach them to the end\n  if (!isNil(nextToCopy)) {\n    currentLast.tail = nextToCopy;\n  }\n  return newHead;\n};\n/**\n * Filters and maps a list using the specified partial function. The resulting\n * list may be smaller than the input list due to the possibility of the partial\n * function not being defined for some elements.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const filterMap = /*#__PURE__*/dual(2, (self, f) => {\n  const bs = [];\n  for (const a of self) {\n    const oa = f(a);\n    if (Option.isSome(oa)) {\n      bs.push(oa.value);\n    }\n  }\n  return fromIterable(bs);\n});\n/**\n * Removes all `None` values from the specified list.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const compact = self => filterMap(self, identity);\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst = /*#__PURE__*/dual(2, (self, predicate) => {\n  let these = self;\n  while (!isNil(these)) {\n    if (predicate(these.head)) {\n      return Option.some(these.head);\n    }\n    these = these.tail;\n  }\n  return Option.none();\n});\n/**\n * Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  let rest = self;\n  let head = undefined;\n  let tail = undefined;\n  while (!isNil(rest)) {\n    let bs = f(rest.head);\n    while (!isNil(bs)) {\n      const next = makeCons(bs.head, _Nil);\n      if (tail === undefined) {\n        head = next;\n      } else {\n        tail.tail = next;\n      }\n      tail = next;\n      bs = bs.tail;\n    }\n    rest = rest.tail;\n  }\n  if (head === undefined) {\n    return _Nil;\n  }\n  return head;\n});\n/**\n * Applies the specified function to each element of the `List`.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const forEach = /*#__PURE__*/dual(2, (self, f) => {\n  let these = self;\n  while (!isNil(these)) {\n    f(these.head);\n    these = these.tail;\n  }\n});\n/**\n * Returns the first element of the specified list, or `None` if the list is\n * empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const head = self => isNil(self) ? Option.none() : Option.some(self.head);\n/**\n * Returns the last element of the specified list, or `None` if the list is\n * empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const last = self => isNil(self) ? Option.none() : Option.some(unsafeLast(self));\n/**\n * Applies the specified mapping function to each element of the list.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map = /*#__PURE__*/dual(2, (self, f) => {\n  if (isNil(self)) {\n    return self;\n  } else {\n    let i = 0;\n    const head = makeCons(f(self.head, i++), _Nil);\n    let nextHead = head;\n    let rest = self.tail;\n    while (!isNil(rest)) {\n      const next = makeCons(f(rest.head, i++), _Nil);\n      nextHead.tail = next;\n      nextHead = next;\n      rest = rest.tail;\n    }\n    return head;\n  }\n});\n/**\n * Partition a list into two lists, where the first list contains all elements\n * that did not satisfy the specified predicate, and the second list contains\n * all elements that did satisfy the specified predicate.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const partition = /*#__PURE__*/dual(2, (self, predicate) => {\n  const left = [];\n  const right = [];\n  for (const a of self) {\n    if (predicate(a)) {\n      right.push(a);\n    } else {\n      left.push(a);\n    }\n  }\n  return [fromIterable(left), fromIterable(right)];\n});\n/**\n * Partition a list into two lists, where the first list contains all elements\n * for which the specified function returned a `Left`, and the second list\n * contains all elements for which the specified function returned a `Right`.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const partitionMap = /*#__PURE__*/dual(2, (self, f) => {\n  const left = [];\n  const right = [];\n  for (const a of self) {\n    const e = f(a);\n    if (Either.isLeft(e)) {\n      left.push(e.left);\n    } else {\n      right.push(e.right);\n    }\n  }\n  return [fromIterable(left), fromIterable(right)];\n});\n/**\n * Folds over the elements of the list using the specified function, using the\n * specified initial value.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduce = /*#__PURE__*/dual(3, (self, zero, f) => {\n  let acc = zero;\n  let these = self;\n  while (!isNil(these)) {\n    acc = f(acc, these.head);\n    these = these.tail;\n  }\n  return acc;\n});\n/**\n * Folds over the elements of the list using the specified function, beginning\n * with the last element of the list, using the specified initial value.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduceRight = /*#__PURE__*/dual(3, (self, zero, f) => {\n  let acc = zero;\n  let these = reverse(self);\n  while (!isNil(these)) {\n    acc = f(acc, these.head);\n    these = these.tail;\n  }\n  return acc;\n});\n/**\n * Returns a new list with the elements of the specified list in reverse order.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const reverse = self => {\n  let result = empty();\n  let these = self;\n  while (!isNil(these)) {\n    result = prepend(result, these.head);\n    these = these.tail;\n  }\n  return result;\n};\n/**\n * Splits the specified list into two lists at the specified index.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const splitAt = /*#__PURE__*/dual(2, (self, n) => [take(self, n), drop(self, n)]);\n/**\n * Returns the tail of the specified list, or `None` if the list is empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const tail = self => isNil(self) ? Option.none() : Option.some(self.tail);\n/**\n * Takes the specified number of elements from the beginning of the specified\n * list.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const take = /*#__PURE__*/dual(2, (self, n) => {\n  if (n <= 0) {\n    return _Nil;\n  }\n  if (n >= size(self)) {\n    return self;\n  }\n  let these = make(unsafeHead(self));\n  let current = unsafeTail(self);\n  for (let i = 1; i < n; i++) {\n    these = makeCons(unsafeHead(current), these);\n    current = unsafeTail(current);\n  }\n  return reverse(these);\n});\n/**\n * Converts the specified `List` to a `Chunk`.\n *\n * @since 2.0.0\n * @category conversions\n */\nexport const toChunk = self => Chunk.fromIterable(self);\nconst getExpectedListToBeNonEmptyErrorMessage = \"Expected List to be non-empty\";\n/**\n * Unsafely returns the first element of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeHead = self => {\n  if (isNil(self)) {\n    throw new Error(getExpectedListToBeNonEmptyErrorMessage);\n  }\n  return self.head;\n};\n/**\n * Unsafely returns the last element of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeLast = self => {\n  if (isNil(self)) {\n    throw new Error(getExpectedListToBeNonEmptyErrorMessage);\n  }\n  let these = self;\n  let scout = self.tail;\n  while (!isNil(scout)) {\n    these = scout;\n    scout = scout.tail;\n  }\n  return these.head;\n};\n/**\n * Unsafely returns the tail of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeTail = self => {\n  if (isNil(self)) {\n    throw new Error(getExpectedListToBeNonEmptyErrorMessage);\n  }\n  return self.tail;\n};\n//# sourceMappingURL=List.js.map","import * as Equal from \"../Equal.js\";\nimport * as Hash from \"../Hash.js\";\nimport { StructuralPrototype } from \"./effectable.js\";\n/** @internal */\nexport const ArrayProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(Array.prototype), {\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.array(this));\n  },\n  [Equal.symbol](that) {\n    if (Array.isArray(that) && this.length === that.length) {\n      return this.every((v, i) => Equal.equals(v, that[i]));\n    } else {\n      return false;\n    }\n  }\n});\n/** @internal */\nexport const Structural = /*#__PURE__*/function () {\n  function Structural(args) {\n    if (args) {\n      Object.assign(this, args);\n    }\n  }\n  Structural.prototype = StructuralPrototype;\n  return Structural;\n}();\n/** @internal */\nexport const struct = as => Object.assign(Object.create(StructuralPrototype), as);\n//# sourceMappingURL=data.js.map","import * as Chunk from \"../../Chunk.js\";\nimport * as Equal from \"../../Equal.js\";\nimport * as Dual from \"../../Function.js\";\nimport { pipe } from \"../../Function.js\";\nimport * as Data from \"../data.js\";\n/** @internal */\nexport const ChunkPatchTypeId = /*#__PURE__*/Symbol.for(\"effect/DifferChunkPatch\");\nfunction variance(a) {\n  return a;\n}\nconst PatchProto = {\n  ...Data.Structural.prototype,\n  [ChunkPatchTypeId]: {\n    _Value: variance,\n    _Patch: variance\n  }\n};\nconst EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Empty\"\n});\nconst _empty = /*#__PURE__*/Object.create(EmptyProto);\n/**\n * @internal\n */\nexport const empty = () => _empty;\nconst AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"AndThen\"\n});\nconst makeAndThen = (first, second) => {\n  const o = Object.create(AndThenProto);\n  o.first = first;\n  o.second = second;\n  return o;\n};\nconst AppendProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Append\"\n});\nconst makeAppend = values => {\n  const o = Object.create(AppendProto);\n  o.values = values;\n  return o;\n};\nconst SliceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Slice\"\n});\nconst makeSlice = (from, until) => {\n  const o = Object.create(SliceProto);\n  o.from = from;\n  o.until = until;\n  return o;\n};\nconst UpdateProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Update\"\n});\nconst makeUpdate = (index, patch) => {\n  const o = Object.create(UpdateProto);\n  o.index = index;\n  o.patch = patch;\n  return o;\n};\n/** @internal */\nexport const diff = options => {\n  let i = 0;\n  let patch = empty();\n  while (i < options.oldValue.length && i < options.newValue.length) {\n    const oldElement = Chunk.unsafeGet(i)(options.oldValue);\n    const newElement = Chunk.unsafeGet(i)(options.newValue);\n    const valuePatch = options.differ.diff(oldElement, newElement);\n    if (!Equal.equals(valuePatch, options.differ.empty)) {\n      patch = pipe(patch, combine(makeUpdate(i, valuePatch)));\n    }\n    i = i + 1;\n  }\n  if (i < options.oldValue.length) {\n    patch = pipe(patch, combine(makeSlice(0, i)));\n  }\n  if (i < options.newValue.length) {\n    patch = pipe(patch, combine(makeAppend(Chunk.drop(i)(options.newValue))));\n  }\n  return patch;\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Dual.dual(2, (self, that) => makeAndThen(self, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Dual.dual(3, (self, oldValue, differ) => {\n  if (self._tag === \"Empty\") {\n    return oldValue;\n  }\n  let chunk = oldValue;\n  let patches = Chunk.of(self);\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail));\n          break;\n        }\n      case \"Append\":\n        {\n          chunk = Chunk.appendAll(head.values)(chunk);\n          patches = tail;\n          break;\n        }\n      case \"Slice\":\n        {\n          const array = Chunk.toReadonlyArray(chunk);\n          chunk = Chunk.unsafeFromArray(array.slice(head.from, head.until));\n          patches = tail;\n          break;\n        }\n      case \"Update\":\n        {\n          const array = Chunk.toReadonlyArray(chunk);\n          array[head.index] = differ.patch(head.patch, array[head.index]);\n          chunk = Chunk.unsafeFromArray(array);\n          patches = tail;\n          break;\n        }\n    }\n  }\n  return chunk;\n});\n//# sourceMappingURL=chunkPatch.js.map","import * as Chunk from \"../../Chunk.js\";\nimport * as Equal from \"../../Equal.js\";\nimport * as Dual from \"../../Function.js\";\nimport { makeContext } from \"../context.js\";\nimport { Structural } from \"../data.js\";\n/** @internal */\nexport const ContextPatchTypeId = /*#__PURE__*/Symbol.for(\"effect/DifferContextPatch\");\nfunction variance(a) {\n  return a;\n}\n/** @internal */\nconst PatchProto = {\n  ...Structural.prototype,\n  [ContextPatchTypeId]: {\n    _Value: variance,\n    _Patch: variance\n  }\n};\nconst EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Empty\"\n});\nconst _empty = /*#__PURE__*/Object.create(EmptyProto);\n/**\n * @internal\n */\nexport const empty = () => _empty;\nconst AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"AndThen\"\n});\nconst makeAndThen = (first, second) => {\n  const o = Object.create(AndThenProto);\n  o.first = first;\n  o.second = second;\n  return o;\n};\nconst AddServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"AddService\"\n});\nconst makeAddService = (key, service) => {\n  const o = Object.create(AddServiceProto);\n  o.key = key;\n  o.service = service;\n  return o;\n};\nconst RemoveServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"RemoveService\"\n});\nconst makeRemoveService = key => {\n  const o = Object.create(RemoveServiceProto);\n  o.key = key;\n  return o;\n};\nconst UpdateServiceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"UpdateService\"\n});\nconst makeUpdateService = (key, update) => {\n  const o = Object.create(UpdateServiceProto);\n  o.key = key;\n  o.update = update;\n  return o;\n};\n/** @internal */\nexport const diff = (oldValue, newValue) => {\n  const missingServices = new Map(oldValue.unsafeMap);\n  let patch = empty();\n  for (const [tag, newService] of newValue.unsafeMap.entries()) {\n    if (missingServices.has(tag)) {\n      const old = missingServices.get(tag);\n      missingServices.delete(tag);\n      if (!Equal.equals(old, newService)) {\n        patch = combine(makeUpdateService(tag, () => newService))(patch);\n      }\n    } else {\n      missingServices.delete(tag);\n      patch = combine(makeAddService(tag, newService))(patch);\n    }\n  }\n  for (const [tag] of missingServices.entries()) {\n    patch = combine(makeRemoveService(tag))(patch);\n  }\n  return patch;\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Dual.dual(2, (self, that) => makeAndThen(self, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Dual.dual(2, (self, context) => {\n  if (self._tag === \"Empty\") {\n    return context;\n  }\n  let wasServiceUpdated = false;\n  let patches = Chunk.of(self);\n  const updatedContext = new Map(context.unsafeMap);\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AddService\":\n        {\n          updatedContext.set(head.key, head.service);\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(Chunk.prepend(tail, head.second), head.first);\n          break;\n        }\n      case \"RemoveService\":\n        {\n          updatedContext.delete(head.key);\n          patches = tail;\n          break;\n        }\n      case \"UpdateService\":\n        {\n          updatedContext.set(head.key, head.update(updatedContext.get(head.key)));\n          wasServiceUpdated = true;\n          patches = tail;\n          break;\n        }\n    }\n  }\n  if (!wasServiceUpdated) {\n    return makeContext(updatedContext);\n  }\n  const map = new Map();\n  for (const [tag] of context.unsafeMap) {\n    if (updatedContext.has(tag)) {\n      map.set(tag, updatedContext.get(tag));\n      updatedContext.delete(tag);\n    }\n  }\n  for (const [tag, s] of updatedContext) {\n    map.set(tag, s);\n  }\n  return makeContext(map);\n});\n//# sourceMappingURL=contextPatch.js.map","import * as Chunk from \"../../Chunk.js\";\nimport * as Equal from \"../../Equal.js\";\nimport * as Dual from \"../../Function.js\";\nimport * as HashMap from \"../../HashMap.js\";\nimport { Structural } from \"../data.js\";\n/** @internal */\nexport const HashMapPatchTypeId = /*#__PURE__*/Symbol.for(\"effect/DifferHashMapPatch\");\nfunction variance(a) {\n  return a;\n}\n/** @internal */\nconst PatchProto = {\n  ...Structural.prototype,\n  [HashMapPatchTypeId]: {\n    _Value: variance,\n    _Key: variance,\n    _Patch: variance\n  }\n};\nconst EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Empty\"\n});\nconst _empty = /*#__PURE__*/Object.create(EmptyProto);\n/** @internal */\nexport const empty = () => _empty;\nconst AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"AndThen\"\n});\nconst makeAndThen = (first, second) => {\n  const o = Object.create(AndThenProto);\n  o.first = first;\n  o.second = second;\n  return o;\n};\nconst AddProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Add\"\n});\nconst makeAdd = (key, value) => {\n  const o = Object.create(AddProto);\n  o.key = key;\n  o.value = value;\n  return o;\n};\nconst RemoveProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Remove\"\n});\nconst makeRemove = key => {\n  const o = Object.create(RemoveProto);\n  o.key = key;\n  return o;\n};\nconst UpdateProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Update\"\n});\nconst makeUpdate = (key, patch) => {\n  const o = Object.create(UpdateProto);\n  o.key = key;\n  o.patch = patch;\n  return o;\n};\n/** @internal */\nexport const diff = options => {\n  const [removed, patch] = HashMap.reduce([options.oldValue, empty()], ([map, patch], newValue, key) => {\n    const option = HashMap.get(key)(map);\n    switch (option._tag) {\n      case \"Some\":\n        {\n          const valuePatch = options.differ.diff(option.value, newValue);\n          if (Equal.equals(valuePatch, options.differ.empty)) {\n            return [HashMap.remove(key)(map), patch];\n          }\n          return [HashMap.remove(key)(map), combine(makeUpdate(key, valuePatch))(patch)];\n        }\n      case \"None\":\n        {\n          return [map, combine(makeAdd(key, newValue))(patch)];\n        }\n    }\n  })(options.newValue);\n  return HashMap.reduce(patch, (patch, _, key) => combine(makeRemove(key))(patch))(removed);\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Dual.dual(2, (self, that) => makeAndThen(self, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Dual.dual(3, (self, oldValue, differ) => {\n  if (self._tag === \"Empty\") {\n    return oldValue;\n  }\n  let map = oldValue;\n  let patches = Chunk.of(self);\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail));\n          break;\n        }\n      case \"Add\":\n        {\n          map = HashMap.set(head.key, head.value)(map);\n          patches = tail;\n          break;\n        }\n      case \"Remove\":\n        {\n          map = HashMap.remove(head.key)(map);\n          patches = tail;\n          break;\n        }\n      case \"Update\":\n        {\n          const option = HashMap.get(head.key)(map);\n          if (option._tag === \"Some\") {\n            map = HashMap.set(head.key, differ.patch(head.patch, option.value))(map);\n          }\n          patches = tail;\n          break;\n        }\n    }\n  }\n  return map;\n});\n//# sourceMappingURL=hashMapPatch.js.map","import * as Chunk from \"../../Chunk.js\";\nimport * as Dual from \"../../Function.js\";\nimport * as HashSet from \"../../HashSet.js\";\nimport { Structural } from \"../data.js\";\n/** @internal */\nexport const HashSetPatchTypeId = /*#__PURE__*/Symbol.for(\"effect/DifferHashSetPatch\");\nfunction variance(a) {\n  return a;\n}\n/** @internal */\nconst PatchProto = {\n  ...Structural.prototype,\n  [HashSetPatchTypeId]: {\n    _Value: variance,\n    _Key: variance,\n    _Patch: variance\n  }\n};\nconst EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Empty\"\n});\nconst _empty = /*#__PURE__*/Object.create(EmptyProto);\n/** @internal */\nexport const empty = () => _empty;\nconst AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"AndThen\"\n});\n/** @internal */\nexport const makeAndThen = (first, second) => {\n  const o = Object.create(AndThenProto);\n  o.first = first;\n  o.second = second;\n  return o;\n};\nconst AddProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Add\"\n});\n/** @internal */\nexport const makeAdd = value => {\n  const o = Object.create(AddProto);\n  o.value = value;\n  return o;\n};\nconst RemoveProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Remove\"\n});\n/** @internal */\nexport const makeRemove = value => {\n  const o = Object.create(RemoveProto);\n  o.value = value;\n  return o;\n};\n/** @internal */\nexport const diff = (oldValue, newValue) => {\n  const [removed, patch] = HashSet.reduce([oldValue, empty()], ([set, patch], value) => {\n    if (HashSet.has(value)(set)) {\n      return [HashSet.remove(value)(set), patch];\n    }\n    return [set, combine(makeAdd(value))(patch)];\n  })(newValue);\n  return HashSet.reduce(patch, (patch, value) => combine(makeRemove(value))(patch))(removed);\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Dual.dual(2, (self, that) => makeAndThen(self, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Dual.dual(2, (self, oldValue) => {\n  if (self._tag === \"Empty\") {\n    return oldValue;\n  }\n  let set = oldValue;\n  let patches = Chunk.of(self);\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail));\n          break;\n        }\n      case \"Add\":\n        {\n          set = HashSet.add(head.value)(set);\n          patches = tail;\n          break;\n        }\n      case \"Remove\":\n        {\n          set = HashSet.remove(head.value)(set);\n          patches = tail;\n        }\n    }\n  }\n  return set;\n});\n//# sourceMappingURL=hashSetPatch.js.map","import * as Chunk from \"../../Chunk.js\";\nimport * as E from \"../../Either.js\";\nimport * as Equal from \"../../Equal.js\";\nimport * as Dual from \"../../Function.js\";\nimport { Structural } from \"../data.js\";\n/** @internal */\nexport const OrPatchTypeId = /*#__PURE__*/Symbol.for(\"effect/DifferOrPatch\");\nfunction variance(a) {\n  return a;\n}\n/** @internal */\nconst PatchProto = {\n  ...Structural.prototype,\n  [OrPatchTypeId]: {\n    _Value: variance,\n    _Key: variance,\n    _Patch: variance\n  }\n};\nconst EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Empty\"\n});\nconst _empty = /*#__PURE__*/Object.create(EmptyProto);\n/** @internal */\nexport const empty = () => _empty;\nconst AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"AndThen\"\n});\n/** @internal */\nexport const makeAndThen = (first, second) => {\n  const o = Object.create(AndThenProto);\n  o.first = first;\n  o.second = second;\n  return o;\n};\nconst SetLeftProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"SetLeft\"\n});\n/** @internal */\nexport const makeSetLeft = value => {\n  const o = Object.create(SetLeftProto);\n  o.value = value;\n  return o;\n};\nconst SetRightProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"SetRight\"\n});\n/** @internal */\nexport const makeSetRight = value => {\n  const o = Object.create(SetRightProto);\n  o.value = value;\n  return o;\n};\nconst UpdateLeftProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"UpdateLeft\"\n});\n/** @internal */\nexport const makeUpdateLeft = patch => {\n  const o = Object.create(UpdateLeftProto);\n  o.patch = patch;\n  return o;\n};\nconst UpdateRightProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"UpdateRight\"\n});\n/** @internal */\nexport const makeUpdateRight = patch => {\n  const o = Object.create(UpdateRightProto);\n  o.patch = patch;\n  return o;\n};\n/** @internal */\nexport const diff = options => {\n  switch (options.oldValue._tag) {\n    case \"Left\":\n      {\n        switch (options.newValue._tag) {\n          case \"Left\":\n            {\n              const valuePatch = options.left.diff(options.oldValue.left, options.newValue.left);\n              if (Equal.equals(valuePatch, options.left.empty)) {\n                return empty();\n              }\n              return makeUpdateLeft(valuePatch);\n            }\n          case \"Right\":\n            {\n              return makeSetRight(options.newValue.right);\n            }\n        }\n      }\n    case \"Right\":\n      {\n        switch (options.newValue._tag) {\n          case \"Left\":\n            {\n              return makeSetLeft(options.newValue.left);\n            }\n          case \"Right\":\n            {\n              const valuePatch = options.right.diff(options.oldValue.right, options.newValue.right);\n              if (Equal.equals(valuePatch, options.right.empty)) {\n                return empty();\n              }\n              return makeUpdateRight(valuePatch);\n            }\n        }\n      }\n  }\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Dual.dual(2, (self, that) => makeAndThen(self, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Dual.dual(2, (self, {\n  left,\n  oldValue,\n  right\n}) => {\n  if (self._tag === \"Empty\") {\n    return oldValue;\n  }\n  let patches = Chunk.of(self);\n  let result = oldValue;\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail));\n          break;\n        }\n      case \"UpdateLeft\":\n        {\n          if (result._tag === \"Left\") {\n            result = E.left(left.patch(head.patch, result.left));\n          }\n          patches = tail;\n          break;\n        }\n      case \"UpdateRight\":\n        {\n          if (result._tag === \"Right\") {\n            result = E.right(right.patch(head.patch, result.right));\n          }\n          patches = tail;\n          break;\n        }\n      case \"SetLeft\":\n        {\n          result = E.left(head.value);\n          patches = tail;\n          break;\n        }\n      case \"SetRight\":\n        {\n          result = E.right(head.value);\n          patches = tail;\n          break;\n        }\n    }\n  }\n  return result;\n});\n//# sourceMappingURL=orPatch.js.map","import * as Arr from \"../../Array.js\";\nimport * as Equal from \"../../Equal.js\";\nimport * as Dual from \"../../Function.js\";\nimport * as Data from \"../data.js\";\n/** @internal */\nexport const ReadonlyArrayPatchTypeId = /*#__PURE__*/Symbol.for(\"effect/DifferReadonlyArrayPatch\");\nfunction variance(a) {\n  return a;\n}\nconst PatchProto = {\n  ...Data.Structural.prototype,\n  [ReadonlyArrayPatchTypeId]: {\n    _Value: variance,\n    _Patch: variance\n  }\n};\nconst EmptyProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Empty\"\n});\nconst _empty = /*#__PURE__*/Object.create(EmptyProto);\n/**\n * @internal\n */\nexport const empty = () => _empty;\nconst AndThenProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"AndThen\"\n});\nconst makeAndThen = (first, second) => {\n  const o = Object.create(AndThenProto);\n  o.first = first;\n  o.second = second;\n  return o;\n};\nconst AppendProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Append\"\n});\nconst makeAppend = values => {\n  const o = Object.create(AppendProto);\n  o.values = values;\n  return o;\n};\nconst SliceProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Slice\"\n});\nconst makeSlice = (from, until) => {\n  const o = Object.create(SliceProto);\n  o.from = from;\n  o.until = until;\n  return o;\n};\nconst UpdateProto = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(PatchProto), {\n  _tag: \"Update\"\n});\nconst makeUpdate = (index, patch) => {\n  const o = Object.create(UpdateProto);\n  o.index = index;\n  o.patch = patch;\n  return o;\n};\n/** @internal */\nexport const diff = options => {\n  let i = 0;\n  let patch = empty();\n  while (i < options.oldValue.length && i < options.newValue.length) {\n    const oldElement = options.oldValue[i];\n    const newElement = options.newValue[i];\n    const valuePatch = options.differ.diff(oldElement, newElement);\n    if (!Equal.equals(valuePatch, options.differ.empty)) {\n      patch = combine(patch, makeUpdate(i, valuePatch));\n    }\n    i = i + 1;\n  }\n  if (i < options.oldValue.length) {\n    patch = combine(patch, makeSlice(0, i));\n  }\n  if (i < options.newValue.length) {\n    patch = combine(patch, makeAppend(Arr.drop(i)(options.newValue)));\n  }\n  return patch;\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Dual.dual(2, (self, that) => makeAndThen(self, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Dual.dual(3, (self, oldValue, differ) => {\n  if (self._tag === \"Empty\") {\n    return oldValue;\n  }\n  let readonlyArray = oldValue.slice();\n  let patches = Arr.of(self);\n  while (Arr.isNonEmptyArray(patches)) {\n    const head = Arr.headNonEmpty(patches);\n    const tail = Arr.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          tail.unshift(head.first, head.second);\n          patches = tail;\n          break;\n        }\n      case \"Append\":\n        {\n          for (const value of head.values) {\n            readonlyArray.push(value);\n          }\n          patches = tail;\n          break;\n        }\n      case \"Slice\":\n        {\n          readonlyArray = readonlyArray.slice(head.from, head.until);\n          patches = tail;\n          break;\n        }\n      case \"Update\":\n        {\n          readonlyArray[head.index] = differ.patch(head.patch, readonlyArray[head.index]);\n          patches = tail;\n          break;\n        }\n    }\n  }\n  return readonlyArray;\n});\n//# sourceMappingURL=readonlyArrayPatch.js.map","import * as Equal from \"../Equal.js\";\nimport * as Dual from \"../Function.js\";\nimport { constant, identity } from \"../Function.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport * as ChunkPatch from \"./differ/chunkPatch.js\";\nimport * as ContextPatch from \"./differ/contextPatch.js\";\nimport * as HashMapPatch from \"./differ/hashMapPatch.js\";\nimport * as HashSetPatch from \"./differ/hashSetPatch.js\";\nimport * as OrPatch from \"./differ/orPatch.js\";\nimport * as ReadonlyArrayPatch from \"./differ/readonlyArrayPatch.js\";\n/** @internal */\nexport const DifferTypeId = /*#__PURE__*/Symbol.for(\"effect/Differ\");\n/** @internal */\nexport const DifferProto = {\n  [DifferTypeId]: {\n    _P: identity,\n    _V: identity\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const make = params => {\n  const differ = Object.create(DifferProto);\n  differ.empty = params.empty;\n  differ.diff = params.diff;\n  differ.combine = params.combine;\n  differ.patch = params.patch;\n  return differ;\n};\n/** @internal */\nexport const environment = () => make({\n  empty: ContextPatch.empty(),\n  combine: (first, second) => ContextPatch.combine(second)(first),\n  diff: (oldValue, newValue) => ContextPatch.diff(oldValue, newValue),\n  patch: (patch, oldValue) => ContextPatch.patch(oldValue)(patch)\n});\n/** @internal */\nexport const chunk = differ => make({\n  empty: ChunkPatch.empty(),\n  combine: (first, second) => ChunkPatch.combine(second)(first),\n  diff: (oldValue, newValue) => ChunkPatch.diff({\n    oldValue,\n    newValue,\n    differ\n  }),\n  patch: (patch, oldValue) => ChunkPatch.patch(oldValue, differ)(patch)\n});\n/** @internal */\nexport const hashMap = differ => make({\n  empty: HashMapPatch.empty(),\n  combine: (first, second) => HashMapPatch.combine(second)(first),\n  diff: (oldValue, newValue) => HashMapPatch.diff({\n    oldValue,\n    newValue,\n    differ\n  }),\n  patch: (patch, oldValue) => HashMapPatch.patch(oldValue, differ)(patch)\n});\n/** @internal */\nexport const hashSet = () => make({\n  empty: HashSetPatch.empty(),\n  combine: (first, second) => HashSetPatch.combine(second)(first),\n  diff: (oldValue, newValue) => HashSetPatch.diff(oldValue, newValue),\n  patch: (patch, oldValue) => HashSetPatch.patch(oldValue)(patch)\n});\n/** @internal */\nexport const orElseEither = /*#__PURE__*/Dual.dual(2, (self, that) => make({\n  empty: OrPatch.empty(),\n  combine: (first, second) => OrPatch.combine(first, second),\n  diff: (oldValue, newValue) => OrPatch.diff({\n    oldValue,\n    newValue,\n    left: self,\n    right: that\n  }),\n  patch: (patch, oldValue) => OrPatch.patch(patch, {\n    oldValue,\n    left: self,\n    right: that\n  })\n}));\n/** @internal */\nexport const readonlyArray = differ => make({\n  empty: ReadonlyArrayPatch.empty(),\n  combine: (first, second) => ReadonlyArrayPatch.combine(first, second),\n  diff: (oldValue, newValue) => ReadonlyArrayPatch.diff({\n    oldValue,\n    newValue,\n    differ\n  }),\n  patch: (patch, oldValue) => ReadonlyArrayPatch.patch(patch, oldValue, differ)\n});\n/** @internal */\nexport const transform = /*#__PURE__*/Dual.dual(2, (self, {\n  toNew,\n  toOld\n}) => make({\n  empty: self.empty,\n  combine: (first, second) => self.combine(first, second),\n  diff: (oldValue, newValue) => self.diff(toOld(oldValue), toOld(newValue)),\n  patch: (patch, oldValue) => toNew(self.patch(patch, toOld(oldValue)))\n}));\n/** @internal */\nexport const update = () => updateWith((_, a) => a);\n/** @internal */\nexport const updateWith = f => make({\n  empty: identity,\n  combine: (first, second) => {\n    if (first === identity) {\n      return second;\n    }\n    if (second === identity) {\n      return first;\n    }\n    return a => second(first(a));\n  },\n  diff: (oldValue, newValue) => {\n    if (Equal.equals(oldValue, newValue)) {\n      return identity;\n    }\n    return constant(newValue);\n  },\n  patch: (patch, oldValue) => f(oldValue, patch(oldValue))\n});\n/** @internal */\nexport const zip = /*#__PURE__*/Dual.dual(2, (self, that) => make({\n  empty: [self.empty, that.empty],\n  combine: (first, second) => [self.combine(first[0], second[0]), that.combine(first[1], second[1])],\n  diff: (oldValue, newValue) => [self.diff(oldValue[0], newValue[0]), that.diff(oldValue[1], newValue[1])],\n  patch: (patch, oldValue) => [self.patch(patch[0], oldValue[0]), that.patch(patch[1], oldValue[1])]\n}));\n//# sourceMappingURL=differ.js.map","import { dual } from \"../Function.js\";\n/** @internal */\nconst BIT_MASK = 0xff;\n/** @internal */\nconst BIT_SHIFT = 0x08;\n/** @internal */\nexport const active = patch => patch & BIT_MASK;\n/** @internal */\nexport const enabled = patch => patch >> BIT_SHIFT & BIT_MASK;\n/** @internal */\nexport const make = (active, enabled) => (active & BIT_MASK) + ((enabled & active & BIT_MASK) << BIT_SHIFT);\n/** @internal */\nexport const empty = /*#__PURE__*/make(0, 0);\n/** @internal */\nexport const enable = flag => make(flag, flag);\n/** @internal */\nexport const disable = flag => make(flag, 0);\n/** @internal */\nexport const isEmpty = patch => patch === 0;\n/** @internal */\nexport const isActive = /*#__PURE__*/dual(2, (self, flag) => (active(self) & flag) !== 0);\n/** @internal */\nexport const isEnabled = /*#__PURE__*/dual(2, (self, flag) => (enabled(self) & flag) !== 0);\n/** @internal */\nexport const isDisabled = /*#__PURE__*/dual(2, (self, flag) => (active(self) & flag) !== 0 && (enabled(self) & flag) === 0);\n/** @internal */\nexport const exclude = /*#__PURE__*/dual(2, (self, flag) => make(active(self) & ~flag, enabled(self)));\n/** @internal */\nexport const both = /*#__PURE__*/dual(2, (self, that) => make(active(self) | active(that), enabled(self) & enabled(that)));\n/** @internal */\nexport const either = /*#__PURE__*/dual(2, (self, that) => make(active(self) | active(that), enabled(self) | enabled(that)));\n/** @internal */\nexport const andThen = /*#__PURE__*/dual(2, (self, that) => self | that);\n/** @internal */\nexport const inverse = patch => make(enabled(patch), invert(active(patch)));\n/** @internal */\nexport const invert = n => ~n >>> 0 & BIT_MASK;\n//# sourceMappingURL=runtimeFlagsPatch.js.map","import { dual } from \"../Function.js\";\nimport * as internalDiffer from \"./differ.js\";\nimport * as runtimeFlagsPatch from \"./runtimeFlagsPatch.js\";\n/** @internal */\nexport const None = 0;\n/** @internal */\nexport const Interruption = 1 << 0;\n/** @internal */\nexport const OpSupervision = 1 << 1;\n/** @internal */\nexport const RuntimeMetrics = 1 << 2;\n/** @internal */\nexport const WindDown = 1 << 4;\n/** @internal */\nexport const CooperativeYielding = 1 << 5;\n/** @internal */\nexport const allFlags = [None, Interruption, OpSupervision, RuntimeMetrics, WindDown, CooperativeYielding];\nconst print = flag => {\n  switch (flag) {\n    case CooperativeYielding:\n      {\n        return \"CooperativeYielding\";\n      }\n    case WindDown:\n      {\n        return \"WindDown\";\n      }\n    case RuntimeMetrics:\n      {\n        return \"RuntimeMetrics\";\n      }\n    case OpSupervision:\n      {\n        return \"OpSupervision\";\n      }\n    case Interruption:\n      {\n        return \"Interruption\";\n      }\n    case None:\n      {\n        return \"None\";\n      }\n  }\n};\n/** @internal */\nexport const cooperativeYielding = self => isEnabled(self, CooperativeYielding);\n/** @internal */\nexport const disable = /*#__PURE__*/dual(2, (self, flag) => self & ~flag);\n/** @internal */\nexport const disableAll = /*#__PURE__*/dual(2, (self, flags) => self & ~flags);\n/** @internal */\nexport const enable = /*#__PURE__*/dual(2, (self, flag) => self | flag);\n/** @internal */\nexport const enableAll = /*#__PURE__*/dual(2, (self, flags) => self | flags);\n/** @internal */\nexport const interruptible = self => interruption(self) && !windDown(self);\n/** @internal */\nexport const interruption = self => isEnabled(self, Interruption);\n/** @internal */\nexport const isDisabled = /*#__PURE__*/dual(2, (self, flag) => !isEnabled(self, flag));\n/** @internal */\nexport const isEnabled = /*#__PURE__*/dual(2, (self, flag) => (self & flag) !== 0);\n/** @internal */\nexport const make = (...flags) => flags.reduce((a, b) => a | b, 0);\n/** @internal */\nexport const none = /*#__PURE__*/make(None);\n/** @internal */\nexport const opSupervision = self => isEnabled(self, OpSupervision);\n/** @internal */\nexport const render = self => {\n  const active = [];\n  allFlags.forEach(flag => {\n    if (isEnabled(self, flag)) {\n      active.push(`${print(flag)}`);\n    }\n  });\n  return `RuntimeFlags(${active.join(\", \")})`;\n};\n/** @internal */\nexport const runtimeMetrics = self => isEnabled(self, RuntimeMetrics);\n/** @internal */\nexport const toSet = self => new Set(allFlags.filter(flag => isEnabled(self, flag)));\nexport const windDown = self => isEnabled(self, WindDown);\n// circular with RuntimeFlagsPatch\n/** @internal */\nexport const enabledSet = self => toSet(runtimeFlagsPatch.active(self) & runtimeFlagsPatch.enabled(self));\n/** @internal */\nexport const disabledSet = self => toSet(runtimeFlagsPatch.active(self) & ~runtimeFlagsPatch.enabled(self));\n/** @internal */\nexport const diff = /*#__PURE__*/dual(2, (self, that) => runtimeFlagsPatch.make(self ^ that, that));\n/** @internal */\nexport const patch = /*#__PURE__*/dual(2, (self, patch) => self & (runtimeFlagsPatch.invert(runtimeFlagsPatch.active(patch)) | runtimeFlagsPatch.enabled(patch)) | runtimeFlagsPatch.active(patch) & runtimeFlagsPatch.enabled(patch));\n/** @internal */\nexport const renderPatch = self => {\n  const enabled = Array.from(enabledSet(self)).map(flag => print(flag)).join(\", \");\n  const disabled = Array.from(disabledSet(self)).map(flag => print(flag)).join(\", \");\n  return `RuntimeFlagsPatch(enabled = (${enabled}), disabled = (${disabled}))`;\n};\n/** @internal */\nexport const differ = /*#__PURE__*/internalDiffer.make({\n  empty: runtimeFlagsPatch.empty,\n  diff: (oldValue, newValue) => diff(oldValue, newValue),\n  combine: (first, second) => runtimeFlagsPatch.andThen(second)(first),\n  patch: (_patch, oldValue) => patch(oldValue, _patch)\n});\n//# sourceMappingURL=runtimeFlags.js.map","/**\n * @since 2.0.0\n */\nimport * as runtimeFlags from \"./internal/runtimeFlags.js\";\nimport * as internal from \"./internal/runtimeFlagsPatch.js\";\n/**\n * The empty `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = internal.empty;\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * Creates a `RuntimeFlagsPatch` describing enabling the provided `RuntimeFlag`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const enable = internal.enable;\n/**\n * Creates a `RuntimeFlagsPatch` describing disabling the provided `RuntimeFlag`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const disable = internal.disable;\n/**\n * Returns `true` if the specified `RuntimeFlagsPatch` is empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isEmpty = internal.isEmpty;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as active.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isActive = internal.isActive;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as enabled.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isEnabled = internal.isEnabled;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as disabled.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isDisabled = internal.isDisabled;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` includes the specified\n * `RuntimeFlag`, `false` otherwise.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const includes = internal.isActive;\n/**\n * Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,\n * followed by `that` patch.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const andThen = internal.andThen;\n/**\n * Creates a `RuntimeFlagsPatch` describing application of both the `self` patch\n * and `that` patch.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const both = internal.both;\n/**\n * Creates a `RuntimeFlagsPatch` describing application of either the `self`\n * patch or `that` patch.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const either = internal.either;\n/**\n * Creates a `RuntimeFlagsPatch` which describes exclusion of the specified\n * `RuntimeFlag` from the set of `RuntimeFlags`.\n *\n * @category utils\n * @since 2.0.0\n */\nexport const exclude = internal.exclude;\n/**\n * Creates a `RuntimeFlagsPatch` which describes the inverse of the patch\n * specified by the provided `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const inverse = internal.inverse;\n/**\n * Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\n * enabled by the specified `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const enabledSet = runtimeFlags.enabledSet;\n/**\n * Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\n * disabled by the specified `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const disabledSet = runtimeFlags.disabledSet;\n/**\n * Renders the provided `RuntimeFlagsPatch` to a string.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const render = runtimeFlags.renderPatch;\n//# sourceMappingURL=RuntimeFlagsPatch.js.map","/** @internal */\nexport const OP_DIE = \"Die\";\n/** @internal */\nexport const OP_EMPTY = \"Empty\";\n/** @internal */\nexport const OP_FAIL = \"Fail\";\n/** @internal */\nexport const OP_INTERRUPT = \"Interrupt\";\n/** @internal */\nexport const OP_PARALLEL = \"Parallel\";\n/** @internal */\nexport const OP_SEQUENTIAL = \"Sequential\";\n//# sourceMappingURL=cause.js.map","import * as Arr from \"../Array.js\";\nimport * as Chunk from \"../Chunk.js\";\nimport * as Either from \"../Either.js\";\nimport * as Equal from \"../Equal.js\";\nimport { constFalse, constTrue, dual, identity, pipe } from \"../Function.js\";\nimport { globalValue } from \"../GlobalValue.js\";\nimport * as Hash from \"../Hash.js\";\nimport * as HashSet from \"../HashSet.js\";\nimport { NodeInspectSymbol, stringifyCircular, toJSON } from \"../Inspectable.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty, isFunction } from \"../Predicate.js\";\nimport { getBugErrorMessage } from \"./errors.js\";\nimport * as OpCodes from \"./opCodes/cause.js\";\n// -----------------------------------------------------------------------------\n// Models\n// -----------------------------------------------------------------------------\n/** @internal */\nconst CauseSymbolKey = \"effect/Cause\";\n/** @internal */\nexport const CauseTypeId = /*#__PURE__*/Symbol.for(CauseSymbolKey);\nconst variance = {\n  /* c8 ignore next */\n  _E: _ => _\n};\n/** @internal */\nconst proto = {\n  [CauseTypeId]: variance,\n  [Hash.symbol]() {\n    return pipe(Hash.hash(CauseSymbolKey), Hash.combine(Hash.hash(flattenCause(this))), Hash.cached(this));\n  },\n  [Equal.symbol](that) {\n    return isCause(that) && causeEquals(this, that);\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  toJSON() {\n    switch (this._tag) {\n      case \"Empty\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag\n        };\n      case \"Die\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          defect: toJSON(this.defect)\n        };\n      case \"Interrupt\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          fiberId: this.fiberId.toJSON()\n        };\n      case \"Fail\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          failure: toJSON(this.error)\n        };\n      case \"Sequential\":\n      case \"Parallel\":\n        return {\n          _id: \"Cause\",\n          _tag: this._tag,\n          left: toJSON(this.left),\n          right: toJSON(this.right)\n        };\n    }\n  },\n  toString() {\n    return pretty(this);\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n};\n// -----------------------------------------------------------------------------\n// Constructors\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const empty = /*#__PURE__*/(() => {\n  const o = /*#__PURE__*/Object.create(proto);\n  o._tag = OpCodes.OP_EMPTY;\n  return o;\n})();\n/** @internal */\nexport const fail = error => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_FAIL;\n  o.error = error;\n  return o;\n};\n/** @internal */\nexport const die = defect => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_DIE;\n  o.defect = defect;\n  return o;\n};\n/** @internal */\nexport const interrupt = fiberId => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_INTERRUPT;\n  o.fiberId = fiberId;\n  return o;\n};\n/** @internal */\nexport const parallel = (left, right) => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_PARALLEL;\n  o.left = left;\n  o.right = right;\n  return o;\n};\n/** @internal */\nexport const sequential = (left, right) => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_SEQUENTIAL;\n  o.left = left;\n  o.right = right;\n  return o;\n};\n// -----------------------------------------------------------------------------\n// Refinements\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const isCause = u => hasProperty(u, CauseTypeId);\n/** @internal */\nexport const isEmptyType = self => self._tag === OpCodes.OP_EMPTY;\n/** @internal */\nexport const isFailType = self => self._tag === OpCodes.OP_FAIL;\n/** @internal */\nexport const isDieType = self => self._tag === OpCodes.OP_DIE;\n/** @internal */\nexport const isInterruptType = self => self._tag === OpCodes.OP_INTERRUPT;\n/** @internal */\nexport const isSequentialType = self => self._tag === OpCodes.OP_SEQUENTIAL;\n/** @internal */\nexport const isParallelType = self => self._tag === OpCodes.OP_PARALLEL;\n// -----------------------------------------------------------------------------\n// Getters\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const size = self => reduceWithContext(self, void 0, SizeCauseReducer);\n/** @internal */\nexport const isEmpty = self => {\n  if (self._tag === OpCodes.OP_EMPTY) {\n    return true;\n  }\n  return reduce(self, true, (acc, cause) => {\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          return Option.some(acc);\n        }\n      case OpCodes.OP_DIE:\n      case OpCodes.OP_FAIL:\n      case OpCodes.OP_INTERRUPT:\n        {\n          return Option.some(false);\n        }\n      default:\n        {\n          return Option.none();\n        }\n    }\n  });\n};\n/** @internal */\nexport const isFailure = self => Option.isSome(failureOption(self));\n/** @internal */\nexport const isDie = self => Option.isSome(dieOption(self));\n/** @internal */\nexport const isInterrupted = self => Option.isSome(interruptOption(self));\n/** @internal */\nexport const isInterruptedOnly = self => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self);\n/** @internal */\nexport const failures = self => Chunk.reverse(reduce(self, Chunk.empty(), (list, cause) => cause._tag === OpCodes.OP_FAIL ? Option.some(pipe(list, Chunk.prepend(cause.error))) : Option.none()));\n/** @internal */\nexport const defects = self => Chunk.reverse(reduce(self, Chunk.empty(), (list, cause) => cause._tag === OpCodes.OP_DIE ? Option.some(pipe(list, Chunk.prepend(cause.defect))) : Option.none()));\n/** @internal */\nexport const interruptors = self => reduce(self, HashSet.empty(), (set, cause) => cause._tag === OpCodes.OP_INTERRUPT ? Option.some(pipe(set, HashSet.add(cause.fiberId))) : Option.none());\n/** @internal */\nexport const failureOption = self => find(self, cause => cause._tag === OpCodes.OP_FAIL ? Option.some(cause.error) : Option.none());\n/** @internal */\nexport const failureOrCause = self => {\n  const option = failureOption(self);\n  switch (option._tag) {\n    case \"None\":\n      {\n        // no `E` inside this `Cause`, so it can be safely cast to `never`\n        return Either.right(self);\n      }\n    case \"Some\":\n      {\n        return Either.left(option.value);\n      }\n  }\n};\n/** @internal */\nexport const dieOption = self => find(self, cause => cause._tag === OpCodes.OP_DIE ? Option.some(cause.defect) : Option.none());\n/** @internal */\nexport const flipCauseOption = self => match(self, {\n  onEmpty: Option.some(empty),\n  onFail: Option.map(fail),\n  onDie: defect => Option.some(die(defect)),\n  onInterrupt: fiberId => Option.some(interrupt(fiberId)),\n  onSequential: Option.mergeWith(sequential),\n  onParallel: Option.mergeWith(parallel)\n});\n/** @internal */\nexport const interruptOption = self => find(self, cause => cause._tag === OpCodes.OP_INTERRUPT ? Option.some(cause.fiberId) : Option.none());\n/** @internal */\nexport const keepDefects = self => match(self, {\n  onEmpty: Option.none(),\n  onFail: () => Option.none(),\n  onDie: defect => Option.some(die(defect)),\n  onInterrupt: () => Option.none(),\n  onSequential: Option.mergeWith(sequential),\n  onParallel: Option.mergeWith(parallel)\n});\n/** @internal */\nexport const keepDefectsAndElectFailures = self => match(self, {\n  onEmpty: Option.none(),\n  onFail: failure => Option.some(die(failure)),\n  onDie: defect => Option.some(die(defect)),\n  onInterrupt: () => Option.none(),\n  onSequential: Option.mergeWith(sequential),\n  onParallel: Option.mergeWith(parallel)\n});\n/** @internal */\nexport const linearize = self => match(self, {\n  onEmpty: HashSet.empty(),\n  onFail: error => HashSet.make(fail(error)),\n  onDie: defect => HashSet.make(die(defect)),\n  onInterrupt: fiberId => HashSet.make(interrupt(fiberId)),\n  onSequential: (leftSet, rightSet) => HashSet.flatMap(leftSet, leftCause => HashSet.map(rightSet, rightCause => sequential(leftCause, rightCause))),\n  onParallel: (leftSet, rightSet) => HashSet.flatMap(leftSet, leftCause => HashSet.map(rightSet, rightCause => parallel(leftCause, rightCause)))\n});\n/** @internal */\nexport const stripFailures = self => match(self, {\n  onEmpty: empty,\n  onFail: () => empty,\n  onDie: die,\n  onInterrupt: interrupt,\n  onSequential: sequential,\n  onParallel: parallel\n});\n/** @internal */\nexport const electFailures = self => match(self, {\n  onEmpty: empty,\n  onFail: die,\n  onDie: die,\n  onInterrupt: interrupt,\n  onSequential: sequential,\n  onParallel: parallel\n});\n/** @internal */\nexport const stripSomeDefects = /*#__PURE__*/dual(2, (self, pf) => match(self, {\n  onEmpty: Option.some(empty),\n  onFail: error => Option.some(fail(error)),\n  onDie: defect => {\n    const option = pf(defect);\n    return Option.isSome(option) ? Option.none() : Option.some(die(defect));\n  },\n  onInterrupt: fiberId => Option.some(interrupt(fiberId)),\n  onSequential: Option.mergeWith(sequential),\n  onParallel: Option.mergeWith(parallel)\n}));\n// -----------------------------------------------------------------------------\n// Mapping\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const as = /*#__PURE__*/dual(2, (self, error) => map(self, () => error));\n/** @internal */\nexport const map = /*#__PURE__*/dual(2, (self, f) => flatMap(self, e => fail(f(e))));\n// -----------------------------------------------------------------------------\n// Sequencing\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => match(self, {\n  onEmpty: empty,\n  onFail: error => f(error),\n  onDie: defect => die(defect),\n  onInterrupt: fiberId => interrupt(fiberId),\n  onSequential: (left, right) => sequential(left, right),\n  onParallel: (left, right) => parallel(left, right)\n}));\n/** @internal */\nexport const flatten = self => flatMap(self, identity);\n/** @internal */\nexport const andThen = /*#__PURE__*/dual(2, (self, f) => isFunction(f) ? flatMap(self, f) : flatMap(self, () => f));\n// -----------------------------------------------------------------------------\n// Equality\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const contains = /*#__PURE__*/dual(2, (self, that) => {\n  if (that._tag === OpCodes.OP_EMPTY || self === that) {\n    return true;\n  }\n  return reduce(self, false, (accumulator, cause) => {\n    return Option.some(accumulator || causeEquals(cause, that));\n  });\n});\n/** @internal */\nconst causeEquals = (left, right) => {\n  let leftStack = Chunk.of(left);\n  let rightStack = Chunk.of(right);\n  while (Chunk.isNonEmpty(leftStack) && Chunk.isNonEmpty(rightStack)) {\n    const [leftParallel, leftSequential] = pipe(Chunk.headNonEmpty(leftStack), reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return Option.some([pipe(parallel, HashSet.union(par)), pipe(sequential, Chunk.appendAll(seq))]);\n    }));\n    const [rightParallel, rightSequential] = pipe(Chunk.headNonEmpty(rightStack), reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return Option.some([pipe(parallel, HashSet.union(par)), pipe(sequential, Chunk.appendAll(seq))]);\n    }));\n    if (!Equal.equals(leftParallel, rightParallel)) {\n      return false;\n    }\n    leftStack = leftSequential;\n    rightStack = rightSequential;\n  }\n  return true;\n};\n// -----------------------------------------------------------------------------\n// Flattening\n// -----------------------------------------------------------------------------\n/**\n * Flattens a cause to a sequence of sets of causes, where each set represents\n * causes that fail in parallel and sequential sets represent causes that fail\n * after each other.\n *\n * @internal\n */\nconst flattenCause = cause => {\n  return flattenCauseLoop(Chunk.of(cause), Chunk.empty());\n};\n/** @internal */\nconst flattenCauseLoop = (causes, flattened) => {\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    const [parallel, sequential] = pipe(causes, Arr.reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return [pipe(parallel, HashSet.union(par)), pipe(sequential, Chunk.appendAll(seq))];\n    }));\n    const updated = HashSet.size(parallel) > 0 ? pipe(flattened, Chunk.prepend(parallel)) : flattened;\n    if (Chunk.isEmpty(sequential)) {\n      return Chunk.reverse(updated);\n    }\n    causes = sequential;\n    flattened = updated;\n  }\n  throw new Error(getBugErrorMessage(\"Cause.flattenCauseLoop\"));\n};\n// -----------------------------------------------------------------------------\n// Finding\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const find = /*#__PURE__*/dual(2, (self, pf) => {\n  const stack = [self];\n  while (stack.length > 0) {\n    const item = stack.pop();\n    const option = pf(item);\n    switch (option._tag) {\n      case \"None\":\n        {\n          switch (item._tag) {\n            case OpCodes.OP_SEQUENTIAL:\n            case OpCodes.OP_PARALLEL:\n              {\n                stack.push(item.right);\n                stack.push(item.left);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Some\":\n        {\n          return option;\n        }\n    }\n  }\n  return Option.none();\n});\n// -----------------------------------------------------------------------------\n// Filtering\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const filter = /*#__PURE__*/dual(2, (self, predicate) => reduceWithContext(self, void 0, FilterCauseReducer(predicate)));\n// -----------------------------------------------------------------------------\n// Evaluation\n// -----------------------------------------------------------------------------\n/**\n * Takes one step in evaluating a cause, returning a set of causes that fail\n * in parallel and a list of causes that fail sequentially after those causes.\n *\n * @internal\n */\nconst evaluateCause = self => {\n  let cause = self;\n  const stack = [];\n  let _parallel = HashSet.empty();\n  let _sequential = Chunk.empty();\n  while (cause !== undefined) {\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_FAIL:\n        {\n          _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.error));\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_DIE:\n        {\n          _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.defect));\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_INTERRUPT:\n        {\n          _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.fiberId));\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          switch (cause.left._tag) {\n            case OpCodes.OP_EMPTY:\n              {\n                cause = cause.right;\n                break;\n              }\n            case OpCodes.OP_SEQUENTIAL:\n              {\n                cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));\n                break;\n              }\n            case OpCodes.OP_PARALLEL:\n              {\n                cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));\n                break;\n              }\n            default:\n              {\n                _sequential = Chunk.prepend(_sequential, cause.right);\n                cause = cause.left;\n                break;\n              }\n          }\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          stack.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n    }\n  }\n  throw new Error(getBugErrorMessage(\"Cause.evaluateCauseLoop\"));\n};\n// -----------------------------------------------------------------------------\n// Reducing\n// -----------------------------------------------------------------------------\n/** @internal */\nconst SizeCauseReducer = {\n  emptyCase: () => 0,\n  failCase: () => 1,\n  dieCase: () => 1,\n  interruptCase: () => 1,\n  sequentialCase: (_, left, right) => left + right,\n  parallelCase: (_, left, right) => left + right\n};\n/** @internal */\nconst IsInterruptedOnlyCauseReducer = {\n  emptyCase: constTrue,\n  failCase: constFalse,\n  dieCase: constFalse,\n  interruptCase: constTrue,\n  sequentialCase: (_, left, right) => left && right,\n  parallelCase: (_, left, right) => left && right\n};\n/** @internal */\nconst FilterCauseReducer = predicate => ({\n  emptyCase: () => empty,\n  failCase: (_, error) => fail(error),\n  dieCase: (_, defect) => die(defect),\n  interruptCase: (_, fiberId) => interrupt(fiberId),\n  sequentialCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return sequential(left, right);\n      }\n      return left;\n    }\n    if (predicate(right)) {\n      return right;\n    }\n    return empty;\n  },\n  parallelCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return parallel(left, right);\n      }\n      return left;\n    }\n    if (predicate(right)) {\n      return right;\n    }\n    return empty;\n  }\n});\nconst OP_SEQUENTIAL_CASE = \"SequentialCase\";\nconst OP_PARALLEL_CASE = \"ParallelCase\";\n/** @internal */\nexport const match = /*#__PURE__*/dual(2, (self, {\n  onDie,\n  onEmpty,\n  onFail,\n  onInterrupt,\n  onParallel,\n  onSequential\n}) => {\n  return reduceWithContext(self, void 0, {\n    emptyCase: () => onEmpty,\n    failCase: (_, error) => onFail(error),\n    dieCase: (_, defect) => onDie(defect),\n    interruptCase: (_, fiberId) => onInterrupt(fiberId),\n    sequentialCase: (_, left, right) => onSequential(left, right),\n    parallelCase: (_, left, right) => onParallel(left, right)\n  });\n});\n/** @internal */\nexport const reduce = /*#__PURE__*/dual(3, (self, zero, pf) => {\n  let accumulator = zero;\n  let cause = self;\n  const causes = [];\n  while (cause !== undefined) {\n    const option = pf(accumulator, cause);\n    accumulator = Option.isSome(option) ? option.value : accumulator;\n    switch (cause._tag) {\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          causes.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          causes.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n      default:\n        {\n          cause = undefined;\n          break;\n        }\n    }\n    if (cause === undefined && causes.length > 0) {\n      cause = causes.pop();\n    }\n  }\n  return accumulator;\n});\n/** @internal */\nexport const reduceWithContext = /*#__PURE__*/dual(3, (self, context, reducer) => {\n  const input = [self];\n  const output = [];\n  while (input.length > 0) {\n    const cause = input.pop();\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          output.push(Either.right(reducer.emptyCase(context)));\n          break;\n        }\n      case OpCodes.OP_FAIL:\n        {\n          output.push(Either.right(reducer.failCase(context, cause.error)));\n          break;\n        }\n      case OpCodes.OP_DIE:\n        {\n          output.push(Either.right(reducer.dieCase(context, cause.defect)));\n          break;\n        }\n      case OpCodes.OP_INTERRUPT:\n        {\n          output.push(Either.right(reducer.interruptCase(context, cause.fiberId)));\n          break;\n        }\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          input.push(cause.right);\n          input.push(cause.left);\n          output.push(Either.left({\n            _tag: OP_SEQUENTIAL_CASE\n          }));\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          input.push(cause.right);\n          input.push(cause.left);\n          output.push(Either.left({\n            _tag: OP_PARALLEL_CASE\n          }));\n          break;\n        }\n    }\n  }\n  const accumulator = [];\n  while (output.length > 0) {\n    const either = output.pop();\n    switch (either._tag) {\n      case \"Left\":\n        {\n          switch (either.left._tag) {\n            case OP_SEQUENTIAL_CASE:\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.sequentialCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n            case OP_PARALLEL_CASE:\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.parallelCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Right\":\n        {\n          accumulator.push(either.right);\n          break;\n        }\n    }\n  }\n  if (accumulator.length === 0) {\n    throw new Error(\"BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues\");\n  }\n  return accumulator.pop();\n});\n// -----------------------------------------------------------------------------\n// Pretty Printing\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const pretty = (cause, options) => {\n  if (isInterruptedOnly(cause)) {\n    return \"All fibers interrupted without errors.\";\n  }\n  return prettyErrors(cause).map(function (e) {\n    if (options?.renderErrorCause !== true || e.cause === undefined) {\n      return e.stack;\n    }\n    return `${e.stack} {\\n${renderErrorCause(e.cause, \"  \")}\\n}`;\n  }).join(\"\\n\");\n};\nconst renderErrorCause = (cause, prefix) => {\n  const lines = cause.stack.split(\"\\n\");\n  let stack = `${prefix}[cause]: ${lines[0]}`;\n  for (let i = 1, len = lines.length; i < len; i++) {\n    stack += `\\n${prefix}${lines[i]}`;\n  }\n  if (cause.cause) {\n    stack += ` {\\n${renderErrorCause(cause.cause, `${prefix}  `)}\\n${prefix}}`;\n  }\n  return stack;\n};\n/** @internal */\nexport class PrettyError extends globalThis.Error {\n  span = undefined;\n  constructor(originalError) {\n    const originalErrorIsObject = typeof originalError === \"object\" && originalError !== null;\n    const prevLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 1;\n    super(prettyErrorMessage(originalError), originalErrorIsObject && \"cause\" in originalError && typeof originalError.cause !== \"undefined\" ? {\n      cause: new PrettyError(originalError.cause)\n    } : undefined);\n    if (this.message === \"\") {\n      this.message = \"An error has occurred\";\n    }\n    Error.stackTraceLimit = prevLimit;\n    this.name = originalError instanceof Error ? originalError.name : \"Error\";\n    if (originalErrorIsObject) {\n      if (spanSymbol in originalError) {\n        this.span = originalError[spanSymbol];\n      }\n      Object.keys(originalError).forEach(key => {\n        if (!(key in this)) {\n          // @ts-expect-error\n          this[key] = originalError[key];\n        }\n      });\n    }\n    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : \"\", this.span);\n  }\n}\n/**\n * A utility function for generating human-readable error messages from a generic error of type `unknown`.\n *\n * Rules:\n *\n * 1) If the input `u` is already a string, it's considered a message.\n * 2) If `u` is an Error instance with a message defined, it uses the message.\n * 3) If `u` has a user-defined `toString()` method, it uses that method.\n * 4) Otherwise, it uses `Inspectable.stringifyCircular` to produce a string representation and uses it as the error message,\n *   with \"Error\" added as a prefix.\n *\n * @internal\n */\nexport const prettyErrorMessage = u => {\n  // 1)\n  if (typeof u === \"string\") {\n    return u;\n  }\n  // 2)\n  if (typeof u === \"object\" && u !== null && u instanceof Error) {\n    return u.message;\n  }\n  // 3)\n  try {\n    if (hasProperty(u, \"toString\") && isFunction(u[\"toString\"]) && u[\"toString\"] !== Object.prototype.toString && u[\"toString\"] !== globalThis.Array.prototype.toString) {\n      return u[\"toString\"]();\n    }\n  } catch {\n    // something's off, rollback to json\n  }\n  // 4)\n  return stringifyCircular(u);\n};\nconst locationRegex = /\\((.*)\\)/g;\n/** @internal */\nexport const spanToTrace = /*#__PURE__*/globalValue(\"effect/Tracer/spanToTrace\", () => new WeakMap());\nconst prettyErrorStack = (message, stack, span) => {\n  const out = [message];\n  const lines = stack.startsWith(message) ? stack.slice(message.length).split(\"\\n\") : stack.split(\"\\n\");\n  for (let i = 1; i < lines.length; i++) {\n    if (lines[i].includes(\"Generator.next\")) {\n      break;\n    }\n    if (lines[i].includes(\"effect_internal_function\")) {\n      out.pop();\n      break;\n    }\n    out.push(lines[i].replace(/at .*effect_instruction_i.*\\((.*)\\)/, \"at $1\").replace(/EffectPrimitive\\.\\w+/, \"<anonymous>\"));\n  }\n  if (span) {\n    let current = span;\n    let i = 0;\n    while (current && current._tag === \"Span\" && i < 10) {\n      const stackFn = spanToTrace.get(current);\n      if (typeof stackFn === \"function\") {\n        const stack = stackFn();\n        if (typeof stack === \"string\") {\n          const locationMatchAll = stack.matchAll(locationRegex);\n          let match = false;\n          for (const [, location] of locationMatchAll) {\n            match = true;\n            out.push(`    at ${current.name} (${location})`);\n          }\n          if (!match) {\n            out.push(`    at ${current.name} (${stack.replace(/^at /, \"\")})`);\n          }\n        } else {\n          out.push(`    at ${current.name}`);\n        }\n      } else {\n        out.push(`    at ${current.name}`);\n      }\n      current = Option.getOrUndefined(current.parent);\n      i++;\n    }\n  }\n  return out.join(\"\\n\");\n};\n/** @internal */\nexport const spanSymbol = /*#__PURE__*/Symbol.for(\"effect/SpanAnnotation\");\n/** @internal */\nexport const prettyErrors = cause => reduceWithContext(cause, void 0, {\n  emptyCase: () => [],\n  dieCase: (_, unknownError) => {\n    return [new PrettyError(unknownError)];\n  },\n  failCase: (_, error) => {\n    return [new PrettyError(error)];\n  },\n  interruptCase: () => [],\n  parallelCase: (_, l, r) => [...l, ...r],\n  sequentialCase: (_, l, r) => [...l, ...r]\n});\n//# sourceMappingURL=cause.js.map","/** @internal */\nexport class SingleShotGen {\n  self;\n  called = false;\n  constructor(self) {\n    this.self = self;\n  }\n  next(a) {\n    return this.called ? {\n      value: a,\n      done: true\n    } : (this.called = true, {\n      value: this.self,\n      done: false\n    });\n  }\n  return(a) {\n    return {\n      value: a,\n      done: true\n    };\n  }\n  throw(e) {\n    throw e;\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(this.self);\n  }\n}\n//# sourceMappingURL=singleShotGen.js.map","import * as Arr from \"../Array.js\";\nimport * as Chunk from \"../Chunk.js\";\nimport * as Context from \"../Context.js\";\nimport * as Duration from \"../Duration.js\";\nimport * as Either from \"../Either.js\";\nimport * as Equal from \"../Equal.js\";\nimport * as FiberId from \"../FiberId.js\";\nimport { dual, identity, pipe } from \"../Function.js\";\nimport { globalValue } from \"../GlobalValue.js\";\nimport * as Hash from \"../Hash.js\";\nimport * as HashMap from \"../HashMap.js\";\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\";\nimport * as List from \"../List.js\";\nimport * as MutableRef from \"../MutableRef.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport { hasProperty, isObject, isPromiseLike } from \"../Predicate.js\";\nimport * as RuntimeFlagsPatch from \"../RuntimeFlagsPatch.js\";\nimport { internalCall, YieldWrap } from \"../Utils.js\";\nimport * as blockedRequests_ from \"./blockedRequests.js\";\nimport * as internalCause from \"./cause.js\";\nimport * as deferred from \"./deferred.js\";\nimport * as internalDiffer from \"./differ.js\";\nimport { CommitPrototype, effectVariance, StructuralCommitPrototype } from \"./effectable.js\";\nimport { getBugErrorMessage } from \"./errors.js\";\nimport * as DeferredOpCodes from \"./opCodes/deferred.js\";\nimport * as OpCodes from \"./opCodes/effect.js\";\nimport * as runtimeFlags_ from \"./runtimeFlags.js\";\nimport { SingleShotGen } from \"./singleShotGen.js\";\n// -----------------------------------------------------------------------------\n// Effect\n// -----------------------------------------------------------------------------\n/**\n * @internal\n */\nexport const blocked = (blockedRequests, _continue) => {\n  const effect = new EffectPrimitive(\"Blocked\");\n  effect.effect_instruction_i0 = blockedRequests;\n  effect.effect_instruction_i1 = _continue;\n  return effect;\n};\n/**\n * @internal\n */\nexport const runRequestBlock = blockedRequests => {\n  const effect = new EffectPrimitive(\"RunBlocked\");\n  effect.effect_instruction_i0 = blockedRequests;\n  return effect;\n};\n/** @internal */\nexport const EffectTypeId = /*#__PURE__*/Symbol.for(\"effect/Effect\");\n/** @internal */\nexport class RevertFlags {\n  patch;\n  op;\n  _op = OpCodes.OP_REVERT_FLAGS;\n  constructor(patch, op) {\n    this.patch = patch;\n    this.op = op;\n  }\n}\nclass EffectPrimitive {\n  _op;\n  effect_instruction_i0 = undefined;\n  effect_instruction_i1 = undefined;\n  effect_instruction_i2 = undefined;\n  trace = undefined;\n  [EffectTypeId] = effectVariance;\n  constructor(_op) {\n    this._op = _op;\n  }\n  [Equal.symbol](that) {\n    return this === that;\n  }\n  [Hash.symbol]() {\n    return Hash.cached(this, Hash.random(this));\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  toJSON() {\n    return {\n      _id: \"Effect\",\n      _op: this._op,\n      effect_instruction_i0: toJSON(this.effect_instruction_i0),\n      effect_instruction_i1: toJSON(this.effect_instruction_i1),\n      effect_instruction_i2: toJSON(this.effect_instruction_i2)\n    };\n  }\n  toString() {\n    return format(this.toJSON());\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this));\n  }\n}\n/** @internal */\nclass EffectPrimitiveFailure {\n  _op;\n  effect_instruction_i0 = undefined;\n  effect_instruction_i1 = undefined;\n  effect_instruction_i2 = undefined;\n  trace = undefined;\n  [EffectTypeId] = effectVariance;\n  constructor(_op) {\n    this._op = _op;\n    // @ts-expect-error\n    this._tag = _op;\n  }\n  [Equal.symbol](that) {\n    return exitIsExit(that) && that._op === \"Failure\" &&\n    // @ts-expect-error\n    Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0);\n  }\n  [Hash.symbol]() {\n    return pipe(\n    // @ts-expect-error\n    Hash.string(this._tag),\n    // @ts-expect-error\n    Hash.combine(Hash.hash(this.effect_instruction_i0)), Hash.cached(this));\n  }\n  get cause() {\n    return this.effect_instruction_i0;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      cause: this.cause.toJSON()\n    };\n  }\n  toString() {\n    return format(this.toJSON());\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this));\n  }\n}\n/** @internal */\nclass EffectPrimitiveSuccess {\n  _op;\n  effect_instruction_i0 = undefined;\n  effect_instruction_i1 = undefined;\n  effect_instruction_i2 = undefined;\n  trace = undefined;\n  [EffectTypeId] = effectVariance;\n  constructor(_op) {\n    this._op = _op;\n    // @ts-expect-error\n    this._tag = _op;\n  }\n  [Equal.symbol](that) {\n    return exitIsExit(that) && that._op === \"Success\" &&\n    // @ts-expect-error\n    Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0);\n  }\n  [Hash.symbol]() {\n    return pipe(\n    // @ts-expect-error\n    Hash.string(this._tag),\n    // @ts-expect-error\n    Hash.combine(Hash.hash(this.effect_instruction_i0)), Hash.cached(this));\n  }\n  get value() {\n    return this.effect_instruction_i0;\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      value: toJSON(this.value)\n    };\n  }\n  toString() {\n    return format(this.toJSON());\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON();\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this));\n  }\n}\n/** @internal */\nexport const isEffect = u => hasProperty(u, EffectTypeId);\n/* @internal */\nexport const withFiberRuntime = withRuntime => {\n  const effect = new EffectPrimitive(OpCodes.OP_WITH_RUNTIME);\n  effect.effect_instruction_i0 = withRuntime;\n  return effect;\n};\n/* @internal */\nexport const acquireUseRelease = /*#__PURE__*/dual(3, (acquire, use, release) => uninterruptibleMask(restore => flatMap(acquire, a => flatMap(exit(suspend(() => restore(use(a)))), exit => {\n  return suspend(() => release(a, exit)).pipe(matchCauseEffect({\n    onFailure: cause => {\n      switch (exit._tag) {\n        case OpCodes.OP_FAILURE:\n          return failCause(internalCause.sequential(exit.effect_instruction_i0, cause));\n        case OpCodes.OP_SUCCESS:\n          return failCause(cause);\n      }\n    },\n    onSuccess: () => exit\n  }));\n}))));\n/* @internal */\nexport const as = /*#__PURE__*/dual(2, (self, value) => flatMap(self, () => succeed(value)));\n/* @internal */\nexport const asVoid = self => as(self, void 0);\n/* @internal */\nexport const custom = function () {\n  const wrapper = new EffectPrimitive(OpCodes.OP_COMMIT);\n  switch (arguments.length) {\n    case 2:\n      {\n        wrapper.effect_instruction_i0 = arguments[0];\n        wrapper.commit = arguments[1];\n        break;\n      }\n    case 3:\n      {\n        wrapper.effect_instruction_i0 = arguments[0];\n        wrapper.effect_instruction_i1 = arguments[1];\n        wrapper.commit = arguments[2];\n        break;\n      }\n    case 4:\n      {\n        wrapper.effect_instruction_i0 = arguments[0];\n        wrapper.effect_instruction_i1 = arguments[1];\n        wrapper.effect_instruction_i2 = arguments[2];\n        wrapper.commit = arguments[3];\n        break;\n      }\n    default:\n      {\n        throw new Error(getBugErrorMessage(\"you're not supposed to end up here\"));\n      }\n  }\n  return wrapper;\n};\n/* @internal */\nexport const unsafeAsync = (register, blockingOn = FiberId.none) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ASYNC);\n  let cancelerRef = undefined;\n  effect.effect_instruction_i0 = resume => {\n    cancelerRef = register(resume);\n  };\n  effect.effect_instruction_i1 = blockingOn;\n  return onInterrupt(effect, _ => isEffect(cancelerRef) ? cancelerRef : void_);\n};\n/* @internal */\nexport const asyncInterrupt = (register, blockingOn = FiberId.none) => suspend(() => unsafeAsync(register, blockingOn));\nconst async_ = (resume, blockingOn = FiberId.none) => {\n  return custom(resume, function () {\n    let backingResume = undefined;\n    let pendingEffect = undefined;\n    function proxyResume(effect) {\n      if (backingResume) {\n        backingResume(effect);\n      } else if (pendingEffect === undefined) {\n        pendingEffect = effect;\n      }\n    }\n    const effect = new EffectPrimitive(OpCodes.OP_ASYNC);\n    effect.effect_instruction_i0 = resume => {\n      backingResume = resume;\n      if (pendingEffect) {\n        resume(pendingEffect);\n      }\n    };\n    effect.effect_instruction_i1 = blockingOn;\n    let cancelerRef = undefined;\n    let controllerRef = undefined;\n    if (this.effect_instruction_i0.length !== 1) {\n      controllerRef = new AbortController();\n      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));\n    } else {\n      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));\n    }\n    return cancelerRef || controllerRef ? onInterrupt(effect, _ => {\n      if (controllerRef) {\n        controllerRef.abort();\n      }\n      return cancelerRef ?? void_;\n    }) : effect;\n  });\n};\nexport { /** @internal */\nasync_ as async };\n/* @internal */\nexport const catchAllCause = /*#__PURE__*/dual(2, (self, f) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_FAILURE);\n  effect.effect_instruction_i0 = self;\n  effect.effect_instruction_i1 = f;\n  return effect;\n});\n/* @internal */\nexport const catchAll = /*#__PURE__*/dual(2, (self, f) => matchEffect(self, {\n  onFailure: f,\n  onSuccess: succeed\n}));\n/* @internal */\nexport const catchIf = /*#__PURE__*/dual(3, (self, predicate, f) => catchAllCause(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      return predicate(either.left) ? f(either.left) : failCause(cause);\n    case \"Right\":\n      return failCause(either.right);\n  }\n}));\n/* @internal */\nexport const catchSome = /*#__PURE__*/dual(2, (self, pf) => catchAllCause(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      return pipe(pf(either.left), Option.getOrElse(() => failCause(cause)));\n    case \"Right\":\n      return failCause(either.right);\n  }\n}));\n/* @internal */\nexport const checkInterruptible = f => withFiberRuntime((_, status) => f(runtimeFlags_.interruption(status.runtimeFlags)));\nconst originalSymbol = /*#__PURE__*/Symbol.for(\"effect/OriginalAnnotation\");\n/* @internal */\nexport const originalInstance = obj => {\n  if (hasProperty(obj, originalSymbol)) {\n    // @ts-expect-error\n    return obj[originalSymbol];\n  }\n  return obj;\n};\n/* @internal */\nexport const capture = (obj, span) => {\n  if (Option.isSome(span)) {\n    return new Proxy(obj, {\n      has(target, p) {\n        return p === internalCause.spanSymbol || p === originalSymbol || p in target;\n      },\n      get(target, p) {\n        if (p === internalCause.spanSymbol) {\n          return span.value;\n        }\n        if (p === originalSymbol) {\n          return obj;\n        }\n        // @ts-expect-error\n        return target[p];\n      }\n    });\n  }\n  return obj;\n};\n/* @internal */\nexport const die = defect => isObject(defect) && !(internalCause.spanSymbol in defect) ? withFiberRuntime(fiber => failCause(internalCause.die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(internalCause.die(defect));\n/* @internal */\nexport const dieMessage = message => failCauseSync(() => internalCause.die(new RuntimeException(message)));\n/* @internal */\nexport const dieSync = evaluate => flatMap(sync(evaluate), die);\n/* @internal */\nexport const either = self => matchEffect(self, {\n  onFailure: e => succeed(Either.left(e)),\n  onSuccess: a => succeed(Either.right(a))\n});\n/* @internal */\nexport const exit = self => matchCause(self, {\n  onFailure: exitFailCause,\n  onSuccess: exitSucceed\n});\n/* @internal */\nexport const fail = error => isObject(error) && !(internalCause.spanSymbol in error) ? withFiberRuntime(fiber => failCause(internalCause.fail(capture(error, currentSpanFromFiber(fiber))))) : failCause(internalCause.fail(error));\n/* @internal */\nexport const failSync = evaluate => flatMap(sync(evaluate), fail);\n/* @internal */\nexport const failCause = cause => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE);\n  effect.effect_instruction_i0 = cause;\n  return effect;\n};\n/* @internal */\nexport const failCauseSync = evaluate => flatMap(sync(evaluate), failCause);\n/* @internal */\nexport const fiberId = /*#__PURE__*/withFiberRuntime(state => succeed(state.id()));\n/* @internal */\nexport const fiberIdWith = f => withFiberRuntime(state => f(state.id()));\n/* @internal */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS);\n  effect.effect_instruction_i0 = self;\n  effect.effect_instruction_i1 = f;\n  return effect;\n});\n/* @internal */\nexport const andThen = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => {\n  const b = typeof f === \"function\" ? f(a) : f;\n  if (isEffect(b)) {\n    return b;\n  } else if (isPromiseLike(b)) {\n    return unsafeAsync(resume => {\n      b.then(a => resume(succeed(a)), e => resume(fail(new UnknownException(e, \"An unknown error occurred in Effect.andThen\"))));\n    });\n  }\n  return succeed(b);\n}));\n/* @internal */\nexport const step = self => {\n  const effect = new EffectPrimitive(\"OnStep\");\n  effect.effect_instruction_i0 = self;\n  return effect;\n};\n/* @internal */\nexport const flatten = self => flatMap(self, identity);\n/* @internal */\nexport const flip = self => matchEffect(self, {\n  onFailure: succeed,\n  onSuccess: fail\n});\n/* @internal */\nexport const matchCause = /*#__PURE__*/dual(2, (self, options) => matchCauseEffect(self, {\n  onFailure: cause => succeed(options.onFailure(cause)),\n  onSuccess: a => succeed(options.onSuccess(a))\n}));\n/* @internal */\nexport const matchCauseEffect = /*#__PURE__*/dual(2, (self, options) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS_AND_FAILURE);\n  effect.effect_instruction_i0 = self;\n  effect.effect_instruction_i1 = options.onFailure;\n  effect.effect_instruction_i2 = options.onSuccess;\n  return effect;\n});\n/* @internal */\nexport const matchEffect = /*#__PURE__*/dual(2, (self, options) => matchCauseEffect(self, {\n  onFailure: cause => {\n    const defects = internalCause.defects(cause);\n    if (defects.length > 0) {\n      return failCause(internalCause.electFailures(cause));\n    }\n    const failures = internalCause.failures(cause);\n    if (failures.length > 0) {\n      return options.onFailure(Chunk.unsafeHead(failures));\n    }\n    return failCause(cause);\n  },\n  onSuccess: options.onSuccess\n}));\n/* @internal */\nexport const forEachSequential = /*#__PURE__*/dual(2, (self, f) => suspend(() => {\n  const arr = Arr.fromIterable(self);\n  const ret = Arr.allocate(arr.length);\n  let i = 0;\n  return as(whileLoop({\n    while: () => i < arr.length,\n    body: () => f(arr[i], i),\n    step: b => {\n      ret[i++] = b;\n    }\n  }), ret);\n}));\n/* @internal */\nexport const forEachSequentialDiscard = /*#__PURE__*/dual(2, (self, f) => suspend(() => {\n  const arr = Arr.fromIterable(self);\n  let i = 0;\n  return whileLoop({\n    while: () => i < arr.length,\n    body: () => f(arr[i], i),\n    step: () => {\n      i++;\n    }\n  });\n}));\n/* @internal */\nexport const if_ = /*#__PURE__*/dual(args => typeof args[0] === \"boolean\" || isEffect(args[0]), (self, options) => isEffect(self) ? flatMap(self, b => b ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());\n/* @internal */\nexport const interrupt = /*#__PURE__*/flatMap(fiberId, fiberId => interruptWith(fiberId));\n/* @internal */\nexport const interruptWith = fiberId => failCause(internalCause.interrupt(fiberId));\n/* @internal */\nexport const interruptible = self => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.enable(runtimeFlags_.Interruption);\n  effect.effect_instruction_i1 = () => self;\n  return effect;\n};\n/* @internal */\nexport const interruptibleMask = f => custom(f, function () {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.enable(runtimeFlags_.Interruption);\n  effect.effect_instruction_i1 = oldFlags => runtimeFlags_.interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible)) : internalCall(() => this.effect_instruction_i0(uninterruptible));\n  return effect;\n});\n/* @internal */\nexport const intoDeferred = /*#__PURE__*/dual(2, (self, deferred) => uninterruptibleMask(restore => flatMap(exit(restore(self)), exit => deferredDone(deferred, exit))));\n/* @internal */\nexport const map = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => sync(() => f(a))));\n/* @internal */\nexport const mapBoth = /*#__PURE__*/dual(2, (self, options) => matchEffect(self, {\n  onFailure: e => failSync(() => options.onFailure(e)),\n  onSuccess: a => sync(() => options.onSuccess(a))\n}));\n/* @internal */\nexport const mapError = /*#__PURE__*/dual(2, (self, f) => matchCauseEffect(self, {\n  onFailure: cause => {\n    const either = internalCause.failureOrCause(cause);\n    switch (either._tag) {\n      case \"Left\":\n        {\n          return failSync(() => f(either.left));\n        }\n      case \"Right\":\n        {\n          return failCause(either.right);\n        }\n    }\n  },\n  onSuccess: succeed\n}));\n/* @internal */\nexport const onError = /*#__PURE__*/dual(2, (self, cleanup) => onExit(self, exit => exitIsSuccess(exit) ? void_ : cleanup(exit.effect_instruction_i0)));\n/* @internal */\nexport const onExit = /*#__PURE__*/dual(2, (self, cleanup) => uninterruptibleMask(restore => matchCauseEffect(restore(self), {\n  onFailure: cause1 => {\n    const result = exitFailCause(cause1);\n    return matchCauseEffect(cleanup(result), {\n      onFailure: cause2 => exitFailCause(internalCause.sequential(cause1, cause2)),\n      onSuccess: () => result\n    });\n  },\n  onSuccess: success => {\n    const result = exitSucceed(success);\n    return zipRight(cleanup(result), result);\n  }\n})));\n/* @internal */\nexport const onInterrupt = /*#__PURE__*/dual(2, (self, cleanup) => onExit(self, exitMatch({\n  onFailure: cause => internalCause.isInterruptedOnly(cause) ? asVoid(cleanup(internalCause.interruptors(cause))) : void_,\n  onSuccess: () => void_\n})));\n/* @internal */\nexport const orElse = /*#__PURE__*/dual(2, (self, that) => attemptOrElse(self, that, succeed));\n/* @internal */\nexport const orDie = self => orDieWith(self, identity);\n/* @internal */\nexport const orDieWith = /*#__PURE__*/dual(2, (self, f) => matchEffect(self, {\n  onFailure: e => die(f(e)),\n  onSuccess: succeed\n}));\n/* @internal */\nexport const partitionMap = Arr.partitionMap;\n/* @internal */\nexport const runtimeFlags = /*#__PURE__*/withFiberRuntime((_, status) => succeed(status.runtimeFlags));\n/* @internal */\nexport const succeed = value => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS);\n  effect.effect_instruction_i0 = value;\n  return effect;\n};\n/* @internal */\nexport const suspend = evaluate => {\n  const effect = new EffectPrimitive(OpCodes.OP_COMMIT);\n  effect.commit = evaluate;\n  return effect;\n};\n/* @internal */\nexport const sync = thunk => {\n  const effect = new EffectPrimitive(OpCodes.OP_SYNC);\n  effect.effect_instruction_i0 = thunk;\n  return effect;\n};\n/* @internal */\nexport const tap = /*#__PURE__*/dual(args => args.length === 3 || args.length === 2 && !(isObject(args[1]) && \"onlyEffect\" in args[1]), (self, f) => flatMap(self, a => {\n  const b = typeof f === \"function\" ? f(a) : f;\n  if (isEffect(b)) {\n    return as(b, a);\n  } else if (isPromiseLike(b)) {\n    return unsafeAsync(resume => {\n      b.then(_ => resume(succeed(a)), e => resume(fail(new UnknownException(e, \"An unknown error occurred in Effect.tap\"))));\n    });\n  }\n  return succeed(a);\n}));\n/* @internal */\nexport const transplant = f => withFiberRuntime(state => {\n  const scopeOverride = state.getFiberRef(currentForkScopeOverride);\n  const scope = pipe(scopeOverride, Option.getOrElse(() => state.scope()));\n  return f(fiberRefLocally(currentForkScopeOverride, Option.some(scope)));\n});\n/* @internal */\nexport const attemptOrElse = /*#__PURE__*/dual(3, (self, that, onSuccess) => matchCauseEffect(self, {\n  onFailure: cause => {\n    const defects = internalCause.defects(cause);\n    if (defects.length > 0) {\n      return failCause(Option.getOrThrow(internalCause.keepDefectsAndElectFailures(cause)));\n    }\n    return that();\n  },\n  onSuccess\n}));\n/* @internal */\nexport const uninterruptible = self => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.disable(runtimeFlags_.Interruption);\n  effect.effect_instruction_i1 = () => self;\n  return effect;\n};\n/* @internal */\nexport const uninterruptibleMask = f => custom(f, function () {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.disable(runtimeFlags_.Interruption);\n  effect.effect_instruction_i1 = oldFlags => runtimeFlags_.interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible)) : internalCall(() => this.effect_instruction_i0(uninterruptible));\n  return effect;\n});\nconst void_ = /*#__PURE__*/succeed(void 0);\nexport { /* @internal */\nvoid_ as void };\n/* @internal */\nexport const updateRuntimeFlags = patch => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.effect_instruction_i0 = patch;\n  effect.effect_instruction_i1 = void 0;\n  return effect;\n};\n/* @internal */\nexport const whenEffect = /*#__PURE__*/dual(2, (self, condition) => flatMap(condition, b => {\n  if (b) {\n    return pipe(self, map(Option.some));\n  }\n  return succeed(Option.none());\n}));\n/* @internal */\nexport const whileLoop = options => {\n  const effect = new EffectPrimitive(OpCodes.OP_WHILE);\n  effect.effect_instruction_i0 = options.while;\n  effect.effect_instruction_i1 = options.body;\n  effect.effect_instruction_i2 = options.step;\n  return effect;\n};\n/* @internal */\nexport const fromIterator = iterator => suspend(() => {\n  const effect = new EffectPrimitive(OpCodes.OP_ITERATOR);\n  effect.effect_instruction_i0 = iterator();\n  return effect;\n});\n/* @internal */\nexport const gen = function () {\n  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);\n  return fromIterator(() => f(pipe));\n};\n/** @internal */\nexport const fnUntraced = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function (...args) {\n  return fromIterator(() => body.apply(this, args));\n} : function (...args) {\n  let effect = fromIterator(() => body.apply(this, args));\n  for (const x of pipeables) {\n    effect = x(effect, ...args);\n  }\n  return effect;\n}, \"length\", {\n  value: body.length,\n  configurable: true\n});\n/* @internal */\nexport const withConcurrency = /*#__PURE__*/dual(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency));\n/* @internal */\nexport const withRequestBatching = /*#__PURE__*/dual(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching));\n/* @internal */\nexport const withRuntimeFlags = /*#__PURE__*/dual(2, (self, update) => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.effect_instruction_i0 = update;\n  effect.effect_instruction_i1 = () => self;\n  return effect;\n});\n/** @internal */\nexport const withTracerEnabled = /*#__PURE__*/dual(2, (effect, enabled) => fiberRefLocally(effect, currentTracerEnabled, enabled));\n/** @internal */\nexport const withTracerTiming = /*#__PURE__*/dual(2, (effect, enabled) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled));\n/* @internal */\nexport const yieldNow = options => {\n  const effect = new EffectPrimitive(OpCodes.OP_YIELD);\n  return typeof options?.priority !== \"undefined\" ? withSchedulingPriority(effect, options.priority) : effect;\n};\n/* @internal */\nexport const zip = /*#__PURE__*/dual(2, (self, that) => flatMap(self, a => map(that, b => [a, b])));\n/* @internal */\nexport const zipFlatten = /*#__PURE__*/dual(2, (self, that) => flatMap(self, a => map(that, b => [...a, b])));\n/* @internal */\nexport const zipLeft = /*#__PURE__*/dual(2, (self, that) => flatMap(self, a => as(that, a)));\n/* @internal */\nexport const zipRight = /*#__PURE__*/dual(2, (self, that) => flatMap(self, () => that));\n/* @internal */\nexport const zipWith = /*#__PURE__*/dual(3, (self, that, f) => flatMap(self, a => map(that, b => f(a, b))));\n/* @internal */\nexport const never = /*#__PURE__*/asyncInterrupt(() => {\n  const interval = setInterval(() => {\n    //\n  }, 2 ** 31 - 1);\n  return sync(() => clearInterval(interval));\n});\n// -----------------------------------------------------------------------------\n// Fiber\n// -----------------------------------------------------------------------------\n/* @internal */\nexport const interruptFiber = self => flatMap(fiberId, fiberId => pipe(self, interruptAsFiber(fiberId)));\n/* @internal */\nexport const interruptAsFiber = /*#__PURE__*/dual(2, (self, fiberId) => flatMap(self.interruptAsFork(fiberId), () => self.await));\n// -----------------------------------------------------------------------------\n// LogLevel\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const logLevelAll = {\n  _tag: \"All\",\n  syslog: 0,\n  label: \"ALL\",\n  ordinal: Number.MIN_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const logLevelFatal = {\n  _tag: \"Fatal\",\n  syslog: 2,\n  label: \"FATAL\",\n  ordinal: 50000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const logLevelError = {\n  _tag: \"Error\",\n  syslog: 3,\n  label: \"ERROR\",\n  ordinal: 40000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const logLevelWarning = {\n  _tag: \"Warning\",\n  syslog: 4,\n  label: \"WARN\",\n  ordinal: 30000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const logLevelInfo = {\n  _tag: \"Info\",\n  syslog: 6,\n  label: \"INFO\",\n  ordinal: 20000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const logLevelDebug = {\n  _tag: \"Debug\",\n  syslog: 7,\n  label: \"DEBUG\",\n  ordinal: 10000,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const logLevelTrace = {\n  _tag: \"Trace\",\n  syslog: 7,\n  label: \"TRACE\",\n  ordinal: 0,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const logLevelNone = {\n  _tag: \"None\",\n  syslog: 7,\n  label: \"OFF\",\n  ordinal: Number.MAX_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];\n// -----------------------------------------------------------------------------\n// FiberRef\n// -----------------------------------------------------------------------------\n/** @internal */\nconst FiberRefSymbolKey = \"effect/FiberRef\";\n/** @internal */\nexport const FiberRefTypeId = /*#__PURE__*/Symbol.for(FiberRefSymbolKey);\nconst fiberRefVariance = {\n  /* c8 ignore next */\n  _A: _ => _\n};\n/* @internal */\nexport const fiberRefGet = self => withFiberRuntime(fiber => exitSucceed(fiber.getFiberRef(self)));\n/* @internal */\nexport const fiberRefGetAndSet = /*#__PURE__*/dual(2, (self, value) => fiberRefModify(self, v => [v, value]));\n/* @internal */\nexport const fiberRefGetAndUpdate = /*#__PURE__*/dual(2, (self, f) => fiberRefModify(self, v => [v, f(v)]));\n/* @internal */\nexport const fiberRefGetAndUpdateSome = /*#__PURE__*/dual(2, (self, pf) => fiberRefModify(self, v => [v, Option.getOrElse(pf(v), () => v)]));\n/* @internal */\nexport const fiberRefGetWith = /*#__PURE__*/dual(2, (self, f) => flatMap(fiberRefGet(self), f));\n/* @internal */\nexport const fiberRefSet = /*#__PURE__*/dual(2, (self, value) => fiberRefModify(self, () => [void 0, value]));\n/* @internal */\nexport const fiberRefDelete = self => withFiberRuntime(state => {\n  state.unsafeDeleteFiberRef(self);\n  return void_;\n});\n/* @internal */\nexport const fiberRefReset = self => fiberRefSet(self, self.initial);\n/* @internal */\nexport const fiberRefModify = /*#__PURE__*/dual(2, (self, f) => withFiberRuntime(state => {\n  const [b, a] = f(state.getFiberRef(self));\n  state.setFiberRef(self, a);\n  return succeed(b);\n}));\n/* @internal */\nexport const fiberRefModifySome = (self, def, f) => fiberRefModify(self, v => Option.getOrElse(f(v), () => [def, v]));\n/* @internal */\nexport const fiberRefUpdate = /*#__PURE__*/dual(2, (self, f) => fiberRefModify(self, v => [void 0, f(v)]));\n/* @internal */\nexport const fiberRefUpdateSome = /*#__PURE__*/dual(2, (self, pf) => fiberRefModify(self, v => [void 0, Option.getOrElse(pf(v), () => v)]));\n/* @internal */\nexport const fiberRefUpdateAndGet = /*#__PURE__*/dual(2, (self, f) => fiberRefModify(self, v => {\n  const result = f(v);\n  return [result, result];\n}));\n/* @internal */\nexport const fiberRefUpdateSomeAndGet = /*#__PURE__*/dual(2, (self, pf) => fiberRefModify(self, v => {\n  const result = Option.getOrElse(pf(v), () => v);\n  return [result, result];\n}));\n// circular\n/** @internal */\nconst RequestResolverSymbolKey = \"effect/RequestResolver\";\n/** @internal */\nexport const RequestResolverTypeId = /*#__PURE__*/Symbol.for(RequestResolverSymbolKey);\nconst requestResolverVariance = {\n  /* c8 ignore next */\n  _A: _ => _,\n  /* c8 ignore next */\n  _R: _ => _\n};\n/** @internal */\nexport class RequestResolverImpl {\n  runAll;\n  target;\n  [RequestResolverTypeId] = requestResolverVariance;\n  constructor(runAll, target) {\n    this.runAll = runAll;\n    this.target = target;\n  }\n  [Hash.symbol]() {\n    return Hash.cached(this, this.target ? Hash.hash(this.target) : Hash.random(this));\n  }\n  [Equal.symbol](that) {\n    return this.target ? isRequestResolver(that) && Equal.equals(this.target, that.target) : this === that;\n  }\n  identified(...ids) {\n    return new RequestResolverImpl(this.runAll, Chunk.fromIterable(ids));\n  }\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n}\n/** @internal */\nexport const isRequestResolver = u => hasProperty(u, RequestResolverTypeId);\n// end\n/** @internal */\nexport const resolverLocally = /*#__PURE__*/dual(3, (use, self, value) => new RequestResolverImpl(requests => fiberRefLocally(use.runAll(requests), self, value), Chunk.make(\"Locally\", use, self, value)));\n/** @internal */\nexport const requestBlockLocally = (self, ref, value) => blockedRequests_.reduce(self, LocallyReducer(ref, value));\nconst LocallyReducer = (ref, value) => ({\n  emptyCase: () => blockedRequests_.empty,\n  parCase: (left, right) => blockedRequests_.par(left, right),\n  seqCase: (left, right) => blockedRequests_.seq(left, right),\n  singleCase: (dataSource, blockedRequest) => blockedRequests_.single(resolverLocally(dataSource, ref, value), blockedRequest)\n});\n/* @internal */\nexport const fiberRefLocally = /*#__PURE__*/dual(3, (use, self, value) => acquireUseRelease(zipLeft(fiberRefGet(self), fiberRefSet(self, value)), () => use, oldValue => fiberRefSet(self, oldValue)));\n/* @internal */\nexport const fiberRefLocallyWith = /*#__PURE__*/dual(3, (use, self, f) => fiberRefGetWith(self, a => fiberRefLocally(use, self, f(a))));\n/** @internal */\nexport const fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {\n  differ: internalDiffer.update(),\n  fork: options?.fork ?? identity,\n  join: options?.join\n});\n/** @internal */\nexport const fiberRefUnsafeMakeHashSet = initial => {\n  const differ = internalDiffer.hashSet();\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  });\n};\n/** @internal */\nexport const fiberRefUnsafeMakeReadonlyArray = initial => {\n  const differ = internalDiffer.readonlyArray(internalDiffer.update());\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  });\n};\n/** @internal */\nexport const fiberRefUnsafeMakeContext = initial => {\n  const differ = internalDiffer.environment();\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  });\n};\n/** @internal */\nexport const fiberRefUnsafeMakePatch = (initial, options) => {\n  const _fiberRef = {\n    ...CommitPrototype,\n    [FiberRefTypeId]: fiberRefVariance,\n    initial,\n    commit() {\n      return fiberRefGet(this);\n    },\n    diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),\n    combine: (first, second) => options.differ.combine(first, second),\n    patch: patch => oldValue => options.differ.patch(patch, oldValue),\n    fork: options.fork,\n    join: options.join ?? ((_, n) => n)\n  };\n  return _fiberRef;\n};\n/** @internal */\nexport const fiberRefUnsafeMakeRuntimeFlags = initial => fiberRefUnsafeMakePatch(initial, {\n  differ: runtimeFlags_.differ,\n  fork: runtimeFlags_.differ.empty\n});\n/** @internal */\nexport const currentContext = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentContext\"), () => fiberRefUnsafeMakeContext(Context.empty()));\n/** @internal */\nexport const currentSchedulingPriority = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentSchedulingPriority\"), () => fiberRefUnsafeMake(0));\n/** @internal */\nexport const currentMaxOpsBeforeYield = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentMaxOpsBeforeYield\"), () => fiberRefUnsafeMake(2048));\n/** @internal */\nexport const currentLogAnnotations = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentLogAnnotation\"), () => fiberRefUnsafeMake(HashMap.empty()));\n/** @internal */\nexport const currentLogLevel = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentLogLevel\"), () => fiberRefUnsafeMake(logLevelInfo));\n/** @internal */\nexport const currentLogSpan = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentLogSpan\"), () => fiberRefUnsafeMake(List.empty()));\n/** @internal */\nexport const withSchedulingPriority = /*#__PURE__*/dual(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));\n/** @internal */\nexport const withMaxOpsBeforeYield = /*#__PURE__*/dual(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler));\n/** @internal */\nexport const currentConcurrency = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentConcurrency\"), () => fiberRefUnsafeMake(\"unbounded\"));\n/**\n * @internal\n */\nexport const currentRequestBatching = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentRequestBatching\"), () => fiberRefUnsafeMake(true));\n/** @internal */\nexport const currentUnhandledErrorLogLevel = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentUnhandledErrorLogLevel\"), () => fiberRefUnsafeMake(Option.some(logLevelDebug)));\n/** @internal */\nexport const withUnhandledErrorLogLevel = /*#__PURE__*/dual(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));\n/** @internal */\nexport const currentMetricLabels = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentMetricLabels\"), () => fiberRefUnsafeMakeReadonlyArray(Arr.empty()));\n/* @internal */\nexport const metricLabels = /*#__PURE__*/fiberRefGet(currentMetricLabels);\n/** @internal */\nexport const currentForkScopeOverride = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentForkScopeOverride\"), () => fiberRefUnsafeMake(Option.none(), {\n  fork: () => Option.none(),\n  join: (parent, _) => parent\n}));\n/** @internal */\nexport const currentInterruptedCause = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentInterruptedCause\"), () => fiberRefUnsafeMake(internalCause.empty, {\n  fork: () => internalCause.empty,\n  join: (parent, _) => parent\n}));\n/** @internal */\nexport const currentTracerEnabled = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentTracerEnabled\"), () => fiberRefUnsafeMake(true));\n/** @internal */\nexport const currentTracerTimingEnabled = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentTracerTiming\"), () => fiberRefUnsafeMake(true));\n/** @internal */\nexport const currentTracerSpanAnnotations = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentTracerSpanAnnotations\"), () => fiberRefUnsafeMake(HashMap.empty()));\n/** @internal */\nexport const currentTracerSpanLinks = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/FiberRef/currentTracerSpanLinks\"), () => fiberRefUnsafeMake(Chunk.empty()));\n// -----------------------------------------------------------------------------\n// Scope\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const ScopeTypeId = /*#__PURE__*/Symbol.for(\"effect/Scope\");\n/** @internal */\nexport const CloseableScopeTypeId = /*#__PURE__*/Symbol.for(\"effect/CloseableScope\");\n/* @internal */\nexport const scopeAddFinalizer = (self, finalizer) => self.addFinalizer(() => asVoid(finalizer));\n/* @internal */\nexport const scopeAddFinalizerExit = (self, finalizer) => self.addFinalizer(finalizer);\n/* @internal */\nexport const scopeClose = (self, exit) => self.close(exit);\n/* @internal */\nexport const scopeFork = (self, strategy) => self.fork(strategy);\n// -----------------------------------------------------------------------------\n// Cause\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const causeSquash = self => {\n  return causeSquashWith(identity)(self);\n};\n/** @internal */\nexport const causeSquashWith = /*#__PURE__*/dual(2, (self, f) => {\n  const option = pipe(self, internalCause.failureOption, Option.map(f));\n  switch (option._tag) {\n    case \"None\":\n      {\n        return pipe(internalCause.defects(self), Chunk.head, Option.match({\n          onNone: () => {\n            const interrupts = Arr.fromIterable(internalCause.interruptors(self)).flatMap(fiberId => Arr.fromIterable(FiberId.ids(fiberId)).map(id => `#${id}`));\n            return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(\", \")}` : void 0);\n          },\n          onSome: identity\n        }));\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n});\n// -----------------------------------------------------------------------------\n// Errors\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const YieldableError = /*#__PURE__*/function () {\n  class YieldableError extends globalThis.Error {\n    commit() {\n      return fail(this);\n    }\n    toJSON() {\n      const obj = {\n        ...this\n      };\n      if (this.message) obj.message = this.message;\n      if (this.cause) obj.cause = this.cause;\n      return obj;\n    }\n    [NodeInspectSymbol]() {\n      if (this.toString !== globalThis.Error.prototype.toString) {\n        return this.stack ? `${this.toString()}\\n${this.stack.split(\"\\n\").slice(1).join(\"\\n\")}` : this.toString();\n      } else if (\"Bun\" in globalThis) {\n        return internalCause.pretty(internalCause.fail(this), {\n          renderErrorCause: true\n        });\n      }\n      return this;\n    }\n  }\n  Object.assign(YieldableError.prototype, StructuralCommitPrototype);\n  return YieldableError;\n}();\nconst makeException = (proto, tag) => {\n  class Base extends YieldableError {\n    _tag = tag;\n  }\n  Object.assign(Base.prototype, proto);\n  Base.prototype.name = tag;\n  return Base;\n};\n/** @internal */\nexport const RuntimeExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/RuntimeException\");\n/** @internal */\nexport const RuntimeException = /*#__PURE__*/makeException({\n  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId\n}, \"RuntimeException\");\n/** @internal */\nexport const isRuntimeException = u => hasProperty(u, RuntimeExceptionTypeId);\n/** @internal */\nexport const InterruptedExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/InterruptedException\");\n/** @internal */\nexport const InterruptedException = /*#__PURE__*/makeException({\n  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId\n}, \"InterruptedException\");\n/** @internal */\nexport const isInterruptedException = u => hasProperty(u, InterruptedExceptionTypeId);\n/** @internal */\nexport const IllegalArgumentExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/IllegalArgument\");\n/** @internal */\nexport const IllegalArgumentException = /*#__PURE__*/makeException({\n  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId\n}, \"IllegalArgumentException\");\n/** @internal */\nexport const isIllegalArgumentException = u => hasProperty(u, IllegalArgumentExceptionTypeId);\n/** @internal */\nexport const NoSuchElementExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/NoSuchElement\");\n/** @internal */\nexport const NoSuchElementException = /*#__PURE__*/makeException({\n  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId\n}, \"NoSuchElementException\");\n/** @internal */\nexport const isNoSuchElementException = u => hasProperty(u, NoSuchElementExceptionTypeId);\n/** @internal */\nexport const InvalidPubSubCapacityExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/InvalidPubSubCapacityException\");\n/** @internal */\nexport const InvalidPubSubCapacityException = /*#__PURE__*/makeException({\n  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId\n}, \"InvalidPubSubCapacityException\");\n/** @internal */\nexport const ExceededCapacityExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/ExceededCapacityException\");\n/** @internal */\nexport const ExceededCapacityException = /*#__PURE__*/makeException({\n  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId\n}, \"ExceededCapacityException\");\n/** @internal */\nexport const isExceededCapacityException = u => hasProperty(u, ExceededCapacityExceptionTypeId);\n/** @internal */\nexport const isInvalidCapacityError = u => hasProperty(u, InvalidPubSubCapacityExceptionTypeId);\n/** @internal */\nexport const TimeoutExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/Timeout\");\n/** @internal */\nexport const TimeoutException = /*#__PURE__*/makeException({\n  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId\n}, \"TimeoutException\");\n/** @internal */\nexport const timeoutExceptionFromDuration = duration => new TimeoutException(`Operation timed out before the specified duration of '${Duration.format(duration)}' elapsed`);\n/** @internal */\nexport const isTimeoutException = u => hasProperty(u, TimeoutExceptionTypeId);\n/** @internal */\nexport const UnknownExceptionTypeId = /*#__PURE__*/Symbol.for(\"effect/Cause/errors/UnknownException\");\n/** @internal */\nexport const UnknownException = /*#__PURE__*/function () {\n  class UnknownException extends YieldableError {\n    _tag = \"UnknownException\";\n    error;\n    constructor(cause, message) {\n      super(message ?? \"An unknown error occurred\", {\n        cause\n      });\n      this.error = cause;\n    }\n  }\n  Object.assign(UnknownException.prototype, {\n    [UnknownExceptionTypeId]: UnknownExceptionTypeId,\n    name: \"UnknownException\"\n  });\n  return UnknownException;\n}();\n/** @internal */\nexport const isUnknownException = u => hasProperty(u, UnknownExceptionTypeId);\n// -----------------------------------------------------------------------------\n// Exit\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const exitIsExit = u => isEffect(u) && \"_tag\" in u && (u._tag === \"Success\" || u._tag === \"Failure\");\n/** @internal */\nexport const exitIsFailure = self => self._tag === \"Failure\";\n/** @internal */\nexport const exitIsSuccess = self => self._tag === \"Success\";\n/** @internal */\nexport const exitIsInterrupted = self => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return internalCause.isInterrupted(self.effect_instruction_i0);\n    case OpCodes.OP_SUCCESS:\n      return false;\n  }\n};\n/** @internal */\nexport const exitAs = /*#__PURE__*/dual(2, (self, value) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return exitFailCause(self.effect_instruction_i0);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return exitSucceed(value);\n      }\n  }\n});\n/** @internal */\nexport const exitAsVoid = self => exitAs(self, void 0);\n/** @internal */\nexport const exitCauseOption = self => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return Option.some(self.effect_instruction_i0);\n    case OpCodes.OP_SUCCESS:\n      return Option.none();\n  }\n};\n/** @internal */\nexport const exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? internalCause.parallel : internalCause.sequential);\n/** @internal */\nexport const exitDie = defect => exitFailCause(internalCause.die(defect));\n/** @internal */\nexport const exitExists = /*#__PURE__*/dual(2, (self, refinement) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return false;\n    case OpCodes.OP_SUCCESS:\n      return refinement(self.effect_instruction_i0);\n  }\n});\n/** @internal */\nexport const exitFail = error => exitFailCause(internalCause.fail(error));\n/** @internal */\nexport const exitFailCause = cause => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE);\n  effect.effect_instruction_i0 = cause;\n  return effect;\n};\n/** @internal */\nexport const exitFlatMap = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return exitFailCause(self.effect_instruction_i0);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return f(self.effect_instruction_i0);\n      }\n  }\n});\n/** @internal */\nexport const exitFlatMapEffect = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return succeed(exitFailCause(self.effect_instruction_i0));\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return f(self.effect_instruction_i0);\n      }\n  }\n});\n/** @internal */\nexport const exitFlatten = self => pipe(self, exitFlatMap(identity));\n/** @internal */\nexport const exitForEachEffect = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return succeed(exitFailCause(self.effect_instruction_i0));\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return exit(f(self.effect_instruction_i0));\n      }\n  }\n});\n/** @internal */\nexport const exitFromEither = either => {\n  switch (either._tag) {\n    case \"Left\":\n      return exitFail(either.left);\n    case \"Right\":\n      return exitSucceed(either.right);\n  }\n};\n/** @internal */\nexport const exitFromOption = option => {\n  switch (option._tag) {\n    case \"None\":\n      return exitFail(void 0);\n    case \"Some\":\n      return exitSucceed(option.value);\n  }\n};\n/** @internal */\nexport const exitGetOrElse = /*#__PURE__*/dual(2, (self, orElse) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return orElse(self.effect_instruction_i0);\n    case OpCodes.OP_SUCCESS:\n      return self.effect_instruction_i0;\n  }\n});\n/** @internal */\nexport const exitInterrupt = fiberId => exitFailCause(internalCause.interrupt(fiberId));\n/** @internal */\nexport const exitMap = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(self.effect_instruction_i0);\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(f(self.effect_instruction_i0));\n  }\n});\n/** @internal */\nexport const exitMapBoth = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(pipe(self.effect_instruction_i0, internalCause.map(onFailure)));\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(onSuccess(self.effect_instruction_i0));\n  }\n});\n/** @internal */\nexport const exitMapError = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(pipe(self.effect_instruction_i0, internalCause.map(f)));\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(self.effect_instruction_i0);\n  }\n});\n/** @internal */\nexport const exitMapErrorCause = /*#__PURE__*/dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(f(self.effect_instruction_i0));\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(self.effect_instruction_i0);\n  }\n});\n/** @internal */\nexport const exitMatch = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return onFailure(self.effect_instruction_i0);\n    case OpCodes.OP_SUCCESS:\n      return onSuccess(self.effect_instruction_i0);\n  }\n});\n/** @internal */\nexport const exitMatchEffect = /*#__PURE__*/dual(2, (self, {\n  onFailure,\n  onSuccess\n}) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return onFailure(self.effect_instruction_i0);\n    case OpCodes.OP_SUCCESS:\n      return onSuccess(self.effect_instruction_i0);\n  }\n});\n/** @internal */\nexport const exitSucceed = value => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS);\n  effect.effect_instruction_i0 = value;\n  return effect;\n};\n/** @internal */\nexport const exitVoid = /*#__PURE__*/exitSucceed(void 0);\n/** @internal */\nexport const exitZip = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (a, a2) => [a, a2],\n  onFailure: internalCause.sequential\n}));\n/** @internal */\nexport const exitZipLeft = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (a, _) => a,\n  onFailure: internalCause.sequential\n}));\n/** @internal */\nexport const exitZipRight = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (_, a2) => a2,\n  onFailure: internalCause.sequential\n}));\n/** @internal */\nexport const exitZipPar = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (a, a2) => [a, a2],\n  onFailure: internalCause.parallel\n}));\n/** @internal */\nexport const exitZipParLeft = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (a, _) => a,\n  onFailure: internalCause.parallel\n}));\n/** @internal */\nexport const exitZipParRight = /*#__PURE__*/dual(2, (self, that) => exitZipWith(self, that, {\n  onSuccess: (_, a2) => a2,\n  onFailure: internalCause.parallel\n}));\n/** @internal */\nexport const exitZipWith = /*#__PURE__*/dual(3, (self, that, {\n  onFailure,\n  onSuccess\n}) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        switch (that._tag) {\n          case OpCodes.OP_SUCCESS:\n            return exitFailCause(self.effect_instruction_i0);\n          case OpCodes.OP_FAILURE:\n            {\n              return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));\n            }\n        }\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        switch (that._tag) {\n          case OpCodes.OP_SUCCESS:\n            return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));\n          case OpCodes.OP_FAILURE:\n            return exitFailCause(that.effect_instruction_i0);\n        }\n      }\n  }\n});\nconst exitCollectAllInternal = (exits, combineCauses) => {\n  const list = Chunk.fromIterable(exits);\n  if (!Chunk.isNonEmpty(list)) {\n    return Option.none();\n  }\n  return pipe(Chunk.tailNonEmpty(list), Arr.reduce(pipe(Chunk.headNonEmpty(list), exitMap(Chunk.of)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {\n    onSuccess: (list, value) => pipe(list, Chunk.prepend(value)),\n    onFailure: combineCauses\n  }))), exitMap(Chunk.reverse), exitMap(chunk => Chunk.toReadonlyArray(chunk)), Option.some);\n};\n// -----------------------------------------------------------------------------\n// Deferred\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const deferredUnsafeMake = fiberId => {\n  const _deferred = {\n    ...CommitPrototype,\n    [deferred.DeferredTypeId]: deferred.deferredVariance,\n    state: MutableRef.make(deferred.pending([])),\n    commit() {\n      return deferredAwait(this);\n    },\n    blockingOn: fiberId\n  };\n  return _deferred;\n};\n/* @internal */\nexport const deferredMake = () => flatMap(fiberId, id => deferredMakeAs(id));\n/* @internal */\nexport const deferredMakeAs = fiberId => sync(() => deferredUnsafeMake(fiberId));\n/* @internal */\nexport const deferredAwait = self => asyncInterrupt(resume => {\n  const state = MutableRef.get(self.state);\n  switch (state._tag) {\n    case DeferredOpCodes.OP_STATE_DONE:\n      {\n        return resume(state.effect);\n      }\n    case DeferredOpCodes.OP_STATE_PENDING:\n      {\n        // we can push here as the internal state is mutable\n        state.joiners.push(resume);\n        return deferredInterruptJoiner(self, resume);\n      }\n  }\n}, self.blockingOn);\n/* @internal */\nexport const deferredComplete = /*#__PURE__*/dual(2, (self, effect) => intoDeferred(effect, self));\n/* @internal */\nexport const deferredCompleteWith = /*#__PURE__*/dual(2, (self, effect) => sync(() => {\n  const state = MutableRef.get(self.state);\n  switch (state._tag) {\n    case DeferredOpCodes.OP_STATE_DONE:\n      {\n        return false;\n      }\n    case DeferredOpCodes.OP_STATE_PENDING:\n      {\n        MutableRef.set(self.state, deferred.done(effect));\n        for (let i = 0, len = state.joiners.length; i < len; i++) {\n          state.joiners[i](effect);\n        }\n        return true;\n      }\n  }\n}));\n/* @internal */\nexport const deferredDone = /*#__PURE__*/dual(2, (self, exit) => deferredCompleteWith(self, exit));\n/* @internal */\nexport const deferredFail = /*#__PURE__*/dual(2, (self, error) => deferredCompleteWith(self, fail(error)));\n/* @internal */\nexport const deferredFailSync = /*#__PURE__*/dual(2, (self, evaluate) => deferredCompleteWith(self, failSync(evaluate)));\n/* @internal */\nexport const deferredFailCause = /*#__PURE__*/dual(2, (self, cause) => deferredCompleteWith(self, failCause(cause)));\n/* @internal */\nexport const deferredFailCauseSync = /*#__PURE__*/dual(2, (self, evaluate) => deferredCompleteWith(self, failCauseSync(evaluate)));\n/* @internal */\nexport const deferredDie = /*#__PURE__*/dual(2, (self, defect) => deferredCompleteWith(self, die(defect)));\n/* @internal */\nexport const deferredDieSync = /*#__PURE__*/dual(2, (self, evaluate) => deferredCompleteWith(self, dieSync(evaluate)));\n/* @internal */\nexport const deferredInterrupt = self => flatMap(fiberId, fiberId => deferredCompleteWith(self, interruptWith(fiberId)));\n/* @internal */\nexport const deferredInterruptWith = /*#__PURE__*/dual(2, (self, fiberId) => deferredCompleteWith(self, interruptWith(fiberId)));\n/* @internal */\nexport const deferredIsDone = self => sync(() => MutableRef.get(self.state)._tag === DeferredOpCodes.OP_STATE_DONE);\n/* @internal */\nexport const deferredPoll = self => sync(() => {\n  const state = MutableRef.get(self.state);\n  switch (state._tag) {\n    case DeferredOpCodes.OP_STATE_DONE:\n      {\n        return Option.some(state.effect);\n      }\n    case DeferredOpCodes.OP_STATE_PENDING:\n      {\n        return Option.none();\n      }\n  }\n});\n/* @internal */\nexport const deferredSucceed = /*#__PURE__*/dual(2, (self, value) => deferredCompleteWith(self, succeed(value)));\n/* @internal */\nexport const deferredSync = /*#__PURE__*/dual(2, (self, evaluate) => deferredCompleteWith(self, sync(evaluate)));\n/** @internal */\nexport const deferredUnsafeDone = (self, effect) => {\n  const state = MutableRef.get(self.state);\n  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n    MutableRef.set(self.state, deferred.done(effect));\n    for (let i = 0, len = state.joiners.length; i < len; i++) {\n      state.joiners[i](effect);\n    }\n  }\n};\nconst deferredInterruptJoiner = (self, joiner) => sync(() => {\n  const state = MutableRef.get(self.state);\n  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n    const index = state.joiners.indexOf(joiner);\n    if (index >= 0) {\n      // we can splice here as the internal state is mutable\n      state.joiners.splice(index, 1);\n    }\n  }\n});\n// -----------------------------------------------------------------------------\n// Context\n// -----------------------------------------------------------------------------\nconst constContext = /*#__PURE__*/withFiberRuntime(fiber => exitSucceed(fiber.currentContext));\n/* @internal */\nexport const context = () => constContext;\n/* @internal */\nexport const contextWith = f => map(context(), f);\n/* @internal */\nexport const contextWithEffect = f => flatMap(context(), f);\n/* @internal */\nexport const provideContext = /*#__PURE__*/dual(2, (self, context) => fiberRefLocally(currentContext, context)(self));\n/* @internal */\nexport const provideSomeContext = /*#__PURE__*/dual(2, (self, context) => fiberRefLocallyWith(currentContext, parent => Context.merge(parent, context))(self));\n/* @internal */\nexport const mapInputContext = /*#__PURE__*/dual(2, (self, f) => contextWithEffect(context => provideContext(self, f(context))));\n// -----------------------------------------------------------------------------\n// Filtering\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const filterEffectOrElse = /*#__PURE__*/dual(2, (self, options) => flatMap(self, a => flatMap(options.predicate(a), pass => pass ? succeed(a) : options.orElse(a))));\n/** @internal */\nexport const filterEffectOrFail = /*#__PURE__*/dual(2, (self, options) => filterEffectOrElse(self, {\n  predicate: options.predicate,\n  orElse: a => fail(options.orFailWith(a))\n}));\n// -----------------------------------------------------------------------------\n// Tracing\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const currentSpanFromFiber = fiber => {\n  const span = fiber.currentSpan;\n  return span !== undefined && span._tag === \"Span\" ? Option.some(span) : Option.none();\n};\nconst NoopSpanProto = {\n  _tag: \"Span\",\n  spanId: \"noop\",\n  traceId: \"noop\",\n  sampled: false,\n  status: {\n    _tag: \"Ended\",\n    startTime: /*#__PURE__*/BigInt(0),\n    endTime: /*#__PURE__*/BigInt(0),\n    exit: exitVoid\n  },\n  attributes: /*#__PURE__*/new Map(),\n  links: [],\n  kind: \"internal\",\n  attribute() {},\n  event() {},\n  end() {}\n};\n/** @internal */\nexport const noopSpan = options => Object.assign(Object.create(NoopSpanProto), options);\n//# sourceMappingURL=core.js.map","import * as Context from \"../Context.js\";\nimport * as Duration from \"../Duration.js\";\nimport { constFalse } from \"../Function.js\";\nimport * as core from \"./core.js\";\n/** @internal */\nconst ClockSymbolKey = \"effect/Clock\";\n/** @internal */\nexport const ClockTypeId = /*#__PURE__*/Symbol.for(ClockSymbolKey);\n/** @internal */\nexport const clockTag = /*#__PURE__*/Context.GenericTag(\"effect/Clock\");\n/** @internal */\nexport const MAX_TIMER_MILLIS = 2 ** 31 - 1;\n/** @internal */\nexport const globalClockScheduler = {\n  unsafeSchedule(task, duration) {\n    const millis = Duration.toMillis(duration);\n    // If the duration is greater than the value allowable by the JS timer\n    // functions, treat the value as an infinite duration\n    if (millis > MAX_TIMER_MILLIS) {\n      return constFalse;\n    }\n    let completed = false;\n    const handle = setTimeout(() => {\n      completed = true;\n      task();\n    }, millis);\n    return () => {\n      clearTimeout(handle);\n      return !completed;\n    };\n  }\n};\nconst performanceNowNanos = /*#__PURE__*/function () {\n  const bigint1e6 = /*#__PURE__*/BigInt(1_000_000);\n  if (typeof performance === \"undefined\") {\n    return () => BigInt(Date.now()) * bigint1e6;\n  } else if (typeof performance.timeOrigin === \"number\" && performance.timeOrigin === 0) {\n    return () => BigInt(Math.round(performance.now() * 1_000_000));\n  }\n  const origin = /*#__PURE__*/BigInt( /*#__PURE__*/Date.now()) * bigint1e6 - /*#__PURE__*/BigInt( /*#__PURE__*/Math.round( /*#__PURE__*/performance.now() * 1_000_000));\n  return () => origin + BigInt(Math.round(performance.now() * 1_000_000));\n}();\nconst processOrPerformanceNow = /*#__PURE__*/function () {\n  const processHrtime = typeof process === \"object\" && \"hrtime\" in process && typeof process.hrtime.bigint === \"function\" ? process.hrtime : undefined;\n  if (!processHrtime) {\n    return performanceNowNanos;\n  }\n  const origin = /*#__PURE__*/performanceNowNanos() - /*#__PURE__*/processHrtime.bigint();\n  return () => origin + processHrtime.bigint();\n}();\n/** @internal */\nclass ClockImpl {\n  [ClockTypeId] = ClockTypeId;\n  unsafeCurrentTimeMillis() {\n    return Date.now();\n  }\n  unsafeCurrentTimeNanos() {\n    return processOrPerformanceNow();\n  }\n  currentTimeMillis = /*#__PURE__*/core.sync(() => this.unsafeCurrentTimeMillis());\n  currentTimeNanos = /*#__PURE__*/core.sync(() => this.unsafeCurrentTimeNanos());\n  scheduler() {\n    return core.succeed(globalClockScheduler);\n  }\n  sleep(duration) {\n    return core.async(resume => {\n      const canceler = globalClockScheduler.unsafeSchedule(() => resume(core.void), duration);\n      return core.asVoid(core.sync(canceler));\n    });\n  }\n}\n/** @internal */\nexport const make = () => new ClockImpl();\n//# sourceMappingURL=clock.js.map","/** @internal */\nexport const OP_AND = \"And\";\n/** @internal */\nexport const OP_OR = \"Or\";\n/** @internal */\nexport const OP_INVALID_DATA = \"InvalidData\";\n/** @internal */\nexport const OP_MISSING_DATA = \"MissingData\";\n/** @internal */\nexport const OP_SOURCE_UNAVAILABLE = \"SourceUnavailable\";\n/** @internal */\nexport const OP_UNSUPPORTED = \"Unsupported\";\n//# sourceMappingURL=configError.js.map","import * as RA from \"../Array.js\";\nimport * as Either from \"../Either.js\";\nimport { constFalse, constTrue, dual, pipe } from \"../Function.js\";\nimport { hasProperty } from \"../Predicate.js\";\nimport * as OpCodes from \"./opCodes/configError.js\";\n/** @internal */\nconst ConfigErrorSymbolKey = \"effect/ConfigError\";\n/** @internal */\nexport const ConfigErrorTypeId = /*#__PURE__*/Symbol.for(ConfigErrorSymbolKey);\n/** @internal */\nexport const proto = {\n  _tag: \"ConfigError\",\n  [ConfigErrorTypeId]: ConfigErrorTypeId\n};\n/** @internal */\nexport const And = (self, that) => {\n  const error = Object.create(proto);\n  error._op = OpCodes.OP_AND;\n  error.left = self;\n  error.right = that;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      return `${this.left} and ${this.right}`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexport const Or = (self, that) => {\n  const error = Object.create(proto);\n  error._op = OpCodes.OP_OR;\n  error.left = self;\n  error.right = that;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      return `${this.left} or ${this.right}`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexport const InvalidData = (path, message, options = {\n  pathDelim: \".\"\n}) => {\n  const error = Object.create(proto);\n  error._op = OpCodes.OP_INVALID_DATA;\n  error.path = path;\n  error.message = message;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = pipe(this.path, RA.join(options.pathDelim));\n      return `(Invalid data at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexport const MissingData = (path, message, options = {\n  pathDelim: \".\"\n}) => {\n  const error = Object.create(proto);\n  error._op = OpCodes.OP_MISSING_DATA;\n  error.path = path;\n  error.message = message;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = pipe(this.path, RA.join(options.pathDelim));\n      return `(Missing data at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexport const SourceUnavailable = (path, message, cause, options = {\n  pathDelim: \".\"\n}) => {\n  const error = Object.create(proto);\n  error._op = OpCodes.OP_SOURCE_UNAVAILABLE;\n  error.path = path;\n  error.message = message;\n  error.cause = cause;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = pipe(this.path, RA.join(options.pathDelim));\n      return `(Source unavailable at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexport const Unsupported = (path, message, options = {\n  pathDelim: \".\"\n}) => {\n  const error = Object.create(proto);\n  error._op = OpCodes.OP_UNSUPPORTED;\n  error.path = path;\n  error.message = message;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = pipe(this.path, RA.join(options.pathDelim));\n      return `(Unsupported operation at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexport const isConfigError = u => hasProperty(u, ConfigErrorTypeId);\n/** @internal */\nexport const isAnd = self => self._op === OpCodes.OP_AND;\n/** @internal */\nexport const isOr = self => self._op === OpCodes.OP_OR;\n/** @internal */\nexport const isInvalidData = self => self._op === OpCodes.OP_INVALID_DATA;\n/** @internal */\nexport const isMissingData = self => self._op === OpCodes.OP_MISSING_DATA;\n/** @internal */\nexport const isSourceUnavailable = self => self._op === OpCodes.OP_SOURCE_UNAVAILABLE;\n/** @internal */\nexport const isUnsupported = self => self._op === OpCodes.OP_UNSUPPORTED;\n/** @internal */\nexport const prefixed = /*#__PURE__*/dual(2, (self, prefix) => {\n  switch (self._op) {\n    case OpCodes.OP_AND:\n      {\n        return And(prefixed(self.left, prefix), prefixed(self.right, prefix));\n      }\n    case OpCodes.OP_OR:\n      {\n        return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));\n      }\n    case OpCodes.OP_INVALID_DATA:\n      {\n        return InvalidData([...prefix, ...self.path], self.message);\n      }\n    case OpCodes.OP_MISSING_DATA:\n      {\n        return MissingData([...prefix, ...self.path], self.message);\n      }\n    case OpCodes.OP_SOURCE_UNAVAILABLE:\n      {\n        return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);\n      }\n    case OpCodes.OP_UNSUPPORTED:\n      {\n        return Unsupported([...prefix, ...self.path], self.message);\n      }\n  }\n});\n/** @internal */\nconst IsMissingDataOnlyReducer = {\n  andCase: (_, left, right) => left && right,\n  orCase: (_, left, right) => left && right,\n  invalidDataCase: constFalse,\n  missingDataCase: constTrue,\n  sourceUnavailableCase: constFalse,\n  unsupportedCase: constFalse\n};\n/** @internal */\nexport const reduceWithContext = /*#__PURE__*/dual(3, (self, context, reducer) => {\n  const input = [self];\n  const output = [];\n  while (input.length > 0) {\n    const error = input.pop();\n    switch (error._op) {\n      case OpCodes.OP_AND:\n        {\n          input.push(error.right);\n          input.push(error.left);\n          output.push(Either.left({\n            _op: \"AndCase\"\n          }));\n          break;\n        }\n      case OpCodes.OP_OR:\n        {\n          input.push(error.right);\n          input.push(error.left);\n          output.push(Either.left({\n            _op: \"OrCase\"\n          }));\n          break;\n        }\n      case OpCodes.OP_INVALID_DATA:\n        {\n          output.push(Either.right(reducer.invalidDataCase(context, error.path, error.message)));\n          break;\n        }\n      case OpCodes.OP_MISSING_DATA:\n        {\n          output.push(Either.right(reducer.missingDataCase(context, error.path, error.message)));\n          break;\n        }\n      case OpCodes.OP_SOURCE_UNAVAILABLE:\n        {\n          output.push(Either.right(reducer.sourceUnavailableCase(context, error.path, error.message, error.cause)));\n          break;\n        }\n      case OpCodes.OP_UNSUPPORTED:\n        {\n          output.push(Either.right(reducer.unsupportedCase(context, error.path, error.message)));\n          break;\n        }\n    }\n  }\n  const accumulator = [];\n  while (output.length > 0) {\n    const either = output.pop();\n    switch (either._op) {\n      case \"Left\":\n        {\n          switch (either.left._op) {\n            case \"AndCase\":\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.andCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n            case \"OrCase\":\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.orCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Right\":\n        {\n          accumulator.push(either.right);\n          break;\n        }\n    }\n  }\n  if (accumulator.length === 0) {\n    throw new Error(\"BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues\");\n  }\n  return accumulator.pop();\n});\n/** @internal */\nexport const isMissingDataOnly = self => reduceWithContext(self, void 0, IsMissingDataOnlyReducer);\n//# sourceMappingURL=configError.js.map","import * as RA from \"../../Array.js\";\nimport * as Either from \"../../Either.js\";\nimport { dual, pipe } from \"../../Function.js\";\nimport * as List from \"../../List.js\";\nimport * as Option from \"../../Option.js\";\nimport * as configError from \"../configError.js\";\n/** @internal */\nexport const empty = {\n  _tag: \"Empty\"\n};\n/** @internal */\nexport const andThen = /*#__PURE__*/dual(2, (self, that) => ({\n  _tag: \"AndThen\",\n  first: self,\n  second: that\n}));\n/** @internal */\nexport const mapName = /*#__PURE__*/dual(2, (self, f) => andThen(self, {\n  _tag: \"MapName\",\n  f\n}));\n/** @internal */\nexport const nested = /*#__PURE__*/dual(2, (self, name) => andThen(self, {\n  _tag: \"Nested\",\n  name\n}));\n/** @internal */\nexport const unnested = /*#__PURE__*/dual(2, (self, name) => andThen(self, {\n  _tag: \"Unnested\",\n  name\n}));\n/** @internal */\nexport const patch = /*#__PURE__*/dual(2, (path, patch) => {\n  let input = List.of(patch);\n  let output = path;\n  while (List.isCons(input)) {\n    const patch = input.head;\n    switch (patch._tag) {\n      case \"Empty\":\n        {\n          input = input.tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          input = List.cons(patch.first, List.cons(patch.second, input.tail));\n          break;\n        }\n      case \"MapName\":\n        {\n          output = RA.map(output, patch.f);\n          input = input.tail;\n          break;\n        }\n      case \"Nested\":\n        {\n          output = RA.prepend(output, patch.name);\n          input = input.tail;\n          break;\n        }\n      case \"Unnested\":\n        {\n          const containsName = pipe(RA.head(output), Option.contains(patch.name));\n          if (containsName) {\n            output = RA.tailNonEmpty(output);\n            input = input.tail;\n          } else {\n            return Either.left(configError.MissingData(output, `Expected ${patch.name} to be in path in ConfigProvider#unnested`));\n          }\n          break;\n        }\n    }\n  }\n  return Either.right(output);\n});\n//# sourceMappingURL=pathPatch.js.map","import * as Arr from \"../Array.js\";\nimport * as Context from \"../Context.js\";\nimport * as Either from \"../Either.js\";\nimport { dual, pipe } from \"../Function.js\";\nimport * as HashMap from \"../HashMap.js\";\nimport * as HashSet from \"../HashSet.js\";\nimport * as number from \"../Number.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport * as Predicate from \"../Predicate.js\";\nimport * as regexp from \"../RegExp.js\";\nimport * as configError from \"./configError.js\";\nimport * as pathPatch from \"./configProvider/pathPatch.js\";\nimport * as core from \"./core.js\";\nimport * as OpCodes from \"./opCodes/config.js\";\nimport * as StringUtils from \"./string-utils.js\";\nconst concat = (l, r) => [...l, ...r];\n/** @internal */\nconst ConfigProviderSymbolKey = \"effect/ConfigProvider\";\n/** @internal */\nexport const ConfigProviderTypeId = /*#__PURE__*/Symbol.for(ConfigProviderSymbolKey);\n/** @internal */\nexport const configProviderTag = /*#__PURE__*/Context.GenericTag(\"effect/ConfigProvider\");\n/** @internal */\nconst FlatConfigProviderSymbolKey = \"effect/ConfigProviderFlat\";\n/** @internal */\nexport const FlatConfigProviderTypeId = /*#__PURE__*/Symbol.for(FlatConfigProviderSymbolKey);\n/** @internal */\nexport const make = options => ({\n  [ConfigProviderTypeId]: ConfigProviderTypeId,\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  ...options\n});\n/** @internal */\nexport const makeFlat = options => ({\n  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,\n  patch: options.patch,\n  load: (path, config, split = true) => options.load(path, config, split),\n  enumerateChildren: options.enumerateChildren\n});\n/** @internal */\nexport const fromFlat = flat => make({\n  load: config => core.flatMap(fromFlatLoop(flat, Arr.empty(), config, false), chunk => Option.match(Arr.head(chunk), {\n    onNone: () => core.fail(configError.MissingData(Arr.empty(), `Expected a single value having structure: ${config}`)),\n    onSome: core.succeed\n  })),\n  flattened: flat\n});\n/** @internal */\nexport const fromEnv = options => {\n  const {\n    pathDelim,\n    seqDelim\n  } = Object.assign({}, {\n    pathDelim: \"_\",\n    seqDelim: \",\"\n  }, options);\n  const makePathString = path => pipe(path, Arr.join(pathDelim));\n  const unmakePathString = pathString => pathString.split(pathDelim);\n  const getEnv = () => typeof process !== \"undefined\" && \"env\" in process && typeof process.env === \"object\" ? process.env : {};\n  const load = (path, primitive, split = true) => {\n    const pathString = makePathString(path);\n    const current = getEnv();\n    const valueOpt = pathString in current ? Option.some(current[pathString]) : Option.none();\n    return pipe(valueOpt, core.mapError(() => configError.MissingData(path, `Expected ${pathString} to exist in the process context`)), core.flatMap(value => parsePrimitive(value, path, primitive, seqDelim, split)));\n  };\n  const enumerateChildren = path => core.sync(() => {\n    const current = getEnv();\n    const keys = Object.keys(current);\n    const keyPaths = keys.map(value => unmakePathString(value.toUpperCase()));\n    const filteredKeyPaths = keyPaths.filter(keyPath => {\n      for (let i = 0; i < path.length; i++) {\n        const pathComponent = pipe(path, Arr.unsafeGet(i));\n        const currentElement = keyPath[i];\n        if (currentElement === undefined || pathComponent !== currentElement) {\n          return false;\n        }\n      }\n      return true;\n    }).flatMap(keyPath => keyPath.slice(path.length, path.length + 1));\n    return HashSet.fromIterable(filteredKeyPaths);\n  });\n  return fromFlat(makeFlat({\n    load,\n    enumerateChildren,\n    patch: pathPatch.empty\n  }));\n};\n/** @internal */\nexport const fromMap = (map, config) => {\n  const {\n    pathDelim,\n    seqDelim\n  } = Object.assign({\n    seqDelim: \",\",\n    pathDelim: \".\"\n  }, config);\n  const makePathString = path => pipe(path, Arr.join(pathDelim));\n  const unmakePathString = pathString => pathString.split(pathDelim);\n  const mapWithIndexSplit = splitIndexInKeys(map, str => unmakePathString(str), makePathString);\n  const load = (path, primitive, split = true) => {\n    const pathString = makePathString(path);\n    const valueOpt = mapWithIndexSplit.has(pathString) ? Option.some(mapWithIndexSplit.get(pathString)) : Option.none();\n    return pipe(valueOpt, core.mapError(() => configError.MissingData(path, `Expected ${pathString} to exist in the provided map`)), core.flatMap(value => parsePrimitive(value, path, primitive, seqDelim, split)));\n  };\n  const enumerateChildren = path => core.sync(() => {\n    const keyPaths = Arr.fromIterable(mapWithIndexSplit.keys()).map(unmakePathString);\n    const filteredKeyPaths = keyPaths.filter(keyPath => {\n      for (let i = 0; i < path.length; i++) {\n        const pathComponent = pipe(path, Arr.unsafeGet(i));\n        const currentElement = keyPath[i];\n        if (currentElement === undefined || pathComponent !== currentElement) {\n          return false;\n        }\n      }\n      return true;\n    }).flatMap(keyPath => keyPath.slice(path.length, path.length + 1));\n    return HashSet.fromIterable(filteredKeyPaths);\n  });\n  return fromFlat(makeFlat({\n    load,\n    enumerateChildren,\n    patch: pathPatch.empty\n  }));\n};\nconst extend = (leftDef, rightDef, left, right) => {\n  const leftPad = Arr.unfold(left.length, index => index >= right.length ? Option.none() : Option.some([leftDef(index), index + 1]));\n  const rightPad = Arr.unfold(right.length, index => index >= left.length ? Option.none() : Option.some([rightDef(index), index + 1]));\n  const leftExtension = concat(left, leftPad);\n  const rightExtension = concat(right, rightPad);\n  return [leftExtension, rightExtension];\n};\nconst appendConfigPath = (path, config) => {\n  let op = config;\n  if (op._tag === \"Nested\") {\n    const out = path.slice();\n    while (op._tag === \"Nested\") {\n      out.push(op.name);\n      op = op.config;\n    }\n    return out;\n  }\n  return path;\n};\nconst fromFlatLoop = (flat, prefix, config, split) => {\n  const op = config;\n  switch (op._tag) {\n    case OpCodes.OP_CONSTANT:\n      {\n        return core.succeed(Arr.of(op.value));\n      }\n    case OpCodes.OP_DESCRIBED:\n      {\n        return core.suspend(() => fromFlatLoop(flat, prefix, op.config, split));\n      }\n    case OpCodes.OP_FAIL:\n      {\n        return core.fail(configError.MissingData(prefix, op.message));\n      }\n    case OpCodes.OP_FALLBACK:\n      {\n        return pipe(core.suspend(() => fromFlatLoop(flat, prefix, op.first, split)), core.catchAll(error1 => {\n          if (op.condition(error1)) {\n            return pipe(fromFlatLoop(flat, prefix, op.second, split), core.catchAll(error2 => core.fail(configError.Or(error1, error2))));\n          }\n          return core.fail(error1);\n        }));\n      }\n    case OpCodes.OP_LAZY:\n      {\n        return core.suspend(() => fromFlatLoop(flat, prefix, op.config(), split));\n      }\n    case OpCodes.OP_MAP_OR_FAIL:\n      {\n        return core.suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split), core.flatMap(core.forEachSequential(a => pipe(op.mapOrFail(a), core.mapError(configError.prefixed(appendConfigPath(prefix, op.original))))))));\n      }\n    case OpCodes.OP_NESTED:\n      {\n        return core.suspend(() => fromFlatLoop(flat, concat(prefix, Arr.of(op.name)), op.config, split));\n      }\n    case OpCodes.OP_PRIMITIVE:\n      {\n        return pipe(pathPatch.patch(prefix, flat.patch), core.flatMap(prefix => pipe(flat.load(prefix, op, split), core.flatMap(values => {\n          if (values.length === 0) {\n            const name = pipe(Arr.last(prefix), Option.getOrElse(() => \"<n/a>\"));\n            return core.fail(configError.MissingData([], `Expected ${op.description} with name ${name}`));\n          }\n          return core.succeed(values);\n        }))));\n      }\n    case OpCodes.OP_SEQUENCE:\n      {\n        return pipe(pathPatch.patch(prefix, flat.patch), core.flatMap(patchedPrefix => pipe(flat.enumerateChildren(patchedPrefix), core.flatMap(indicesFrom), core.flatMap(indices => {\n          if (indices.length === 0) {\n            return core.suspend(() => core.map(fromFlatLoop(flat, prefix, op.config, true), Arr.of));\n          }\n          return pipe(core.forEachSequential(indices, index => fromFlatLoop(flat, Arr.append(prefix, `[${index}]`), op.config, true)), core.map(chunkChunk => {\n            const flattened = Arr.flatten(chunkChunk);\n            if (flattened.length === 0) {\n              return Arr.of(Arr.empty());\n            }\n            return Arr.of(flattened);\n          }));\n        }))));\n      }\n    case OpCodes.OP_HASHMAP:\n      {\n        return core.suspend(() => pipe(pathPatch.patch(prefix, flat.patch), core.flatMap(prefix => pipe(flat.enumerateChildren(prefix), core.flatMap(keys => {\n          return pipe(keys, core.forEachSequential(key => fromFlatLoop(flat, concat(prefix, Arr.of(key)), op.valueConfig, split)), core.map(matrix => {\n            if (matrix.length === 0) {\n              return Arr.of(HashMap.empty());\n            }\n            return pipe(transpose(matrix), Arr.map(values => HashMap.fromIterable(Arr.zip(Arr.fromIterable(keys), values))));\n          }));\n        })))));\n      }\n    case OpCodes.OP_ZIP_WITH:\n      {\n        return core.suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split), core.either, core.flatMap(left => pipe(fromFlatLoop(flat, prefix, op.right, split), core.either, core.flatMap(right => {\n          if (Either.isLeft(left) && Either.isLeft(right)) {\n            return core.fail(configError.And(left.left, right.left));\n          }\n          if (Either.isLeft(left) && Either.isRight(right)) {\n            return core.fail(left.left);\n          }\n          if (Either.isRight(left) && Either.isLeft(right)) {\n            return core.fail(right.left);\n          }\n          if (Either.isRight(left) && Either.isRight(right)) {\n            const path = pipe(prefix, Arr.join(\".\"));\n            const fail = fromFlatLoopFail(prefix, path);\n            const [lefts, rights] = extend(fail, fail, pipe(left.right, Arr.map(Either.right)), pipe(right.right, Arr.map(Either.right)));\n            return pipe(lefts, Arr.zip(rights), core.forEachSequential(([left, right]) => pipe(core.zip(left, right), core.map(([left, right]) => op.zip(left, right)))));\n          }\n          throw new Error(\"BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues\");\n        })))));\n      }\n  }\n};\nconst fromFlatLoopFail = (prefix, path) => index => Either.left(configError.MissingData(prefix, `The element at index ${index} in a sequence at path \"${path}\" was missing`));\n/** @internal */\nexport const mapInputPath = /*#__PURE__*/dual(2, (self, f) => fromFlat(mapInputPathFlat(self.flattened, f)));\nconst mapInputPathFlat = (self, f) => makeFlat({\n  load: (path, config, split = true) => self.load(path, config, split),\n  enumerateChildren: path => self.enumerateChildren(path),\n  patch: pathPatch.mapName(self.patch, f)\n});\n/** @internal */\nexport const nested = /*#__PURE__*/dual(2, (self, name) => fromFlat(makeFlat({\n  load: (path, config) => self.flattened.load(path, config, true),\n  enumerateChildren: path => self.flattened.enumerateChildren(path),\n  patch: pathPatch.nested(self.flattened.patch, name)\n})));\n/** @internal */\nexport const unnested = /*#__PURE__*/dual(2, (self, name) => fromFlat(makeFlat({\n  load: (path, config) => self.flattened.load(path, config, true),\n  enumerateChildren: path => self.flattened.enumerateChildren(path),\n  patch: pathPatch.unnested(self.flattened.patch, name)\n})));\n/** @internal */\nexport const orElse = /*#__PURE__*/dual(2, (self, that) => fromFlat(orElseFlat(self.flattened, () => that().flattened)));\nconst orElseFlat = (self, that) => makeFlat({\n  load: (path, config, split) => pipe(pathPatch.patch(path, self.patch), core.flatMap(patch => self.load(patch, config, split)), core.catchAll(error1 => pipe(core.sync(that), core.flatMap(that => pipe(pathPatch.patch(path, that.patch), core.flatMap(patch => that.load(patch, config, split)), core.catchAll(error2 => core.fail(configError.Or(error1, error2)))))))),\n  enumerateChildren: path => pipe(pathPatch.patch(path, self.patch), core.flatMap(patch => self.enumerateChildren(patch)), core.either, core.flatMap(left => pipe(core.sync(that), core.flatMap(that => pipe(pathPatch.patch(path, that.patch), core.flatMap(patch => that.enumerateChildren(patch)), core.either, core.flatMap(right => {\n    if (Either.isLeft(left) && Either.isLeft(right)) {\n      return core.fail(configError.And(left.left, right.left));\n    }\n    if (Either.isLeft(left) && Either.isRight(right)) {\n      return core.succeed(right.right);\n    }\n    if (Either.isRight(left) && Either.isLeft(right)) {\n      return core.succeed(left.right);\n    }\n    if (Either.isRight(left) && Either.isRight(right)) {\n      return core.succeed(pipe(left.right, HashSet.union(right.right)));\n    }\n    throw new Error(\"BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/effect/issues\");\n  })))))),\n  patch: pathPatch.empty\n});\n/** @internal */\nexport const constantCase = self => mapInputPath(self, StringUtils.constantCase);\n/** @internal */\nexport const kebabCase = self => mapInputPath(self, StringUtils.kebabCase);\n/** @internal */\nexport const lowerCase = self => mapInputPath(self, StringUtils.lowerCase);\n/** @internal */\nexport const snakeCase = self => mapInputPath(self, StringUtils.snakeCase);\n/** @internal */\nexport const upperCase = self => mapInputPath(self, StringUtils.upperCase);\n/** @internal */\nexport const within = /*#__PURE__*/dual(3, (self, path, f) => {\n  const unnest = Arr.reduce(path, self, (provider, name) => unnested(provider, name));\n  const nest = Arr.reduceRight(path, f(unnest), (provider, name) => nested(provider, name));\n  return orElse(nest, () => self);\n});\nconst splitPathString = (text, delim) => {\n  const split = text.split(new RegExp(`\\\\s*${regexp.escape(delim)}\\\\s*`));\n  return split;\n};\nconst parsePrimitive = (text, path, primitive, delimiter, split) => {\n  if (!split) {\n    return pipe(primitive.parse(text), core.mapBoth({\n      onFailure: configError.prefixed(path),\n      onSuccess: Arr.of\n    }));\n  }\n  return pipe(splitPathString(text, delimiter), core.forEachSequential(char => primitive.parse(char.trim())), core.mapError(configError.prefixed(path)));\n};\nconst transpose = array => {\n  return Object.keys(array[0]).map(column => array.map(row => row[column]));\n};\nconst indicesFrom = quotedIndices => pipe(core.forEachSequential(quotedIndices, parseQuotedIndex), core.mapBoth({\n  onFailure: () => Arr.empty(),\n  onSuccess: Arr.sort(number.Order)\n}), core.either, core.map(Either.merge));\nconst STR_INDEX_REGEX = /(^.+)(\\[(\\d+)\\])$/;\nconst QUOTED_INDEX_REGEX = /^(\\[(\\d+)\\])$/;\nconst parseQuotedIndex = str => {\n  const match = str.match(QUOTED_INDEX_REGEX);\n  if (match !== null) {\n    const matchedIndex = match[2];\n    return pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? Option.some(matchedIndex) : Option.none(), Option.flatMap(parseInteger));\n  }\n  return Option.none();\n};\nconst splitIndexInKeys = (map, unmakePathString, makePathString) => {\n  const newMap = new Map();\n  for (const [pathString, value] of map) {\n    const keyWithIndex = pipe(unmakePathString(pathString), Arr.flatMap(key => Option.match(splitIndexFrom(key), {\n      onNone: () => Arr.of(key),\n      onSome: ([key, index]) => Arr.make(key, `[${index}]`)\n    })));\n    newMap.set(makePathString(keyWithIndex), value);\n  }\n  return newMap;\n};\nconst splitIndexFrom = key => {\n  const match = key.match(STR_INDEX_REGEX);\n  if (match !== null) {\n    const matchedString = match[1];\n    const matchedIndex = match[3];\n    const optionalString = matchedString !== undefined && matchedString.length > 0 ? Option.some(matchedString) : Option.none();\n    const optionalIndex = pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? Option.some(matchedIndex) : Option.none(), Option.flatMap(parseInteger));\n    return Option.all([optionalString, optionalIndex]);\n  }\n  return Option.none();\n};\nconst parseInteger = str => {\n  const parsedIndex = Number.parseInt(str);\n  return Number.isNaN(parsedIndex) ? Option.none() : Option.some(parsedIndex);\n};\nconst keyName = name => ({\n  _tag: \"KeyName\",\n  name\n});\nconst keyIndex = index => ({\n  _tag: \"KeyIndex\",\n  index\n});\n/** @internal */\nexport const fromJson = json => {\n  const hiddenDelimiter = \"\\ufeff\";\n  const indexedEntries = Arr.map(getIndexedEntries(json), ([key, value]) => [configPathToString(key).join(hiddenDelimiter), value]);\n  return fromMap(new Map(indexedEntries), {\n    pathDelim: hiddenDelimiter,\n    seqDelim: hiddenDelimiter\n  });\n};\nconst configPathToString = path => {\n  const output = [];\n  let i = 0;\n  while (i < path.length) {\n    const component = path[i];\n    if (component._tag === \"KeyName\") {\n      if (i + 1 < path.length) {\n        const nextComponent = path[i + 1];\n        if (nextComponent._tag === \"KeyIndex\") {\n          output.push(`${component.name}[${nextComponent.index}]`);\n          i += 2;\n        } else {\n          output.push(component.name);\n          i += 1;\n        }\n      } else {\n        output.push(component.name);\n        i += 1;\n      }\n    }\n  }\n  return output;\n};\nconst getIndexedEntries = config => {\n  const loopAny = (path, value) => {\n    if (typeof value === \"string\") {\n      return Arr.make([path, value]);\n    }\n    if (typeof value === \"number\" || typeof value === \"boolean\") {\n      return Arr.make([path, String(value)]);\n    }\n    if (Arr.isArray(value)) {\n      return loopArray(path, value);\n    }\n    if (typeof value === \"object\" && value !== null) {\n      return loopObject(path, value);\n    }\n    return Arr.empty();\n  };\n  const loopArray = (path, values) => Arr.match(values, {\n    onEmpty: () => Arr.make([path, \"<nil>\"]),\n    onNonEmpty: Arr.flatMap((value, index) => loopAny(Arr.append(path, keyIndex(index)), value))\n  });\n  const loopObject = (path, value) => Object.entries(value).filter(([, value]) => Predicate.isNotNullable(value)).flatMap(([key, value]) => {\n    const newPath = Arr.append(path, keyName(key));\n    const result = loopAny(newPath, value);\n    if (Arr.isEmptyReadonlyArray(result)) {\n      return Arr.make([newPath, \"\"]);\n    }\n    return result;\n  });\n  return loopObject(Arr.empty(), config);\n};\n//# sourceMappingURL=configProvider.js.map","/** @internal */\nexport const OP_CONSTANT = \"Constant\";\n/** @internal */\nexport const OP_FAIL = \"Fail\";\n/** @internal */\nexport const OP_FALLBACK = \"Fallback\";\n/** @internal */\nexport const OP_DESCRIBED = \"Described\";\n/** @internal */\nexport const OP_LAZY = \"Lazy\";\n/** @internal */\nexport const OP_MAP_OR_FAIL = \"MapOrFail\";\n/** @internal */\nexport const OP_NESTED = \"Nested\";\n/** @internal */\nexport const OP_PRIMITIVE = \"Primitive\";\n/** @internal */\nexport const OP_SEQUENCE = \"Sequence\";\n/** @internal */\nexport const OP_HASHMAP = \"HashMap\";\n/** @internal */\nexport const OP_ZIP_WITH = \"ZipWith\";\n//# sourceMappingURL=config.js.map","/**\n * This module provides utility functions for working with RegExp in TypeScript.\n *\n * @since 2.0.0\n */\nimport * as predicate from \"./Predicate.js\";\n/**\n * Tests if a value is a `RegExp`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { RegExp } from \"effect\"\n *\n * assert.deepStrictEqual(RegExp.isRegExp(/a/), true)\n * assert.deepStrictEqual(RegExp.isRegExp(\"a\"), false)\n * ```\n *\n * @category guards\n * @since 3.9.0\n */\nexport const isRegExp = predicate.isRegExp;\n/**\n * Escapes special characters in a regular expression pattern.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { RegExp } from \"effect\"\n *\n * assert.deepStrictEqual(RegExp.escape(\"a*b\"), \"a\\\\*b\")\n * ```\n *\n * @since 2.0.0\n */\nexport const escape = string => string.replace(/[/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n//# sourceMappingURL=RegExp.js.map","import * as Context from \"../../Context.js\";\nimport * as core from \"../core.js\";\n/** @internal */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/Console\");\n/** @internal */\nexport const consoleTag = /*#__PURE__*/Context.GenericTag(\"effect/Console\");\n/** @internal */\nexport const defaultConsole = {\n  [TypeId]: TypeId,\n  assert(condition, ...args) {\n    return core.sync(() => {\n      console.assert(condition, ...args);\n    });\n  },\n  clear: /*#__PURE__*/core.sync(() => {\n    console.clear();\n  }),\n  count(label) {\n    return core.sync(() => {\n      console.count(label);\n    });\n  },\n  countReset(label) {\n    return core.sync(() => {\n      console.countReset(label);\n    });\n  },\n  debug(...args) {\n    return core.sync(() => {\n      console.debug(...args);\n    });\n  },\n  dir(item, options) {\n    return core.sync(() => {\n      console.dir(item, options);\n    });\n  },\n  dirxml(...args) {\n    return core.sync(() => {\n      console.dirxml(...args);\n    });\n  },\n  error(...args) {\n    return core.sync(() => {\n      console.error(...args);\n    });\n  },\n  group(options) {\n    return options?.collapsed ? core.sync(() => console.groupCollapsed(options?.label)) : core.sync(() => console.group(options?.label));\n  },\n  groupEnd: /*#__PURE__*/core.sync(() => {\n    console.groupEnd();\n  }),\n  info(...args) {\n    return core.sync(() => {\n      console.info(...args);\n    });\n  },\n  log(...args) {\n    return core.sync(() => {\n      console.log(...args);\n    });\n  },\n  table(tabularData, properties) {\n    return core.sync(() => {\n      console.table(tabularData, properties);\n    });\n  },\n  time(label) {\n    return core.sync(() => console.time(label));\n  },\n  timeEnd(label) {\n    return core.sync(() => console.timeEnd(label));\n  },\n  timeLog(label, ...args) {\n    return core.sync(() => {\n      console.timeLog(label, ...args);\n    });\n  },\n  trace(...args) {\n    return core.sync(() => {\n      console.trace(...args);\n    });\n  },\n  warn(...args) {\n    return core.sync(() => {\n      console.warn(...args);\n    });\n  },\n  unsafe: console\n};\n//# sourceMappingURL=console.js.map","import * as Chunk from \"../Chunk.js\";\nimport * as Context from \"../Context.js\";\nimport { pipe } from \"../Function.js\";\nimport * as Hash from \"../Hash.js\";\nimport * as PCGRandom from \"../Utils.js\";\nimport * as core from \"./core.js\";\n/** @internal */\nconst RandomSymbolKey = \"effect/Random\";\n/** @internal */\nexport const RandomTypeId = /*#__PURE__*/Symbol.for(RandomSymbolKey);\n/** @internal */\nexport const randomTag = /*#__PURE__*/Context.GenericTag(\"effect/Random\");\n/** @internal */\nclass RandomImpl {\n  seed;\n  [RandomTypeId] = RandomTypeId;\n  PRNG;\n  constructor(seed) {\n    this.seed = seed;\n    this.PRNG = new PCGRandom.PCGRandom(seed);\n  }\n  get next() {\n    return core.sync(() => this.PRNG.number());\n  }\n  get nextBoolean() {\n    return core.map(this.next, n => n > 0.5);\n  }\n  get nextInt() {\n    return core.sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));\n  }\n  nextRange(min, max) {\n    return core.map(this.next, n => (max - min) * n + min);\n  }\n  nextIntBetween(min, max) {\n    return core.sync(() => this.PRNG.integer(max - min) + min);\n  }\n  shuffle(elements) {\n    return shuffleWith(elements, n => this.nextIntBetween(0, n));\n  }\n}\nconst shuffleWith = (elements, nextIntBounded) => {\n  return core.suspend(() => pipe(core.sync(() => Array.from(elements)), core.flatMap(buffer => {\n    const numbers = [];\n    for (let i = buffer.length; i >= 2; i = i - 1) {\n      numbers.push(i);\n    }\n    return pipe(numbers, core.forEachSequentialDiscard(n => pipe(nextIntBounded(n), core.map(k => swap(buffer, n - 1, k)))), core.as(Chunk.fromIterable(buffer)));\n  })));\n};\nconst swap = (buffer, index1, index2) => {\n  const tmp = buffer[index1];\n  buffer[index1] = buffer[index2];\n  buffer[index2] = tmp;\n  return buffer;\n};\nexport const make = seed => new RandomImpl(Hash.hash(seed));\n//# sourceMappingURL=random.js.map","/**\n * @since 2.0.0\n */\nimport * as Context from \"../Context.js\";\nimport { constFalse } from \"../Function.js\";\n/** @internal */\nexport const TracerTypeId = /*#__PURE__*/Symbol.for(\"effect/Tracer\");\n/** @internal */\nexport const make = options => ({\n  [TracerTypeId]: TracerTypeId,\n  ...options\n});\n/** @internal */\nexport const tracerTag = /*#__PURE__*/Context.GenericTag(\"effect/Tracer\");\n/** @internal */\nexport const spanTag = /*#__PURE__*/Context.GenericTag(\"effect/ParentSpan\");\nconst randomHexString = /*#__PURE__*/function () {\n  const characters = \"abcdef0123456789\";\n  const charactersLength = characters.length;\n  return function (length) {\n    let result = \"\";\n    for (let i = 0; i < length; i++) {\n      result += characters.charAt(Math.floor(Math.random() * charactersLength));\n    }\n    return result;\n  };\n}();\n/** @internal */\nexport class NativeSpan {\n  name;\n  parent;\n  context;\n  links;\n  startTime;\n  kind;\n  _tag = \"Span\";\n  spanId;\n  traceId = \"native\";\n  sampled = true;\n  status;\n  attributes;\n  events = [];\n  constructor(name, parent, context, links, startTime, kind) {\n    this.name = name;\n    this.parent = parent;\n    this.context = context;\n    this.links = links;\n    this.startTime = startTime;\n    this.kind = kind;\n    this.status = {\n      _tag: \"Started\",\n      startTime\n    };\n    this.attributes = new Map();\n    this.traceId = parent._tag === \"Some\" ? parent.value.traceId : randomHexString(32);\n    this.spanId = randomHexString(16);\n  }\n  end(endTime, exit) {\n    this.status = {\n      _tag: \"Ended\",\n      endTime,\n      exit,\n      startTime: this.status.startTime\n    };\n  }\n  attribute(key, value) {\n    this.attributes.set(key, value);\n  }\n  event(name, startTime, attributes) {\n    this.events.push([name, startTime, attributes ?? {}]);\n  }\n}\n/** @internal */\nexport const nativeTracer = /*#__PURE__*/make({\n  span: (name, parent, context, links, startTime, kind) => new NativeSpan(name, parent, context, links, startTime, kind),\n  context: f => f()\n});\n/** @internal */\nexport const externalSpan = options => ({\n  _tag: \"ExternalSpan\",\n  spanId: options.spanId,\n  traceId: options.traceId,\n  sampled: options.sampled ?? true,\n  context: options.context ?? Context.empty()\n});\n/** @internal */\nexport const addSpanStackTrace = options => {\n  if (options?.captureStackTrace === false) {\n    return options;\n  } else if (options?.captureStackTrace !== undefined && typeof options.captureStackTrace !== \"boolean\") {\n    return options;\n  }\n  const limit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 3;\n  const traceError = new Error();\n  Error.stackTraceLimit = limit;\n  let cache = false;\n  return {\n    ...options,\n    captureStackTrace: () => {\n      if (cache !== false) {\n        return cache;\n      }\n      if (traceError.stack !== undefined) {\n        const stack = traceError.stack.split(\"\\n\");\n        if (stack[3] !== undefined) {\n          cache = stack[3].trim();\n          return cache;\n        }\n      }\n    }\n  };\n};\n/** @internal */\nexport const DisablePropagation = /*#__PURE__*/Context.Reference()(\"effect/Tracer/DisablePropagation\", {\n  defaultValue: constFalse\n});\n//# sourceMappingURL=tracer.js.map","import * as Array from \"../Array.js\";\nimport * as Context from \"../Context.js\";\nimport * as Duration from \"../Duration.js\";\nimport { dual, pipe } from \"../Function.js\";\nimport { globalValue } from \"../GlobalValue.js\";\nimport * as clock from \"./clock.js\";\nimport * as configProvider from \"./configProvider.js\";\nimport * as core from \"./core.js\";\nimport * as console_ from \"./defaultServices/console.js\";\nimport * as random from \"./random.js\";\nimport * as tracer from \"./tracer.js\";\n/** @internal */\nexport const liveServices = /*#__PURE__*/pipe( /*#__PURE__*/Context.empty(), /*#__PURE__*/Context.add(clock.clockTag, /*#__PURE__*/clock.make()), /*#__PURE__*/Context.add(console_.consoleTag, console_.defaultConsole), /*#__PURE__*/Context.add(random.randomTag, /*#__PURE__*/random.make( /*#__PURE__*/Math.random())), /*#__PURE__*/Context.add(configProvider.configProviderTag, /*#__PURE__*/configProvider.fromEnv()), /*#__PURE__*/Context.add(tracer.tracerTag, tracer.nativeTracer));\n/**\n * The `FiberRef` holding the default `Effect` services.\n *\n * @since 2.0.0\n * @category fiberRefs\n */\nexport const currentServices = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"effect/DefaultServices/currentServices\"), () => core.fiberRefUnsafeMakeContext(liveServices));\n// circular with Clock\n/** @internal */\nexport const sleep = duration => {\n  const decodedDuration = Duration.decode(duration);\n  return clockWith(clock => clock.sleep(decodedDuration));\n};\n/** @internal */\nexport const defaultServicesWith = f => core.withFiberRuntime(fiber => f(fiber.currentDefaultServices));\n/** @internal */\nexport const clockWith = f => defaultServicesWith(services => f(services.unsafeMap.get(clock.clockTag.key)));\n/** @internal */\nexport const currentTimeMillis = /*#__PURE__*/clockWith(clock => clock.currentTimeMillis);\n/** @internal */\nexport const currentTimeNanos = /*#__PURE__*/clockWith(clock => clock.currentTimeNanos);\n/** @internal */\nexport const withClock = /*#__PURE__*/dual(2, (effect, c) => core.fiberRefLocallyWith(currentServices, Context.add(clock.clockTag, c))(effect));\n// circular with ConfigProvider\n/** @internal */\nexport const withConfigProvider = /*#__PURE__*/dual(2, (self, provider) => core.fiberRefLocallyWith(currentServices, Context.add(configProvider.configProviderTag, provider))(self));\n/** @internal */\nexport const configProviderWith = f => defaultServicesWith(services => f(services.unsafeMap.get(configProvider.configProviderTag.key)));\n/** @internal */\nexport const config = config => configProviderWith(_ => _.load(config));\n/** @internal */\nexport const configOrDie = config => core.orDie(configProviderWith(_ => _.load(config)));\n// circular with Random\n/** @internal */\nexport const randomWith = f => defaultServicesWith(services => f(services.unsafeMap.get(random.randomTag.key)));\n/** @internal */\nexport const withRandom = /*#__PURE__*/dual(2, (effect, value) => core.fiberRefLocallyWith(currentServices, Context.add(random.randomTag, value))(effect));\n/** @internal */\nexport const next = /*#__PURE__*/randomWith(random => random.next);\n/** @internal */\nexport const nextInt = /*#__PURE__*/randomWith(random => random.nextInt);\n/** @internal */\nexport const nextBoolean = /*#__PURE__*/randomWith(random => random.nextBoolean);\n/** @internal */\nexport const nextRange = (min, max) => randomWith(random => random.nextRange(min, max));\n/** @internal */\nexport const nextIntBetween = (min, max) => randomWith(random => random.nextIntBetween(min, max));\n/** @internal */\nexport const shuffle = elements => randomWith(random => random.shuffle(elements));\n/** @internal */\nexport const choice = elements => {\n  const array = Array.fromIterable(elements);\n  return core.map(array.length === 0 ? core.fail(new core.NoSuchElementException(\"Cannot select a random element from an empty array\")) : randomWith(random => random.nextIntBetween(0, array.length)), i => array[i]);\n};\n// circular with Tracer\n/** @internal */\nexport const tracerWith = f => defaultServicesWith(services => f(services.unsafeMap.get(tracer.tracerTag.key)));\n/** @internal */\nexport const withTracer = /*#__PURE__*/dual(2, (effect, value) => core.fiberRefLocallyWith(currentServices, Context.add(tracer.tracerTag, value))(effect));\n//# sourceMappingURL=defaultServices.js.map","import * as Arr from \"../Array.js\";\nimport * as Context from \"../Context.js\";\nimport * as FiberRefs from \"../FiberRefs.js\";\nimport { constVoid, dual } from \"../Function.js\";\nimport { globalValue } from \"../GlobalValue.js\";\nimport * as HashMap from \"../HashMap.js\";\nimport * as Inspectable from \"../Inspectable.js\";\nimport * as List from \"../List.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\nimport * as Cause from \"./cause.js\";\nimport * as defaultServices from \"./defaultServices.js\";\nimport { consoleTag } from \"./defaultServices/console.js\";\nimport * as fiberId_ from \"./fiberId.js\";\nimport * as logSpan_ from \"./logSpan.js\";\n/** @internal */\nconst LoggerSymbolKey = \"effect/Logger\";\n/** @internal */\nexport const LoggerTypeId = /*#__PURE__*/Symbol.for(LoggerSymbolKey);\nconst loggerVariance = {\n  /* c8 ignore next */\n  _Message: _ => _,\n  /* c8 ignore next */\n  _Output: _ => _\n};\n/** @internal */\nexport const makeLogger = log => ({\n  [LoggerTypeId]: loggerVariance,\n  log,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n});\n/** @internal */\nexport const mapInput = /*#__PURE__*/dual(2, (self, f) => makeLogger(options => self.log({\n  ...options,\n  message: f(options.message)\n})));\n/** @internal */\nexport const mapInputOptions = /*#__PURE__*/dual(2, (self, f) => makeLogger(options => self.log(f(options))));\n/** @internal */\nexport const filterLogLevel = /*#__PURE__*/dual(2, (self, f) => makeLogger(options => f(options.logLevel) ? Option.some(self.log(options)) : Option.none()));\n/** @internal */\nexport const map = /*#__PURE__*/dual(2, (self, f) => makeLogger(options => f(self.log(options))));\n/** @internal */\nexport const none = {\n  [LoggerTypeId]: loggerVariance,\n  log: constVoid,\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\n/** @internal */\nexport const simple = log => ({\n  [LoggerTypeId]: loggerVariance,\n  log: ({\n    message\n  }) => log(message),\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n});\n/** @internal */\nexport const succeed = value => {\n  return simple(() => value);\n};\n/** @internal */\nexport const sync = evaluate => {\n  return simple(evaluate);\n};\n/** @internal */\nexport const zip = /*#__PURE__*/dual(2, (self, that) => makeLogger(options => [self.log(options), that.log(options)]));\n/** @internal */\nexport const zipLeft = /*#__PURE__*/dual(2, (self, that) => map(zip(self, that), tuple => tuple[0]));\n/** @internal */\nexport const zipRight = /*#__PURE__*/dual(2, (self, that) => map(zip(self, that), tuple => tuple[1]));\n/**\n * Match strings that do not contain any whitespace characters, double quotes,\n * or equal signs.\n *\n * @internal\n */\nconst textOnly = /^[^\\s\"=]*$/;\n/**\n * Used by both {@link stringLogger} and {@link logfmtLogger} to render a log\n * message.\n *\n * @internal\n */\nconst format = (quoteValue, whitespace) => ({\n  annotations,\n  cause,\n  date,\n  fiberId,\n  logLevel,\n  message,\n  spans\n}) => {\n  const formatValue = value => value.match(textOnly) ? value : quoteValue(value);\n  const format = (label, value) => `${logSpan_.formatLabel(label)}=${formatValue(value)}`;\n  const append = (label, value) => \" \" + format(label, value);\n  let out = format(\"timestamp\", date.toISOString());\n  out += append(\"level\", logLevel.label);\n  out += append(\"fiber\", fiberId_.threadName(fiberId));\n  const messages = Arr.ensure(message);\n  for (let i = 0; i < messages.length; i++) {\n    out += append(\"message\", Inspectable.toStringUnknown(messages[i], whitespace));\n  }\n  if (!Cause.isEmptyType(cause)) {\n    out += append(\"cause\", Cause.pretty(cause, {\n      renderErrorCause: true\n    }));\n  }\n  for (const span of spans) {\n    out += \" \" + logSpan_.render(date.getTime())(span);\n  }\n  for (const [label, value] of annotations) {\n    out += append(label, Inspectable.toStringUnknown(value, whitespace));\n  }\n  return out;\n};\n/** @internal */\nconst escapeDoubleQuotes = s => `\"${s.replace(/\\\\([\\s\\S])|(\")/g, \"\\\\$1$2\")}\"`;\n/** @internal */\nexport const stringLogger = /*#__PURE__*/makeLogger( /*#__PURE__*/format(escapeDoubleQuotes));\n/** @internal */\nexport const logfmtLogger = /*#__PURE__*/makeLogger( /*#__PURE__*/format(JSON.stringify, 0));\n/** @internal */\nexport const structuredLogger = /*#__PURE__*/makeLogger(({\n  annotations,\n  cause,\n  date,\n  fiberId,\n  logLevel,\n  message,\n  spans\n}) => {\n  const now = date.getTime();\n  const annotationsObj = {};\n  const spansObj = {};\n  if (HashMap.size(annotations) > 0) {\n    for (const [k, v] of annotations) {\n      annotationsObj[k] = structuredMessage(v);\n    }\n  }\n  if (List.isCons(spans)) {\n    for (const span of spans) {\n      spansObj[span.label] = now - span.startTime;\n    }\n  }\n  const messageArr = Arr.ensure(message);\n  return {\n    message: messageArr.length === 1 ? structuredMessage(messageArr[0]) : messageArr.map(structuredMessage),\n    logLevel: logLevel.label,\n    timestamp: date.toISOString(),\n    cause: Cause.isEmpty(cause) ? undefined : Cause.pretty(cause, {\n      renderErrorCause: true\n    }),\n    annotations: annotationsObj,\n    spans: spansObj,\n    fiberId: fiberId_.threadName(fiberId)\n  };\n});\n/** @internal */\nexport const structuredMessage = u => {\n  switch (typeof u) {\n    case \"bigint\":\n    case \"function\":\n    case \"symbol\":\n      {\n        return String(u);\n      }\n    default:\n      {\n        return Inspectable.toJSON(u);\n      }\n  }\n};\n/** @internal */\nexport const jsonLogger = /*#__PURE__*/map(structuredLogger, Inspectable.stringifyCircular);\n/** @internal */\nexport const isLogger = u => {\n  return typeof u === \"object\" && u != null && LoggerTypeId in u;\n};\nconst withColor = (text, ...colors) => {\n  let out = \"\";\n  for (let i = 0; i < colors.length; i++) {\n    out += `\\x1b[${colors[i]}m`;\n  }\n  return out + text + \"\\x1b[0m\";\n};\nconst withColorNoop = (text, ..._colors) => text;\nconst colors = {\n  bold: \"1\",\n  red: \"31\",\n  green: \"32\",\n  yellow: \"33\",\n  blue: \"34\",\n  cyan: \"36\",\n  white: \"37\",\n  gray: \"90\",\n  black: \"30\",\n  bgBrightRed: \"101\"\n};\nconst logLevelColors = {\n  None: [],\n  All: [],\n  Trace: [colors.gray],\n  Debug: [colors.blue],\n  Info: [colors.green],\n  Warning: [colors.yellow],\n  Error: [colors.red],\n  Fatal: [colors.bgBrightRed, colors.black]\n};\nconst logLevelStyle = {\n  None: \"\",\n  All: \"\",\n  Trace: \"color:gray\",\n  Debug: \"color:blue\",\n  Info: \"color:green\",\n  Warning: \"color:orange\",\n  Error: \"color:red\",\n  Fatal: \"background-color:red;color:white\"\n};\nconst defaultDateFormat = date => `${date.getHours().toString().padStart(2, \"0\")}:${date.getMinutes().toString().padStart(2, \"0\")}:${date.getSeconds().toString().padStart(2, \"0\")}.${date.getMilliseconds().toString().padStart(3, \"0\")}`;\nconst hasProcessStdout = typeof process === \"object\" && process !== null && typeof process.stdout === \"object\" && process.stdout !== null;\nconst processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;\nconst hasProcessStdoutOrDeno = hasProcessStdout || \"Deno\" in globalThis;\n/** @internal */\nexport const prettyLogger = options => {\n  const mode_ = options?.mode ?? \"auto\";\n  const mode = mode_ === \"auto\" ? hasProcessStdoutOrDeno ? \"tty\" : \"browser\" : mode_;\n  const isBrowser = mode === \"browser\";\n  const showColors = typeof options?.colors === \"boolean\" ? options.colors : processStdoutIsTTY || isBrowser;\n  const formatDate = options?.formatDate ?? defaultDateFormat;\n  return isBrowser ? prettyLoggerBrowser({\n    colors: showColors,\n    formatDate\n  }) : prettyLoggerTty({\n    colors: showColors,\n    formatDate,\n    stderr: options?.stderr === true\n  });\n};\nconst prettyLoggerTty = options => {\n  const processIsBun = typeof process === \"object\" && \"isBun\" in process && process.isBun === true;\n  const color = options.colors ? withColor : withColorNoop;\n  return makeLogger(({\n    annotations,\n    cause,\n    context,\n    date,\n    fiberId,\n    logLevel,\n    message: message_,\n    spans\n  }) => {\n    const services = FiberRefs.getOrDefault(context, defaultServices.currentServices);\n    const console = Context.get(services, consoleTag).unsafe;\n    const log = options.stderr === true ? console.error : console.log;\n    const message = Arr.ensure(message_);\n    let firstLine = color(`[${options.formatDate(date)}]`, colors.white) + ` ${color(logLevel.label, ...logLevelColors[logLevel._tag])}` + ` (${fiberId_.threadName(fiberId)})`;\n    if (List.isCons(spans)) {\n      const now = date.getTime();\n      const render = logSpan_.render(now);\n      for (const span of spans) {\n        firstLine += \" \" + render(span);\n      }\n    }\n    firstLine += \":\";\n    let messageIndex = 0;\n    if (message.length > 0) {\n      const firstMaybeString = structuredMessage(message[0]);\n      if (typeof firstMaybeString === \"string\") {\n        firstLine += \" \" + color(firstMaybeString, colors.bold, colors.cyan);\n        messageIndex++;\n      }\n    }\n    log(firstLine);\n    if (!processIsBun) console.group();\n    if (!Cause.isEmpty(cause)) {\n      log(Cause.pretty(cause, {\n        renderErrorCause: true\n      }));\n    }\n    if (messageIndex < message.length) {\n      for (; messageIndex < message.length; messageIndex++) {\n        log(Inspectable.redact(message[messageIndex]));\n      }\n    }\n    if (HashMap.size(annotations) > 0) {\n      for (const [key, value] of annotations) {\n        log(color(`${key}:`, colors.bold, colors.white), Inspectable.redact(value));\n      }\n    }\n    if (!processIsBun) console.groupEnd();\n  });\n};\nconst prettyLoggerBrowser = options => {\n  const color = options.colors ? \"%c\" : \"\";\n  return makeLogger(({\n    annotations,\n    cause,\n    context,\n    date,\n    fiberId,\n    logLevel,\n    message: message_,\n    spans\n  }) => {\n    const services = FiberRefs.getOrDefault(context, defaultServices.currentServices);\n    const console = Context.get(services, consoleTag).unsafe;\n    const message = Arr.ensure(message_);\n    let firstLine = `${color}[${options.formatDate(date)}]`;\n    const firstParams = [];\n    if (options.colors) {\n      firstParams.push(\"color:gray\");\n    }\n    firstLine += ` ${color}${logLevel.label}${color} (${fiberId_.threadName(fiberId)})`;\n    if (options.colors) {\n      firstParams.push(logLevelStyle[logLevel._tag], \"\");\n    }\n    if (List.isCons(spans)) {\n      const now = date.getTime();\n      const render = logSpan_.render(now);\n      for (const span of spans) {\n        firstLine += \" \" + render(span);\n      }\n    }\n    firstLine += \":\";\n    let messageIndex = 0;\n    if (message.length > 0) {\n      const firstMaybeString = structuredMessage(message[0]);\n      if (typeof firstMaybeString === \"string\") {\n        firstLine += ` ${color}${firstMaybeString}`;\n        if (options.colors) {\n          firstParams.push(\"color:deepskyblue\");\n        }\n        messageIndex++;\n      }\n    }\n    console.groupCollapsed(firstLine, ...firstParams);\n    if (!Cause.isEmpty(cause)) {\n      console.error(Cause.pretty(cause, {\n        renderErrorCause: true\n      }));\n    }\n    if (messageIndex < message.length) {\n      for (; messageIndex < message.length; messageIndex++) {\n        console.log(Inspectable.redact(message[messageIndex]));\n      }\n    }\n    if (HashMap.size(annotations) > 0) {\n      for (const [key, value] of annotations) {\n        const redacted = Inspectable.redact(value);\n        if (options.colors) {\n          console.log(`%c${key}:`, \"color:gray\", redacted);\n        } else {\n          console.log(`${key}:`, redacted);\n        }\n      }\n    }\n    console.groupEnd();\n  });\n};\n/** @internal */\nexport const prettyLoggerDefault = /*#__PURE__*/globalValue(\"effect/Logger/prettyLoggerDefault\", () => prettyLogger());\n//# sourceMappingURL=logger.js.map","import * as Context from \"../Context.js\";\nimport { dual } from \"../Function.js\";\nimport * as core from \"./core.js\";\nimport * as defaultServices from \"./defaultServices.js\";\nimport * as defaultConsole from \"./defaultServices/console.js\";\nimport * as fiberRuntime from \"./fiberRuntime.js\";\nimport * as layer from \"./layer.js\";\n/** @internal */\nexport const console = /*#__PURE__*/core.map( /*#__PURE__*/core.fiberRefGet(defaultServices.currentServices), /*#__PURE__*/Context.get(defaultConsole.consoleTag));\n/** @internal */\nexport const consoleWith = f => core.fiberRefGetWith(defaultServices.currentServices, services => f(Context.get(services, defaultConsole.consoleTag)));\n/** @internal */\nexport const withConsole = /*#__PURE__*/dual(2, (effect, value) => core.fiberRefLocallyWith(effect, defaultServices.currentServices, Context.add(defaultConsole.consoleTag, value)));\n/** @internal */\nexport const withConsoleScoped = console => fiberRuntime.fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(defaultConsole.consoleTag, console));\n/** @internal */\nexport const setConsole = console => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(defaultConsole.consoleTag, console)));\n/** @internal */\nexport const assert = (condition, ...args) => consoleWith(_ => _.assert(condition, ...args));\n/** @internal */\nexport const clear = /*#__PURE__*/consoleWith(_ => _.clear);\n/** @internal */\nexport const count = label => consoleWith(_ => _.count(label));\n/** @internal */\nexport const countReset = label => consoleWith(_ => _.countReset(label));\n/** @internal */\nexport const debug = (...args) => consoleWith(_ => _.debug(...args));\n/** @internal */\nexport const dir = (item, options) => consoleWith(_ => _.dir(item, options));\n/** @internal */\nexport const dirxml = (...args) => consoleWith(_ => _.dirxml(...args));\n/** @internal */\nexport const error = (...args) => consoleWith(_ => _.error(...args));\n/** @internal */\nexport const group = options => consoleWith(_ => fiberRuntime.acquireRelease(_.group(options), () => _.groupEnd));\n/** @internal */\nexport const info = (...args) => consoleWith(_ => _.info(...args));\n/** @internal */\nexport const log = (...args) => consoleWith(_ => _.log(...args));\n/** @internal */\nexport const table = (tabularData, properties) => consoleWith(_ => _.table(tabularData, properties));\n/** @internal */\nexport const time = label => consoleWith(_ => fiberRuntime.acquireRelease(_.time(label), () => _.timeEnd(label)));\n/** @internal */\nexport const timeLog = (label, ...args) => consoleWith(_ => _.timeLog(label, ...args));\n/** @internal */\nexport const trace = (...args) => consoleWith(_ => _.trace(...args));\n/** @internal */\nexport const warn = (...args) => consoleWith(_ => _.warn(...args));\n/** @internal */\nexport const withGroup = /*#__PURE__*/dual(args => core.isEffect(args[0]), (self, options) => consoleWith(_ => core.acquireUseRelease(_.group(options), () => self, () => _.groupEnd)));\n/** @internal */\nexport const withTime = /*#__PURE__*/dual(args => core.isEffect(args[0]), (self, label) => consoleWith(_ => core.acquireUseRelease(_.time(label), () => self, () => _.timeEnd(label))));\n//# sourceMappingURL=console.js.map","import * as internal from \"./internal/console.js\";\nimport * as defaultConsole from \"./internal/defaultServices/console.js\";\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport const TypeId = defaultConsole.TypeId;\n/**\n * @since 2.0.0\n * @category context\n */\nexport const Console = defaultConsole.consoleTag;\n/**\n * @since 2.0.0\n * @category default services\n */\nexport const withConsole = internal.withConsole;\n/**\n * @since 2.0.0\n * @category default services\n */\nexport const setConsole = internal.setConsole;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const consoleWith = internal.consoleWith;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const assert = internal.assert;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const clear = internal.clear;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const count = internal.count;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const countReset = internal.countReset;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const debug = internal.debug;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const dir = internal.dir;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const dirxml = internal.dirxml;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const error = internal.error;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const group = internal.group;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const info = internal.info;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const log = internal.log;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const table = internal.table;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const time = internal.time;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const timeLog = internal.timeLog;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const trace = internal.trace;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const warn = internal.warn;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const withGroup = internal.withGroup;\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const withTime = internal.withTime;\n//# sourceMappingURL=Console.js.map","import * as Either from \"../Either.js\";\nimport { identity } from \"../Function.js\";\nimport * as Option from \"../Option.js\";\nimport { pipeArguments } from \"../Pipeable.js\";\n/** @internal */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"@effect/matcher/Matcher\");\nconst TypeMatcherProto = {\n  [TypeId]: {\n    _input: identity,\n    _filters: identity,\n    _remaining: identity,\n    _result: identity,\n    _return: identity\n  },\n  _tag: \"TypeMatcher\",\n  add(_case) {\n    return makeTypeMatcher([...this.cases, _case]);\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nfunction makeTypeMatcher(cases) {\n  const matcher = Object.create(TypeMatcherProto);\n  matcher.cases = cases;\n  return matcher;\n}\nconst ValueMatcherProto = {\n  [TypeId]: {\n    _input: identity,\n    _filters: identity,\n    _result: identity,\n    _return: identity\n  },\n  _tag: \"ValueMatcher\",\n  add(_case) {\n    if (this.value._tag === \"Right\") {\n      return this;\n    }\n    if (_case._tag === \"When\" && _case.guard(this.provided) === true) {\n      return makeValueMatcher(this.provided, Either.right(_case.evaluate(this.provided)));\n    } else if (_case._tag === \"Not\" && _case.guard(this.provided) === false) {\n      return makeValueMatcher(this.provided, Either.right(_case.evaluate(this.provided)));\n    }\n    return this;\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nfunction makeValueMatcher(provided, value) {\n  const matcher = Object.create(ValueMatcherProto);\n  matcher.provided = provided;\n  matcher.value = value;\n  return matcher;\n}\nconst makeWhen = (guard, evaluate) => ({\n  _tag: \"When\",\n  guard,\n  evaluate\n});\nconst makeNot = (guard, evaluate) => ({\n  _tag: \"Not\",\n  guard,\n  evaluate\n});\nconst makePredicate = pattern => {\n  if (typeof pattern === \"function\") {\n    return pattern;\n  } else if (Array.isArray(pattern)) {\n    const predicates = pattern.map(makePredicate);\n    const len = predicates.length;\n    return u => {\n      if (!Array.isArray(u)) {\n        return false;\n      }\n      for (let i = 0; i < len; i++) {\n        if (predicates[i](u[i]) === false) {\n          return false;\n        }\n      }\n      return true;\n    };\n  } else if (pattern !== null && typeof pattern === \"object\") {\n    const keysAndPredicates = Object.entries(pattern).map(([k, p]) => [k, makePredicate(p)]);\n    const len = keysAndPredicates.length;\n    return u => {\n      if (typeof u !== \"object\" || u === null) {\n        return false;\n      }\n      for (let i = 0; i < len; i++) {\n        const [key, predicate] = keysAndPredicates[i];\n        if (!(key in u) || predicate(u[key]) === false) {\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n  return u => u === pattern;\n};\nconst makeOrPredicate = patterns => {\n  const predicates = patterns.map(makePredicate);\n  const len = predicates.length;\n  return u => {\n    for (let i = 0; i < len; i++) {\n      if (predicates[i](u) === true) {\n        return true;\n      }\n    }\n    return false;\n  };\n};\nconst makeAndPredicate = patterns => {\n  const predicates = patterns.map(makePredicate);\n  const len = predicates.length;\n  return u => {\n    for (let i = 0; i < len; i++) {\n      if (predicates[i](u) === false) {\n        return false;\n      }\n    }\n    return true;\n  };\n};\n/** @internal */\nexport const type = () => makeTypeMatcher([]);\n/** @internal */\nexport const value = i => makeValueMatcher(i, Either.left(i));\n/** @internal */\nexport const valueTags = fields => {\n  const match = tagsExhaustive(fields)(makeTypeMatcher([]));\n  return input => match(input);\n};\n/** @internal */\nexport const typeTags = () => fields => {\n  const match = tagsExhaustive(fields)(makeTypeMatcher([]));\n  return input => match(input);\n};\n/** @internal */\nexport const withReturnType = () => self => self;\n/** @internal */\nexport const when = (pattern, f) => self => self.add(makeWhen(makePredicate(pattern), f));\n/** @internal */\nexport const whenOr = (...args) => self => {\n  const onMatch = args[args.length - 1];\n  const patterns = args.slice(0, -1);\n  return self.add(makeWhen(makeOrPredicate(patterns), onMatch));\n};\n/** @internal */\nexport const whenAnd = (...args) => self => {\n  const onMatch = args[args.length - 1];\n  const patterns = args.slice(0, -1);\n  return self.add(makeWhen(makeAndPredicate(patterns), onMatch));\n};\n/** @internal */\nexport const discriminator = field => (...pattern) => {\n  const f = pattern[pattern.length - 1];\n  const values = pattern.slice(0, -1);\n  const pred = values.length === 1 ? _ => _[field] === values[0] : _ => values.includes(_[field]);\n  return self => self.add(makeWhen(pred, f));\n};\n/** @internal */\nexport const discriminatorStartsWith = field => (pattern, f) => {\n  const pred = _ => typeof _[field] === \"string\" && _[field].startsWith(pattern);\n  return self => self.add(makeWhen(pred, f));\n};\n/** @internal */\nexport const discriminators = field => fields => {\n  const predicate = makeWhen(arg => arg != null && arg[field] in fields, data => fields[data[field]](data));\n  return self => self.add(predicate);\n};\n/** @internal */\nexport const discriminatorsExhaustive = field => fields => {\n  const addCases = discriminators(field)(fields);\n  return matcher => exhaustive(addCases(matcher));\n};\n/** @internal */\nexport const tag = /*#__PURE__*/discriminator(\"_tag\");\n/** @internal */\nexport const tagStartsWith = /*#__PURE__*/discriminatorStartsWith(\"_tag\");\n/** @internal */\nexport const tags = /*#__PURE__*/discriminators(\"_tag\");\n/** @internal */\nexport const tagsExhaustive = /*#__PURE__*/discriminatorsExhaustive(\"_tag\");\n/** @internal */\nexport const not = (pattern, f) => self => self.add(makeNot(makePredicate(pattern), f));\n/** @internal */\nexport const nonEmptyString = u => typeof u === \"string\" && u.length > 0;\n/** @internal */\nexport const is = (...literals) => {\n  const len = literals.length;\n  return u => {\n    for (let i = 0; i < len; i++) {\n      if (u === literals[i]) {\n        return true;\n      }\n    }\n    return false;\n  };\n};\n/** @internal */\nexport const any = () => true;\n/** @internal */\nexport const defined = u => u !== undefined && u !== null;\n/** @internal */\nexport const instanceOf = constructor => u => u instanceof constructor;\n/** @internal */\nexport const instanceOfUnsafe = instanceOf;\n/** @internal */\nexport const orElse = f => self => {\n  const result = either(self);\n  if (Either.isEither(result)) {\n    // @ts-expect-error\n    return result._tag === \"Right\" ? result.right : f(result.left);\n  }\n  // @ts-expect-error\n  return input => {\n    const a = result(input);\n    return a._tag === \"Right\" ? a.right : f(a.left);\n  };\n};\n/** @internal */\nexport const orElseAbsurd = self => orElse(() => {\n  throw new Error(\"effect/Match/orElseAbsurd: absurd\");\n})(self);\n/** @internal */\nexport const either = self => {\n  if (self._tag === \"ValueMatcher\") {\n    return self.value;\n  }\n  const len = self.cases.length;\n  if (len === 1) {\n    const _case = self.cases[0];\n    return input => {\n      if (_case._tag === \"When\" && _case.guard(input) === true) {\n        return Either.right(_case.evaluate(input));\n      } else if (_case._tag === \"Not\" && _case.guard(input) === false) {\n        return Either.right(_case.evaluate(input));\n      }\n      return Either.left(input);\n    };\n  }\n  return input => {\n    for (let i = 0; i < len; i++) {\n      const _case = self.cases[i];\n      if (_case._tag === \"When\" && _case.guard(input) === true) {\n        return Either.right(_case.evaluate(input));\n      } else if (_case._tag === \"Not\" && _case.guard(input) === false) {\n        return Either.right(_case.evaluate(input));\n      }\n    }\n    return Either.left(input);\n  };\n};\n/** @internal */\nexport const option = self => {\n  const toEither = either(self);\n  if (Either.isEither(toEither)) {\n    return Either.match(toEither, {\n      onLeft: () => Option.none(),\n      onRight: Option.some\n    });\n  }\n  return input => Either.match(toEither(input), {\n    onLeft: () => Option.none(),\n    onRight: Option.some\n  });\n};\nconst getExhaustiveAbsurdErrorMessage = \"effect/Match/exhaustive: absurd\";\n/** @internal */\nexport const exhaustive = self => {\n  const toEither = either(self);\n  if (Either.isEither(toEither)) {\n    if (toEither._tag === \"Right\") {\n      return toEither.right;\n    }\n    throw new Error(getExhaustiveAbsurdErrorMessage);\n  }\n  return u => {\n    // @ts-expect-error\n    const result = toEither(u);\n    if (result._tag === \"Right\") {\n      return result.right;\n    }\n    throw new Error(getExhaustiveAbsurdErrorMessage);\n  };\n};\n//# sourceMappingURL=matcher.js.map","import * as internal from \"./internal/matcher.js\";\nimport * as Predicate from \"./Predicate.js\";\n/**\n * @category Symbols\n * @since 1.0.0\n */\nexport const MatcherTypeId = internal.TypeId;\n/**\n * Creates a matcher for a specific type.\n *\n * **Details**\n *\n * This function defines a `Matcher` that operates on a given type, allowing you\n * to specify conditions for handling different cases. Once the matcher is\n * created, you can use pattern-matching functions like {@link when} to define\n * how different values should be processed.\n *\n * @see {@link value} for creating a matcher from a specific value.\n *\n * @example\n * ```ts\n * // Title: Matching Numbers and Strings\n * import { Match } from \"effect\"\n *\n * // Create a matcher for values that are either strings or numbers\n * //\n * //      ┌─── (u: string | number) => string\n * //      ▼\n * const match = Match.type<string | number>().pipe(\n *   // Match when the value is a number\n *   Match.when(Match.number, (n) => `number: ${n}`),\n *   // Match when the value is a string\n *   Match.when(Match.string, (s) => `string: ${s}`),\n *   // Ensure all possible cases are handled\n *   Match.exhaustive\n * )\n *\n * console.log(match(0))\n * // Output: \"number: 0\"\n *\n * console.log(match(\"hello\"))\n * // Output: \"string: hello\"\n * ```\n *\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const type = internal.type;\n/**\n * Creates a matcher from a specific value.\n *\n * **Details**\n *\n * This function allows you to define a `Matcher` directly from a given value,\n * rather than from a type. This is useful when working with known values,\n * enabling structured pattern matching on objects, primitives, or any data\n * structure.\n *\n * Once the matcher is created, you can use pattern-matching functions like\n * {@link when} to define how different cases should be handled.\n *\n * @see {@link type} for creating a matcher from a specific type.\n *\n * @example\n * ```ts\n * // Title: Matching an Object by Property\n * import { Match } from \"effect\"\n *\n * const input = { name: \"John\", age: 30 }\n *\n * // Create a matcher for the specific object\n * const result = Match.value(input).pipe(\n *   // Match when the 'name' property is \"John\"\n *   Match.when(\n *     { name: \"John\" },\n *     (user) => `${user.name} is ${user.age} years old`\n *   ),\n *   // Provide a fallback if no match is found\n *   Match.orElse(() => \"Oh, not John\")\n * )\n *\n * console.log(result)\n * // Output: \"John is 30 years old\"\n * ```\n *\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const value = internal.value;\n/**\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const valueTags = internal.valueTags;\n/**\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const typeTags = internal.typeTags;\n/**\n * Ensures that all branches of a matcher return a specific type.\n *\n * **Details**\n *\n * This function enforces a consistent return type across all pattern-matching\n * branches. By specifying a return type, TypeScript will check that every\n * matching condition produces a value of the expected type.\n *\n * **Important:** This function must be the first step in the matcher pipeline.\n * If used later, TypeScript will not enforce type consistency correctly.\n *\n * @example\n * ```ts\n * // Title: Validating Return Type Consistency\n * import { Match } from \"effect\"\n *\n * const match = Match.type<{ a: number } | { b: string }>().pipe(\n *   // Ensure all branches return a string\n *   Match.withReturnType<string>(),\n *   // ❌ Type error: 'number' is not assignable to type 'string'\n *   // @ts-expect-error\n *   Match.when({ a: Match.number }, (_) => _.a),\n *   // ✅ Correct: returns a string\n *   Match.when({ b: Match.string }, (_) => _.b),\n *   Match.exhaustive\n * )\n * ```\n *\n * @since 1.0.0\n */\nexport const withReturnType = internal.withReturnType;\n/**\n * Defines a condition for matching values.\n *\n * **Details**\n *\n * This function enables pattern matching by checking whether a given value\n * satisfies a condition. It supports both direct value comparisons and\n * predicate functions. If the condition is met, the associated function is\n * executed.\n *\n * This function is useful when defining matchers that need to check for\n * specific values or apply logical conditions to determine a match. It works\n * well with structured objects and primitive types.\n *\n * @see {@link whenOr} Use this when multiple patterns should match in a single\n * condition.\n * @see {@link whenAnd} Use this when a value must match all provided patterns.\n * @see {@link orElse} Provides a fallback when no patterns match.\n *\n * @example\n * ```ts\n * // Title: Matching with Values and Predicates\n * import { Match } from \"effect\"\n *\n * // Create a matcher for objects with an \"age\" property\n * const match = Match.type<{ age: number }>().pipe(\n *   // Match when age is greater than 18\n *   Match.when({ age: (age) => age > 18 }, (user) => `Age: ${user.age}`),\n *   // Match when age is exactly 18\n *   Match.when({ age: 18 }, () => \"You can vote\"),\n *   // Fallback case for all other ages\n *   Match.orElse((user) => `${user.age} is too young`)\n * )\n *\n * console.log(match({ age: 20 }))\n * // Output: \"Age: 20\"\n *\n * console.log(match({ age: 18 }))\n * // Output: \"You can vote\"\n *\n * console.log(match({ age: 4 }))\n * // Output: \"4 is too young\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const when = internal.when;\n/**\n * Matches one of multiple patterns in a single condition.\n *\n * **Details**\n *\n * This function allows defining a condition where a value matches any of the\n * provided patterns. If a match is found, the associated function is executed.\n * It simplifies cases where multiple patterns share the same handling logic.\n *\n * Unlike {@link when}, which requires separate conditions for each pattern,\n * this function enables combining them into a single statement, making the\n * matcher more concise.\n *\n * @example\n * ```ts\n * import { Match } from \"effect\"\n *\n * type ErrorType =\n *   | { readonly _tag: \"NetworkError\"; readonly message: string }\n *   | { readonly _tag: \"TimeoutError\"; readonly duration: number }\n *   | { readonly _tag: \"ValidationError\"; readonly field: string }\n *\n * const handleError = Match.type<ErrorType>().pipe(\n *   Match.whenOr(\n *     { _tag: \"NetworkError\" },\n *     { _tag: \"TimeoutError\" },\n *     () => \"Retry the request\"\n *   ),\n *   Match.when({ _tag: \"ValidationError\" }, (_) => `Invalid field: ${_.field}`),\n *   Match.exhaustive\n * )\n *\n * console.log(handleError({ _tag: \"NetworkError\", message: \"No connection\" }))\n * // Output: \"Retry the request\"\n *\n * console.log(handleError({ _tag: \"ValidationError\", field: \"email\" }))\n * // Output: \"Invalid field: email\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const whenOr = internal.whenOr;\n/**\n * Matches a value that satisfies all provided patterns.\n *\n * **Details**\n *\n * This function allows defining a condition where a value must match all the\n * given patterns simultaneously. If the value satisfies every pattern, the\n * associated function is executed.\n *\n * Unlike {@link when}, which matches a single pattern at a time, this function\n * ensures that multiple conditions are met before executing the callback. It is\n * useful when checking for values that need to fulfill multiple criteria at\n * once.\n *\n * @example\n * ```ts\n * import { Match } from \"effect\"\n *\n * type User = { readonly age: number; readonly role: \"admin\" | \"user\" }\n *\n * const checkUser = Match.type<User>().pipe(\n *   Match.whenAnd(\n *     { age: (n) => n >= 18 },\n *     { role: \"admin\" },\n *     () => \"Admin access granted\"\n *   ),\n *   Match.orElse(() => \"Access denied\")\n * )\n *\n * console.log(checkUser({ age: 20, role: \"admin\" }))\n * // Output: \"Admin access granted\"\n *\n * console.log(checkUser({ age: 20, role: \"user\" }))\n * // Output: \"Access denied\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const whenAnd = internal.whenAnd;\n/**\n * Matches values based on a specified discriminant field.\n *\n * **Details**\n *\n * This function is used to define pattern matching on objects that follow a\n * **discriminated union** structure, where a specific field (e.g., `type`,\n * `kind`, `_tag`) determines the variant of the object. It allows matching\n * multiple values of the discriminant and provides a function to handle the\n * matched cases.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n *   Match.discriminator(\"type\")(\"A\", \"B\", (_) => `A or B: ${_.type}`),\n *   Match.discriminator(\"type\")(\"C\", (_) => `C(${_.c})`),\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminator = internal.discriminator;\n/**\n * Matches values where a specified field starts with a given prefix.\n *\n * **Details**\n *\n * This function is useful for working with discriminated unions where the\n * discriminant field follows a hierarchical or namespaced structure. It allows\n * you to match values based on whether the specified field starts with a given\n * prefix, making it easier to handle grouped cases.\n *\n * Instead of checking for exact matches, this function lets you match values\n * that share a common prefix. For example, if your discriminant field contains\n * hierarchical names like `\"A\"`, `\"A.A\"`, and `\"B\"`, you can match all values\n * starting with `\"A\"` using a single rule.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\" } | { type: \"B\" } | { type: \"A.A\" } | {}>(),\n *   Match.discriminatorStartsWith(\"type\")(\"A\", (_) => 1 as const),\n *   Match.discriminatorStartsWith(\"type\")(\"B\", (_) => 2 as const),\n *   Match.orElse((_) => 3 as const)\n * )\n *\n * console.log(match({ type: \"A\" })) // 1\n * console.log(match({ type: \"B\" })) // 2\n * console.log(match({ type: \"A.A\" })) // 1\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminatorStartsWith = internal.discriminatorStartsWith;\n/**\n * Matches values based on a field that serves as a discriminator, mapping each\n * possible value to a corresponding handler.\n *\n * **Details**\n *\n * This function simplifies working with discriminated unions by letting you\n * define a set of handlers for each possible value of a given field. Instead of\n * chaining multiple calls to {@link discriminator}, this function allows\n * defining all possible cases at once using an object where the keys are the\n * possible values of the field, and the values are the corresponding handler\n * functions.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n *   Match.discriminators(\"type\")({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   }),\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminators = internal.discriminators;\n/**\n * Matches values based on a discriminator field and **ensures all cases are\n * handled**.\n *\n * **Details*+\n *\n * This function is similar to {@link discriminators}, but **requires that all\n * possible cases** are explicitly handled. It is useful when working with\n * discriminated unions, where a specific field (e.g., `\"type\"`) determines the\n * shape of an object. Each possible value of the field must have a\n * corresponding handler, ensuring **exhaustiveness checking** at compile time.\n *\n * This function **does not require** `Match.exhaustive` at the end of the\n * pipeline because it enforces exhaustiveness by design.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n *   Match.discriminatorsExhaustive(\"type\")({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   })\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminatorsExhaustive = internal.discriminatorsExhaustive;\n/**\n * The `Match.tag` function allows pattern matching based on the `_tag` field in\n * a [Discriminated Union](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions).\n * You can specify multiple tags to match within a single pattern.\n *\n * **Note**\n *\n * The `Match.tag` function relies on the convention within the Effect ecosystem\n * of naming the tag field as `\"_tag\"`. Ensure that your discriminated unions\n * follow this naming convention for proper functionality.\n *\n * @example\n * ```ts\n * // Title: Matching a Discriminated Union by Tag\n * import { Match } from \"effect\"\n *\n * type Event =\n *   | { readonly _tag: \"fetch\" }\n *   | { readonly _tag: \"success\"; readonly data: string }\n *   | { readonly _tag: \"error\"; readonly error: Error }\n *   | { readonly _tag: \"cancel\" }\n *\n * // Create a Matcher for Either<number, string>\n * const match = Match.type<Event>().pipe(\n *   // Match either \"fetch\" or \"success\"\n *   Match.tag(\"fetch\", \"success\", () => `Ok!`),\n *   // Match \"error\" and extract the error message\n *   Match.tag(\"error\", (event) => `Error: ${event.error.message}`),\n *   // Match \"cancel\"\n *   Match.tag(\"cancel\", () => \"Cancelled\"),\n *   Match.exhaustive\n * )\n *\n * console.log(match({ _tag: \"success\", data: \"Hello\" }))\n * // Output: \"Ok!\"\n *\n * console.log(match({ _tag: \"error\", error: new Error(\"Oops!\") }))\n * // Output: \"Error: Oops!\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tag = internal.tag;\n/**\n * Matches values where the `_tag` field starts with a given prefix.\n *\n * **Details**\n *\n * This function allows you to match on values in a **discriminated union**\n * based on whether the `_tag` field starts with a specified prefix. It is\n * useful for handling hierarchical or namespaced tags, where multiple related\n * cases share a common prefix.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ _tag: \"A\" } | { _tag: \"B\" } | { _tag: \"A.A\" } | {}>(),\n *   Match.tagStartsWith(\"A\", (_) => 1 as const),\n *   Match.tagStartsWith(\"B\", (_) => 2 as const),\n *   Match.orElse((_) => 3 as const)\n * )\n *\n * console.log(match({ _tag: \"A\" })) // 1\n * console.log(match({ _tag: \"B\" })) // 2\n * console.log(match({ _tag: \"A.A\" })) // 1\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tagStartsWith = internal.tagStartsWith;\n/**\n * Matches values based on their `_tag` field, mapping each tag to a\n * corresponding handler.\n *\n * **Details**\n *\n * This function provides a way to handle discriminated unions by mapping `_tag`\n * values to specific functions. Each handler receives the matched value and\n * returns a transformed result. If all possible tags are handled, you can\n * enforce exhaustiveness using `Match.exhaustive` to ensure no case is missed.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ _tag: \"A\"; a: string } | { _tag: \"B\"; b: number } | { _tag: \"C\"; c: boolean }>(),\n *   Match.tags({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   }),\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tags = internal.tags;\n/**\n * Matches values based on their `_tag` field and requires handling of all\n * possible cases.\n *\n * **Details**\n *\n * This function is designed for **discriminated unions** where every possible\n * `_tag` value must have a corresponding handler. Unlike {@link tags}, this\n * function ensures **exhaustiveness**, meaning all cases must be explicitly\n * handled. If a `_tag` value is missing from the mapping, TypeScript will\n * report an error.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ _tag: \"A\"; a: string } | { _tag: \"B\"; b: number } | { _tag: \"C\"; c: boolean }>(),\n *   Match.tagsExhaustive({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   })\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tagsExhaustive = internal.tagsExhaustive;\n/**\n * Excludes a specific value from matching while allowing all others.\n *\n * **Details**\n *\n * This function is useful when you need to **handle all values except one or\n * more specific cases**. Instead of listing all possible matches manually, this\n * function simplifies the logic by allowing you to specify values to exclude.\n * Any excluded value will bypass the provided function and continue matching\n * through other cases.\n *\n * @example\n * ```ts\n * // Title: Ignoring a Specific Value\n * import { Match } from \"effect\"\n *\n * // Create a matcher for string or number values\n * const match = Match.type<string | number>().pipe(\n *   // Match any value except \"hi\", returning \"ok\"\n *   Match.not(\"hi\", () => \"ok\"),\n *   // Fallback case for when the value is \"hi\"\n *   Match.orElse(() => \"fallback\")\n * )\n *\n * console.log(match(\"hello\"))\n * // Output: \"ok\"\n *\n * console.log(match(\"hi\"))\n * // Output: \"fallback\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const not = internal.not;\n/**\n * Matches non-empty strings.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const nonEmptyString = internal.nonEmptyString;\n/**\n * Matches a specific set of literal values (e.g., `Match.is(\"a\", 42, true)`).\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const is = internal.is;\n/**\n * Matches values of type `string`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const string = Predicate.isString;\n/**\n * Matches values of type `number`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const number = Predicate.isNumber;\n/**\n * Matches any value without restrictions.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const any = internal.any;\n/**\n * Matches any defined (non-null and non-undefined) value.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const defined = internal.defined;\n/**\n * Matches values of type `boolean`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const boolean = Predicate.isBoolean;\nconst _undefined = Predicate.isUndefined;\nexport {\n/**\n * Matches the value `undefined`.\n *\n * @category Predicates\n * @since 1.0.0\n */\n_undefined as undefined };\nconst _null = Predicate.isNull;\nexport {\n/**\n * Matches the value `null`.\n *\n * @category Predicates\n * @since 1.0.0\n */\n_null as null };\n/**\n * Matches values of type `bigint`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const bigint = Predicate.isBigInt;\n/**\n * Matches values of type `symbol`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const symbol = Predicate.isSymbol;\n/**\n * Matches values that are instances of `Date`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const date = Predicate.isDate;\n/**\n * Matches objects where keys are `string` or `symbol` and values are `unknown`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const record = Predicate.isRecord;\n/**\n * Matches instances of a given class.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const instanceOf = internal.instanceOf;\n/**\n * @category Predicates\n * @since 1.0.0\n */\nexport const instanceOfUnsafe = internal.instanceOf;\n/**\n * Provides a fallback value when no patterns match.\n *\n * **Details**\n *\n * This function ensures that a matcher always returns a valid result, even if\n * no defined patterns match. It acts as a default case, similar to the\n * `default` clause in a `switch` statement or the final `else` in an `if-else`\n * chain.\n *\n * @example\n * ```ts\n * // Title: Providing a Default Value When No Patterns Match\n * import { Match } from \"effect\"\n *\n * // Create a matcher for string or number values\n * const match = Match.type<string | number>().pipe(\n *   // Match when the value is \"a\"\n *   Match.when(\"a\", () => \"ok\"),\n *   // Fallback when no patterns match\n *   Match.orElse(() => \"fallback\")\n * )\n *\n * console.log(match(\"a\"))\n * // Output: \"ok\"\n *\n * console.log(match(\"b\"))\n * // Output: \"fallback\"\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const orElse = internal.orElse;\n// TODO(4.0): Rename to \"orThrow\"? Like Either.getOrThrow\n/**\n * Throws an error if no pattern matches.\n *\n * **Details**\n *\n * This function finalizes a matcher by ensuring that if no patterns match, an\n * error is thrown. It is useful when all cases should be covered, and any\n * unexpected input should trigger an error instead of returning a default\n * value.\n *\n * When used, this function removes the need for an explicit fallback case and\n * ensures that an unmatched value is never silently ignored.\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const orElseAbsurd = internal.orElseAbsurd;\n/**\n * Wraps the match result in an `Either`, distinguishing matched and unmatched\n * cases.\n *\n * **Details**\n *\n * This function ensures that the result of a matcher is always wrapped in an\n * `Either`, allowing clear differentiation between successful matches\n * (`Right(value)`) and cases where no pattern matched (`Left(unmatched\n * value)`).\n *\n * This approach is particularly useful when handling optional values or when an\n * unmatched case should be explicitly handled rather than returning a default\n * value or throwing an error.\n *\n * @example\n * ```ts\n * // Title: Extracting a User Role with Either\n * import { Match } from \"effect\"\n *\n * type User = { readonly role: \"admin\" | \"editor\" | \"viewer\" }\n *\n * // Create a matcher to extract user roles\n * const getRole = Match.type<User>().pipe(\n *   Match.when({ role: \"admin\" }, () => \"Has full access\"),\n *   Match.when({ role: \"editor\" }, () => \"Can edit content\"),\n *   Match.either // Wrap the result in an Either\n * )\n *\n * console.log(getRole({ role: \"admin\" }))\n * // Output: { _id: 'Either', _tag: 'Right', right: 'Has full access' }\n *\n * console.log(getRole({ role: \"viewer\" }))\n * // Output: { _id: 'Either', _tag: 'Left', left: { role: 'viewer' } }\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const either = internal.either;\n/**\n * Wraps the match result in an `Option`, representing an optional match.\n *\n * **Details**\n *\n * This function ensures that the result of a matcher is wrapped in an `Option`,\n * making it easy to handle cases where no pattern matches. If a match is found,\n * it returns `Some(value)`, otherwise, it returns `None`.\n *\n * This is useful in cases where a missing match is expected and should be\n * handled explicitly rather than throwing an error or returning a default\n * value.\n *\n * @example\n * ```ts\n * // Title: Extracting a User Role with Option\n * import { Match } from \"effect\"\n *\n * type User = { readonly role: \"admin\" | \"editor\" | \"viewer\" }\n *\n * // Create a matcher to extract user roles\n * const getRole = Match.type<User>().pipe(\n *   Match.when({ role: \"admin\" }, () => \"Has full access\"),\n *   Match.when({ role: \"editor\" }, () => \"Can edit content\"),\n *   Match.option // Wrap the result in an Option\n * )\n *\n * console.log(getRole({ role: \"admin\" }))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'Has full access' }\n *\n * console.log(getRole({ role: \"viewer\" }))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const option = internal.option;\n/**\n * The `Match.exhaustive` method finalizes the pattern matching process by\n * ensuring that all possible cases are accounted for. If any case is missing,\n * TypeScript will produce a type error. This is particularly useful when\n * working with unions, as it helps prevent unintended gaps in pattern matching.\n *\n * @example\n * ```ts\n * // Title: Ensuring All Cases Are Covered\n * import { Match } from \"effect\"\n *\n * // Create a matcher for string or number values\n * const match = Match.type<string | number>().pipe(\n *   // Match when the value is a number\n *   Match.when(Match.number, (n) => `number: ${n}`),\n *   // Mark the match as exhaustive, ensuring all cases are handled\n *   // TypeScript will throw an error if any case is missing\n *   // @ts-expect-error Type 'string' is not assignable to type 'never'\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const exhaustive = internal.exhaustive;\n/**\n * @since 1.0.0\n * @category Symbols\n */\nexport const SafeRefinementId = /*#__PURE__*/Symbol.for(\"effect/SafeRefinement\");\nconst Fail = /*#__PURE__*/Symbol.for(\"effect/Fail\");\n//# sourceMappingURL=Match.js.map"],"names":["dual","arity","body","arguments","apply","this","self","RangeError","a","b","length","c","d","e","args","identity","constant","value","constTrue","constFalse","constUndefined","undefined","pipe","ab","bc","cd","de","ef","fg","gh","hi","ret","i","make","isEquivalent","that","mapInput","f","x","y","getCurrentVersion","globalStoreId","version.getCurrentVersion","globalStore","globalValue","id","compute","globalThis","Map","has","set","get","isNumber","input","isFunction","isObject","isRecordOrArray","hasProperty","property","isTagged","tag","isNullable","getBugErrorMessage","message","SingleShotGen$1","SingleShotGen","called","constructor","next","done","Symbol","iterator","PCGRandom","_state","seedHi","seedLo","incHi","incLo","Math","random","Int32Array","_next","add64","getState","setState","state","integer","max","round","number","Number","MAX_SAFE_INTEGER","oldHi","oldLo","out","aHi","aLo","bHi","bLo","c1","c0","lo","imul","mul64","xsHi","xsLo","xorshifted","rot","YieldWrapTypeId","for","YieldWrap","structuralRegionState","enabled","tester","internalCall","name","wrap","fn","tracingFunction","randomHashCache","WeakMap","symbol","hash","string","toString","String","Date","toISOString","isHash","Error","floor","combine","optimize","n","u","Infinity","h","str","charCodeAt","structure","o","keys","structureKeys","Object","array","arr","cached","defineProperty","enumerable","equals","compareBoth","selfType","isEqual","Hash.hash","Array","isArray","every","v","getPrototypeOf","prototype","keysSelf","keysThat","key","equivalence","NodeInspectSymbol","toJSON","map","_","redact","format","JSON","stringify","symbolRedactable","isRedactable","redactableState","fiberRefs","pipeArguments","len","OP_COMMIT","OP_FAILURE","OP_SUCCESS","OP_UPDATE_RUNTIME_FLAGS","EffectTypeId","StreamTypeId","SinkTypeId","ChannelTypeId","effectVariance","_R","_E","_A","_V","EffectPrototype","EffectTypeId$1","_In","_L","_Env","_InErr","_InElem","_InDone","_OutErr","_OutElem","_OutDone","Equal.symbol","Hash.symbol","Hash.cached","Hash.random","StructuralPrototype","Hash.structure","selfKeys","thatKeys","Equal.equals","CommitPrototype","_op","OpCodes.OP_COMMIT","TypeId","CommonProto","TypeId$7","SomeProto","assign","create","_tag","isOption","isSome","Hash.combine","_id","NoneHash","NoneProto","isNone","symbol$1","fa","none","TypeId$6","RightProto","isEither","isRight","right","LeftProto","isLeft","left","ma","either.isEither","either.isLeft","either.isRight","merge","onLeft","onRight","match","compare","option.none","some","option.isNone","option.isSome","onNone","onSome","getOrElse","getOrUndefined","flatMap","contains","containsWith","Equal.equivalence","elements","fromIterable","collection","from","prepend","head","append","last","isEmptyReadonlyArray","isNonEmptyReadonlyArray","isOutOfBound","as","index","O.none","O.some","unsafeGet","headNonEmpty","lastNonEmpty","tailNonEmpty","slice","reverse","sort","O","zip","zipWith","Tuple.make","bs","min","of","flatten","inner","j","push","reduce","unfold","O.isSome","getEquivalence","item","join","sep","Order","order.number","TagTypeId","ReferenceTypeId","STMTypeId","TagProto","_Service","_Identifier","stack","context","ContextProto","TypeId$5","_Services","isContext","unsafeMap","size","k","Hash.number","services","makeContext","_empty","service","add","defaultValueCache","defaultValue","getDefaultValue","error","lines","split","afterAt","splice","serviceNotFoundError","GenericTag","limit","stackTraceLimit","creationError","empty","internal.add","emptyArray","Equivalence.make","toReadonlyArray","_equivalence","ChunkProto","TypeId$4","values","isChunk","Hash.array","backing","makeChunk","chunk","depth","unsafeFromNonEmptyArray","copyToArray","initial","src","srcPos","dest","destPos","copy","RA.reverse","unsafeFromArray","offset","elem","appendAll","drop","diff","abs","nr","nrr","nl","nll","isNonEmpty","unsafeHead","bigint0","BigInt","bigint24","bigint60","bigint1e3","bigint1e6","bigint1e9","DURATION_REGEX","decode","isDuration","millis","isBigInt","nanos","isNaN","zero","infinity","isString","exec","valueStr","unit","micros","seconds","minutes","hours","days","weeks","zeroValue","infinityValue","DurationProto","TypeId$3","hrtime","toHrTime","duration","isFinite","isInteger","toMillis","onMillis","onNanos","_self","options","matchWith","_that","selfNanos","thatNanos","Equivalence","parts","unsafeToNanos","ms","sec","hr","isZero","fragments","pieces","BUCKET_SIZE","pow","MASK","MAX_INDEX_NODE","MIN_ARRAY_NODE","hashFragment","shift","toBitmap","fromBitmap","bitmap","bit","previous","arrayUpdate","mutate","at","arraySpliceOut","newLen","g","EmptyNode","modify","edit","_shift","O.isNone","LeafNode","isEmptyNode","canEditNode","node","mergeLeaves","CollisionNode","children","canEdit","list","updateCollisionList","child","newValue","IndexedNode","mask","frag","indx","exists","_newChild","subNodes","count","ArrayNode","expand","arraySpliceIn","current","newChildren","newChild","removed","pack","mergeLeavesInner","h1","n1","h2","n2","subH1","subH2","currentShift","res","final","Stack.make","HashMapSymbolKey","HashMapTypeId","HashMapProto","HashMapIterator","isHashMap","_size","getHash","Option.isNone","makeImpl","editable","root","_editable","_edit","_root","visitLazy","v0","applyCont","cont","visitLazyChildren","Option.none","Option.isSome","Option.some","Node.isEmptyNode","Node.EmptyNode","Dual.dual","modifyAt","setTree","newRoot","newSize","beginMutation","endMutation","modifyHash","NaN","forEach","toVisit","pop","HashSetSymbolKey","HashSetTypeId","HashSetProto","_keyMap","isHashSet","HM.size","keyMap","HM.empty","HM.beginMutation","transient","HM.set","union","HM.forEach","HS.empty","HS.add","HS.union","FiberIdSymbolKey","FiberIdTypeId","OP_NONE","emptyHash","Hash.string","None","startTimeMillis","isFiberId","entries","entry","toArray","Arr.fromIterable","Equivalence.mapInput","Arr.getEquivalence","ConsProto","TypeId$2","isList","return","tail","makeCons","cons","NilHash","NilProto","_Nil","Structural","Data.Structural","ContextPatchTypeId","variance","PatchProto","_Value","_Patch","EmptyProto","AndThenProto","AddServiceProto","makeAddService","RemoveServiceProto","makeRemoveService","UpdateServiceProto","makeUpdateService","update","first","second","makeAndThen","patch","wasServiceUpdated","patches","Chunk.of","updatedContext","Chunk.isNonEmpty","Chunk.headNonEmpty","Chunk.tailNonEmpty","Chunk.prepend","delete","s","DifferTypeId","DifferProto","_P","environment","params","differ","ContextPatch.empty","ContextPatch.combine","oldValue","missingServices","newService","old","ContextPatch.diff","ContextPatch.patch","active","isEnabled","flag","enable","disable","OP_DIE","OP_EMPTY","OP_FAIL","OP_INTERRUPT","OP_PARALLEL","OP_SEQUENTIAL","CauseSymbolKey","CauseTypeId","proto","flattenCause","isCause","causeEquals","defect","fiberId","failure","pretty","OpCodes.OP_EMPTY","fail","OpCodes.OP_FAIL","die","OpCodes.OP_DIE","interrupt","OpCodes.OP_INTERRUPT","parallel","OpCodes.OP_PARALLEL","sequential","OpCodes.OP_SEQUENTIAL","isInterruptedOnly","reduceWithContext","IsInterruptedOnlyCauseReducer","failureOrCause","option","find","cause","failureOption","Either.right","Either.left","leftStack","rightStack","leftParallel","leftSequential","HashSet.empty","Chunk.empty","par","seq","evaluateCause","HashSet.union","Chunk.appendAll","rightParallel","rightSequential","flattenCauseLoop","causes","flattened","Arr.reduce","updated","HashSet.size","Chunk.reverse","pf","_parallel","_sequential","HashSet.add","Chunk.make","emptyCase","failCase","dieCase","interruptCase","sequentialCase","parallelCase","OP_SEQUENTIAL_CASE","OP_PARALLEL_CASE","onDie","onEmpty","onFail","onInterrupt","onParallel","onSequential","accumulator","reducer","output","either","prettyErrors","renderErrorCause","prefix","PrettyError","span","originalError","originalErrorIsObject","prevLimit","super","prettyErrorMessage","spanSymbol","prettyErrorStack","obj","whitespace","cache","retVal","_key","includes","stringifyCircular","locationRegex","spanToTrace","startsWith","replace","stackFn","locationMatchAll","matchAll","location","Option.getOrUndefined","parent","unknownError","l","r","EffectPrimitive","effect_instruction_i0","effect_instruction_i1","effect_instruction_i2","trace","EffectPrimitiveFailure","exitIsExit","EffectPrimitiveSuccess","withFiberRuntime","withRuntime","effect","succeed","asVoid","custom","wrapper","commit","async_","resume","blockingOn","FiberId.none","backingResume","pendingEffect","proxyResume","cancelerRef","controllerRef","AbortController","signal","abort","void_","catchAll","matchEffect","onFailure","onSuccess","originalSymbol","internalCause.spanSymbol","fiber","failCause","internalCause.fail","currentSpanFromFiber","Proxy","target","p","failSync","evaluate","sync","OpCodes.OP_FAILURE","matchCauseEffect","defects","internalCause.defects","internalCause.electFailures","failures","internalCause.failures","Chunk.unsafeHead","forEachSequential","suspend","whileLoop","while","step","forEachSequentialDiscard","interruptible","OpCodes.OP_UPDATE_RUNTIME_FLAGS","RuntimeFlagsPatch.enable","mapBoth","mapError","internalCause.failureOrCause","onExit","cleanup","uninterruptibleMask","restore","cause1","result","exitFailCause","cause2","internalCause.sequential","success","exitSucceed","zipRight","exitMatch","internalCause.isInterruptedOnly","internalCause.interruptors","OpCodes.OP_SUCCESS","thunk","uninterruptible","RuntimeFlagsPatch.disable","oldFlags","FiberRefTypeId","fiberRefVariance","fiberRefGet","getFiberRef","fiberRefGetWith","fiberRefUnsafeMakePatch","_fiberRef","fork","isEffect","currentSpan","ClockTypeId","clockTag","Context.GenericTag","globalClockScheduler","unsafeSchedule","task","Duration.toMillis","completed","handle","setTimeout","clearTimeout","performanceNowNanos","performance","now","timeOrigin","origin","processOrPerformanceNow","processHrtime","process","bigint","ClockImpl","unsafeCurrentTimeMillis","unsafeCurrentTimeNanos","currentTimeMillis","core.sync","currentTimeNanos","scheduler","core.succeed","sleep","core.async","canceler","core.void","core.asVoid","OP_INVALID_DATA","OP_MISSING_DATA","OP_SOURCE_UNAVAILABLE","OP_UNSUPPORTED","ConfigErrorTypeId","And","Or","InvalidData","path","pathDelim","OpCodes.OP_INVALID_DATA","RA.join","MissingData","OpCodes.OP_MISSING_DATA","SourceUnavailable","OpCodes.OP_SOURCE_UNAVAILABLE","Unsupported","OpCodes.OP_UNSUPPORTED","prefixed","List.of","List.cons","RA.map","RA.prepend","RA.head","Option.contains","configError.MissingData","RA.tailNonEmpty","concat","ConfigProviderTypeId","configProviderTag","FlatConfigProviderTypeId","fromEnv","seqDelim","getEnv","env","flat","load","config","enumerateChildren","makeFlat","primitive","pathString","Arr.join","makePathString","core.mapError","core.flatMap","parsePrimitive","keyPaths","toUpperCase","filteredKeyPaths","filter","keyPath","pathComponent","Arr.unsafeGet","currentElement","HashSet.fromIterable","pathPatch.empty","fromFlatLoop","Option.match","Arr.head","core.fail","op","Arr.of","core.suspend","core.catchAll","error1","condition","error2","configError.Or","original","core.forEachSequential","mapOrFail","configError.prefixed","appendConfigPath","pathPatch.patch","Option.getOrElse","description","patchedPrefix","indicesFrom","indices","core.map","Arr.append","chunkChunk","Arr.flatten","valueConfig","matrix","HashMap.empty","transpose","Arr.map","HashMap.fromIterable","Arr.zip","core.either","Either.isLeft","configError.And","Either.isRight","fromFlatLoopFail","lefts","rights","leftDef","rightDef","leftPad","Arr.unfold","rightPad","extend","core.zip","text","delimiter","delim","RegExp","regexp.escape","splitPathString","char","parse","trim","core.mapBoth","column","row","quotedIndices","parseQuotedIndex","Arr.sort","number.Order","Either.merge","QUOTED_INDEX_REGEX","matchedIndex","Option.flatMap","parseInteger","parsedIndex","parseInt","consoleTag","defaultConsole","TypeId$1","assert","console","clear","label","countReset","debug","dir","dirxml","group","collapsed","groupCollapsed","groupEnd","info","log","table","tabularData","properties","time","timeEnd","timeLog","warn","unsafe","RandomTypeId","randomTag","RandomImpl","seed","PRNG","PCGRandom.PCGRandom","nextBoolean","nextInt","nextRange","nextIntBetween","shuffle","shuffleWith","nextIntBounded","buffer","numbers","core.forEachSequentialDiscard","swap","core.as","RA.fromIterable","index1","index2","tmp","TracerTypeId","tracerTag","randomHexString","characters","charAt","NativeSpan","links","startTime","kind","spanId","traceId","sampled","status","attributes","events","end","endTime","exit","attribute","event","nativeTracer","liveServices","Context.empty","Context.add","clock.clockTag","clock.make","console_.consoleTag","console_.defaultConsole","random.randomTag","random.make","configProvider.configProviderTag","configProvider.fromEnv","tracer.tracerTag","tracer.nativeTracer","currentServices","internalDiffer.environment","core.fiberRefUnsafeMakeContext","stdout","isTTY","consoleWith","core.fiberRefGetWith","defaultServices.currentServices","Context.get","defaultConsole.consoleTag","ValueMatcherProto","_input","_filters","_result","_return","_case","guard","provided","makeValueMatcher","matcher","makePredicate","pattern","predicates","keysAndPredicates","predicate","getExhaustiveAbsurdErrorMessage","when","exhaustive","toEither","cases","Either.isEither"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68]}